<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>Time Slices</title>
<link rel="icon" type="image/svg+xml" href="favicon.svg">
<link rel="apple-touch-icon" href="favicon.svg">
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<style>
  :root {
    --bg: #0a0a0f;
    --surface: #14141f;
    --surface2: #1e1e2e;
    --border: #2a2a3a;
    --text: #e0e0e8;
    --text-dim: #8888a0;
    --accent: #7c6ff7;
    --art: #e06090;
    --lit: #60c0e0;
    --phil: #e0a050;
    --hist: #60e080;
    --conn: #c080e0;
    --font: 'Segoe UI', system-ui, -apple-system, sans-serif;
    --mono: 'SF Mono', 'Fira Code', 'Consolas', monospace;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: var(--font);
    overflow-x: hidden;
  }

  /* Header */
  header {
    position: fixed; top: 0; left: 0; right: 0; z-index: 100;
    background: rgba(10,10,15,0.95);
    backdrop-filter: blur(20px);
    border-bottom: 1px solid var(--border);
    padding: 14px 32px;
  }
  .header-top {
    display: flex; align-items: baseline; justify-content: space-between;
    margin-bottom: 10px;
  }
  .header-left { display: flex; align-items: baseline; }
  .header-right { display: flex; align-items: center; gap: 6px; }
  header h1 {
    font-size: 1.4rem; font-weight: 700;
    background: linear-gradient(135deg, var(--accent), var(--art));
    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  }
  header .subtitle { color: var(--text-dim); font-size: 0.85rem; margin-left: 12px; }

  /* Language switcher */
  .lang-btn {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 3px 10px;
    font-size: 0.75rem;
    font-family: var(--font);
    color: var(--text-dim);
    cursor: pointer;
    transition: all 0.2s ease;
    line-height: 1.4;
  }
  .lang-btn:hover { border-color: var(--text-dim); color: var(--text); }
  .lang-btn.active { background: var(--accent); border-color: var(--accent); color: #fff; }

  /* Thread banner */
  .thread-banner {
    display: none;
    align-items: center;
    gap: 10px;
    margin-top: 10px;
    padding: 8px 14px;
    background: var(--surface2);
    border: 1px solid var(--accent);
    border-radius: 10px;
    font-size: 0.8rem;
    color: var(--text);
    animation: fadeIn 0.2s ease;
  }
  .thread-banner.visible { display: flex; }
  .thread-banner .thread-name {
    font-weight: 600;
    color: var(--accent);
  }
  .thread-banner .thread-close {
    margin-left: auto;
    cursor: pointer;
    color: var(--text-dim);
    font-size: 1.2rem;
    padding: 4px 8px;
    border-radius: 4px;
    transition: background 0.15s ease, color 0.15s ease;
  }
  .thread-banner .thread-close:hover { color: var(--text); background: rgba(255,255,255,0.1); }
  .thread-banner .thread-count { color: var(--text-dim); }

  /* Timeline container */
  .timeline-container {
    margin-top: 110px;
    padding: 40px 32px 80px;
    position: relative;
  }

  /* Central line */
  .timeline-line {
    position: absolute;
    left: 50%;
    top: 0; bottom: 0;
    width: 2px;
    background: linear-gradient(to bottom, transparent, var(--border) 80px, var(--border) calc(100% - 80px), transparent);
    transform: translateX(-50%);
    transition: opacity 0.4s ease;
  }
  .timeline-line.thread-active { opacity: 0.15; }

  /* Entry */
  .entry {
    position: relative;
    width: 45%;
    margin-bottom: 48px;
    cursor: pointer;
    transition: transform 0.2s ease, opacity 0.3s ease, max-height 0.4s ease, margin-bottom 0.4s ease;
  }
  .entry:hover { transform: translateY(-2px); }
  .entry:nth-child(odd) { margin-left: 5%; }
  .entry:nth-child(even) { margin-left: 50%; }
  .entry.thread-hidden {
    max-height: 0;
    margin-bottom: 0;
    opacity: 0;
    pointer-events: none;
    overflow: hidden;
    transition: max-height 0.4s ease, margin-bottom 0.4s ease, opacity 0.3s ease;
  }
  .entry.thread-highlighted { opacity: 1; }

  /* Dot on timeline */
  .entry::before {
    content: '';
    position: absolute;
    top: 24px;
    width: 14px; height: 14px;
    border-radius: 50%;
    background: var(--accent);
    border: 3px solid var(--bg);
    z-index: 2;
    transition: transform 0.2s, box-shadow 0.2s;
  }
  .entry:hover::before {
    transform: scale(1.3);
    box-shadow: 0 0 16px var(--accent);
  }
  .entry:nth-child(odd)::before { right: -32px; }
  .entry:nth-child(even)::before { left: -32px; }

  /* Connector line */
  .entry::after {
    content: '';
    position: absolute;
    top: 30px;
    width: 24px; height: 2px;
    background: var(--border);
  }
  .entry:nth-child(odd)::after { right: -24px; }
  .entry:nth-child(even)::after { left: -24px; }

  /* Card */
  .card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 12px;
    overflow: hidden;
    transition: border-color 0.2s, box-shadow 0.2s;
    position: relative;
    max-width: 100%;
    box-sizing: border-box;
  }

  /* ‚òï Fresh entry badge */
  .fresh-badge {
    position: absolute;
    top: 12px;
    right: 12px;
    width: 36px;
    height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.1rem;
    border-radius: 50%;
    background: rgba(124, 111, 247, 0.15);
    border: 2px solid var(--accent);
    z-index: 10;
    pointer-events: none;
    animation: freshPulse 3s ease-in-out infinite;
  }
  @keyframes freshPulse {
    0%, 100% { box-shadow: 0 0 0 0 rgba(124, 111, 247, 0.3); }
    50% { box-shadow: 0 0 12px 4px rgba(124, 111, 247, 0.15); }
  }

  /* üé≤ Random dice button */
  /* Floating action buttons below header */
  .quick-actions {
    position: fixed;
    top: 72px;
    right: 32px;
    z-index: 99;
    display: flex;
    gap: 10px;
    align-items: center;
  }
  .quick-btn {
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.3rem;
    border: none;
    border-radius: 50%;
    background: rgba(124, 111, 247, 0.12);
    border: 1.5px solid var(--accent);
    color: var(--text);
    cursor: pointer;
    transition: transform 0.3s ease, box-shadow 0.3s ease, background 0.2s ease;
    backdrop-filter: blur(8px);
  }
  .quick-btn:hover {
    transform: scale(1.12);
    box-shadow: 0 0 16px rgba(124, 111, 247, 0.3);
    background: rgba(124, 111, 247, 0.25);
  }
  .quick-btn:active { transform: scale(0.95); }
  .quick-btn.loading { opacity: 0.4; pointer-events: none; }
  .quick-btn.rolling { animation: diceRoll 0.5s ease-out; }
  @keyframes diceRoll {
    0% { transform: rotate(0deg) scale(1); }
    25% { transform: rotate(90deg) scale(1.2); }
    50% { transform: rotate(180deg) scale(1); }
    75% { transform: rotate(270deg) scale(1.1); }
    100% { transform: rotate(360deg) scale(1); }
  }
  @media (max-width: 600px) {
    .quick-actions { top: 68px; right: 16px; gap: 8px; }
    .quick-btn { width: 36px; height: 36px; font-size: 1.1rem; }
  }
  .entry:hover .card {
    border-color: var(--accent);
    box-shadow: 0 4px 24px rgba(124,111,247,0.15);
  }
  .entry.expanded .card {
    border-color: var(--accent);
    box-shadow: 0 8px 32px rgba(124,111,247,0.2);
  }

  /* Hero image ‚Äî inline (collapsed state + mobile) */
  .card-image-inline {
    width: 100%;
    height: 500px;
    object-fit: cover;
    object-position: center 20%;
    display: block;
    background: var(--surface2);
    opacity: 0;
    transition: opacity 0.4s ease;
  }
  .card-image-inline.loaded { opacity: 1; }
  .entry.expanded .card-image-inline { display: none; }

  .card-image-caption-inline {
    font-size: 0.7rem;
    color: var(--text-dim);
    padding: 4px 24px 0;
    opacity: 0.6;
    font-style: italic;
  }
  .entry.expanded .card-image-caption-inline { display: none; }

  /* Floating image ‚Äî opposite side (expanded state, desktop only) */
  .floating-image {
    display: none;
    position: absolute;
    top: 0;
    width: 50%;
    z-index: 10;
    animation: fadeIn 0.4s ease;
  }
  .entry.expanded .floating-image { display: block; }
  /* Odd entries are on the left ‚Üí image floats right */
  .entry:nth-child(odd) .floating-image { left: calc(100% + 56px); }
  /* Even entries are on the right ‚Üí image floats left */
  .entry:nth-child(even) .floating-image { right: calc(100% + 56px); }

  .floating-image img {
    width: 100%;
    max-height: 500px;
    object-fit: contain;
    border-radius: 12px;
    background: transparent;
    border: none;
    display: block;
  }
  .floating-image .floating-caption {
    font-size: 0.7rem;
    color: var(--text-dim);
    padding: 6px 4px 0;
    opacity: 0.6;
    font-style: italic;
    text-align: center;
  }
  .floating-image .floating-attribution {
    font-size: 0.6rem;
    color: var(--text-dim);
    opacity: 0.4;
    text-align: center;
    padding-top: 2px;
  }

  .card-body {
    padding: 20px 24px;
    overflow-wrap: break-word;
    word-wrap: break-word;
    word-break: break-word;
    min-width: 0;
  }

  .card-year {
    font-family: var(--mono);
    font-size: 0.75rem;
    color: var(--accent);
    letter-spacing: 0.1em;
    text-transform: uppercase;
    margin-bottom: 6px;
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .card-map-link {
    font-size: 0.7rem;
    color: var(--text-dim);
    cursor: pointer;
    opacity: 0.5;
    transition: opacity 0.2s ease, color 0.2s ease;
    text-decoration: none;
    font-family: system-ui, sans-serif;
  }
  .card-map-link:hover {
    opacity: 1;
    color: var(--accent);
  }
  .card-title {
    font-size: 1.15rem;
    font-weight: 600;
    margin-bottom: 8px;
    line-height: 1.3;
  }
  .card-teaser {
    font-size: 0.9rem;
    color: var(--text-dim);
    line-height: 1.5;
  }

  /* Thread tags */
  .card-threads {
    display: flex; flex-wrap: wrap; gap: 6px;
    margin-top: 12px;
  }
  .thread-tag {
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 2px 10px;
    font-size: 0.7rem;
    color: var(--text-dim);
    cursor: pointer;
    transition: all 0.2s ease;
  }
  .thread-tag:hover {
    border-color: var(--accent);
    color: var(--accent);
    background: rgba(124,111,247,0.1);
  }
  .thread-tag.active {
    border-color: var(--accent);
    color: #fff;
    background: var(--accent);
  }

  /* Expanded content */
  .card-details {
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.5s ease, opacity 0.3s ease;
    opacity: 0;
  }
  .entry.expanded .card-details {
    opacity: 1;
    overflow: visible;
    overflow-wrap: break-word;
    word-wrap: break-word;
    word-break: break-word;
  }

  /* Dimension sections */
  .dimension {
    padding: 14px 0;
    border-top: 1px solid var(--border);
    transition: opacity 0.3s ease, max-height 0.3s ease;
  }
  .dimension:first-child { border-top: none; }
  .dim-header {
    display: flex; align-items: center; gap: 8px;
    font-weight: 600; font-size: 0.9rem;
    margin-bottom: 8px;
  }
  .dim-icon { font-size: 1.1rem; }
  .dim-label-art { color: var(--art); }
  .dim-label-lit { color: var(--lit); }
  .dim-label-phil { color: var(--phil); }
  .dim-label-hist { color: var(--hist); }
  .dim-label-conn { color: var(--conn); }

  .dim-content {
    font-size: 0.88rem;
    line-height: 1.7;
    color: var(--text-dim);
    overflow-wrap: break-word;
    word-wrap: break-word;
    word-break: break-word;
  }
  .dim-content strong { color: var(--text); font-weight: 500; }
  .dim-content em { color: var(--text); font-style: italic; }

  /* Fun fact callout */
  .fun-fact {
    background: var(--surface2);
    border-left: 3px solid var(--border);
    border-radius: 0 8px 8px 0;
    padding: 10px 14px;
    margin-top: 10px;
    font-size: 0.85rem;
    color: var(--text-dim);
    transition: border-color 0.4s ease, background 0.4s ease;
    overflow-wrap: break-word;
    word-wrap: break-word;
    word-break: break-word;
  }
  .fun-fact::before { content: 'üí° '; }
  .entry.expanded .fun-fact {
    border-left-color: var(--accent);
    background: rgba(124,111,247,0.06);
  }

  /* Sources */
  .card-sources {
    padding-top: 12px;
    border-top: 1px solid var(--border);
    margin-top: 4px;
  }
  .card-sources summary {
    font-size: 0.75rem;
    color: var(--text-dim);
    cursor: pointer;
    opacity: 0.6;
  }
  .card-sources summary:hover { opacity: 1; }
  .card-sources a {
    display: block;
    font-size: 0.72rem;
    color: var(--accent);
    text-decoration: none;
    padding: 2px 0;
    opacity: 0.7;
  }
  .card-sources a:hover { opacity: 1; text-decoration: underline; }

  /* Expand hint */
  .expand-hint {
    font-size: 0.75rem;
    color: var(--text-dim);
    margin-top: 10px;
    opacity: 0.6;
    transition: opacity 0.2s;
  }
  .entry:hover .expand-hint { opacity: 1; }
  .entry.expanded .expand-hint { display: none; }

  /* Reference markers */
  .marker {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 12px;
    height: 28px;
  }
  .marker.thread-hidden { display: none; }

  /* Thread narrative connector */
  .thread-narrative {
    position: relative;
    width: 50%;
    margin: 0 auto 32px;
    padding: 14px 20px;
    background: var(--bg);
    border: 1px solid rgba(124,111,247,0.25);
    border-radius: 10px;
    font-size: 0.82rem;
    line-height: 1.6;
    color: var(--text-dim);
    text-align: center;
    animation: fadeIn 0.4s ease;
    z-index: 5;
    /* Cover the timeline line behind */
    box-shadow: 0 0 0 12px var(--bg), 0 0 20px rgba(124,111,247,0.08);
  }
  .thread-narrative .narrative-arrow {
    color: var(--accent);
    opacity: 0.5;
    display: block;
    font-size: 1.2rem;
    margin-bottom: 6px;
  }
  .thread-narrative strong { color: var(--text); font-weight: 500; }
  .thread-narrative em { color: var(--accent); }

  /* SVG thread lines overlay */
  .thread-lines-svg {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 1;
    overflow: visible;
  }
  .marker-line {
    position: absolute;
    left: calc(50% - 60px);
    width: 120px;
    height: 1px;
    background: var(--border);
    opacity: 0.6;
  }
  .marker-label {
    position: relative;
    z-index: 2;
    font-family: var(--mono);
    font-size: 0.65rem;
    color: var(--text-dim);
    letter-spacing: 0.08em;
    background: var(--bg);
    padding: 2px 10px;
    border: 1px solid var(--border);
    border-radius: 10px;
    white-space: nowrap;
    opacity: 0.5;
    transition: opacity 0.2s;
  }
  .marker:hover .marker-label { opacity: 1; }

  /* Responsive */
  @media (max-width: 768px) {
    .timeline-line { left: 24px; }
    .entry { width: calc(100% - 60px); margin-left: 50px !important; }
    .entry::before { left: -33px !important; right: auto !important; }
    .entry::after { left: -24px !important; right: auto !important; }
    header { padding: 10px 16px; }
    .header-top { margin-bottom: 8px; }
    .timeline-container { padding: 40px 16px 80px; margin-top: 120px; }
    .subtitle { display: none; }
    .card-image-inline { max-height: none; height: auto; object-fit: contain; object-position: center; }
    /* On mobile: no floating image, keep inline visible when expanded */
    .floating-image { display: none !important; }
    .entry.expanded .card-image-inline { display: block; }
    .entry.expanded .card-image-caption-inline { display: block; }
    .thread-narrative { width: 80%; }
    .thread-lines-svg { display: none; }
  }

  /* Scroll animation */
  .entry { opacity: 0; transform: translateY(20px); transition: opacity 0.5s ease, transform 0.5s ease; }
  .entry.visible { opacity: 1; transform: translateY(0); }
  .entry:hover.visible { transform: translateY(-2px); }
  .entry.thread-hidden.visible { opacity: 0; transform: translateY(0); }

  @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

  /* View toggle */
  .view-toggle {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 3px 10px;
    font-size: 0.85rem;
    font-family: var(--font);
    color: var(--text-dim);
    cursor: pointer;
    transition: all 0.2s ease;
    line-height: 1.4;
    margin-right: 10px;
  }
  .view-toggle:hover { border-color: var(--text-dim); color: var(--text); }
  .view-toggle.active { background: var(--accent); border-color: var(--accent); color: #fff; }

  /* Map container */
  #mapView {
    display: none;
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    z-index: 50;
    background: var(--bg);
  }
  #mapView.active { display: block; }

  #map {
    position: absolute;
    top: 56px;
    left: 0; right: 0;
    bottom: 72px;
  }

  /* Override Leaflet popups */
  .leaflet-popup-content-wrapper {
    background: var(--surface) !important;
    border: 1px solid var(--accent) !important;
    border-radius: 12px !important;
    color: var(--text) !important;
    box-shadow: 0 8px 32px rgba(124,111,247,0.2) !important;
  }
  .leaflet-popup-tip-container {
    overflow: visible !important;
    margin-top: -1px !important;
  }
  .leaflet-popup-tip {
    background: var(--surface) !important;
    border-right: 1px solid var(--accent) !important;
    border-bottom: 1px solid var(--accent) !important;
    border-top: none !important;
    border-left: none !important;
    box-shadow: none !important;
  }
  .leaflet-popup-tip::after {
    display: none;
  }
  .leaflet-popup-content {
    margin: 14px 18px !important;
    font-family: var(--font) !important;
    font-size: 0.88rem !important;
    line-height: 1.5 !important;
  }
  .leaflet-popup-close-button {
    color: var(--text-dim) !important;
    font-size: 1.2rem !important;
  }
  .leaflet-popup-close-button:hover { color: var(--text) !important; }

  .map-popup-year {
    font-family: var(--mono);
    font-size: 0.72rem;
    color: var(--accent);
    letter-spacing: 0.1em;
    margin-bottom: 4px;
  }
  .map-popup-title {
    font-size: 1rem;
    font-weight: 600;
    margin-bottom: 6px;
  }
  .map-popup-teaser {
    font-size: 0.82rem;
    color: var(--text-dim);
    margin-bottom: 10px;
    line-height: 1.5;
  }
  .map-popup-threads {
    display: flex; flex-wrap: wrap; gap: 4px;
    margin-bottom: 10px;
  }
  .map-popup-link {
    display: inline-block;
    font-size: 0.78rem;
    color: var(--accent);
    text-decoration: none;
    cursor: pointer;
  }
  .map-popup-link:hover { text-decoration: underline; }

  /* Map time slider */
  .map-time-control {
    position: fixed;
    bottom: 0; left: 0; right: 0;
    z-index: 60;
    background: rgba(10,10,15,0.95);
    backdrop-filter: blur(20px);
    border-top: 1px solid var(--border);
    padding: 16px 32px calc(20px + env(safe-area-inset-bottom, 0px));
    display: none;
  }
  .map-time-control.visible { display: block; }

  .time-slider-row {
    display: flex;
    align-items: center;
    gap: 16px;
  }
  .time-year-display {
    font-family: var(--mono);
    font-size: 1.4rem;
    color: var(--accent);
    font-weight: 700;
    min-width: 70px;
    text-align: center;
  }
  .time-slider {
    flex: 1;
    -webkit-appearance: none;
    appearance: none;
    height: 4px;
    background: var(--border);
    border-radius: 2px;
    outline: none;
    cursor: pointer;
  }
  .time-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 18px; height: 18px;
    border-radius: 50%;
    background: var(--accent);
    box-shadow: 0 0 12px rgba(124,111,247,0.5);
    cursor: pointer;
    transition: transform 0.15s ease;
  }
  .time-slider::-webkit-slider-thumb:hover { transform: scale(1.3); }
  .time-slider::-moz-range-thumb {
    width: 18px; height: 18px;
    border-radius: 50%;
    background: var(--accent);
    border: none;
    box-shadow: 0 0 12px rgba(124,111,247,0.5);
    cursor: pointer;
  }
  .time-play-btn {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 50%;
    width: 36px; height: 36px;
    font-size: 1rem;
    color: var(--text-dim);
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex; align-items: center; justify-content: center;
    position: relative;
  }
  .time-play-btn .play-icon,
  .time-play-btn .pause-icon { display: flex; align-items: center; justify-content: center; }
  .time-play-btn .play-icon {
    width: 0; height: 0;
    border-style: solid;
    border-width: 6px 0 6px 10px;
    border-color: transparent transparent transparent var(--text-dim);
    margin-left: 2px;
    transition: border-color 0.2s ease;
  }
  .time-play-btn .pause-icon {
    display: none;
    gap: 3px;
  }
  .time-play-btn .pause-icon span {
    width: 3px; height: 12px;
    background: #fff;
    border-radius: 1px;
  }
  .time-play-btn:hover .play-icon { border-left-color: var(--accent); }
  .time-play-btn.playing { background: var(--accent); border-color: var(--accent); }
  .time-play-btn.playing .play-icon { display: none; }
  .time-play-btn.playing .pause-icon { display: flex; }

  /* Map marker pulse */
  @keyframes markerPulse {
    0% { box-shadow: 0 0 0 0 rgba(124,111,247,0.6); }
    70% { box-shadow: 0 0 0 16px rgba(124,111,247,0); }
    100% { box-shadow: 0 0 0 0 rgba(124,111,247,0); }
  }
  .map-marker-wrap {
    position: relative;
    width: 40px; height: 40px;
    display: flex; align-items: center; justify-content: center;
    cursor: pointer;
  }
  .map-marker {
    width: 22px; height: 22px;
    border-radius: 50%;
    background: var(--accent);
    border: 3px solid var(--bg);
    box-shadow: 0 0 16px rgba(124,111,247,0.5);
    transition: opacity 0.5s ease, transform 0.3s ease;
    position: relative;
    z-index: 2;
  }
  .map-marker-wrap:hover .map-marker { transform: scale(1.3); }
  .map-marker.arriving {
    animation: markerPulse 1.2s ease-out;
  }
  .map-marker-ring {
    position: absolute;
    width: 36px; height: 36px;
    border-radius: 50%;
    border: 2px solid rgba(124,111,247,0.25);
    top: 2px; left: 2px;
    z-index: 1;
    transition: opacity 0.5s ease;
  }
  .map-marker.dimmed { opacity: 0.15; }
  .map-marker.dimmed + .map-marker-ring { opacity: 0.1; }
  .map-marker.dimmed ~ .map-marker-label { opacity: 0.15; }
  .map-marker.dimmed ~ .map-marker-year { opacity: 0.15; }
  .map-marker.hidden-by-time { opacity: 0; pointer-events: none; }
  .map-marker.hidden-by-time + .map-marker-ring { opacity: 0; }
  .map-marker.hidden-by-time ~ .map-marker-label { opacity: 0; }
  .map-marker.hidden-by-time ~ .map-marker-year { opacity: 0; }

  .map-marker-label {
    position: absolute;
    top: 38px; left: 50%;
    transform: translateX(-50%);
    font-family: var(--mono);
    font-size: 0.65rem;
    color: var(--text);
    white-space: nowrap;
    letter-spacing: 0.05em;
    text-shadow: 0 1px 6px rgba(0,0,0,0.9), 0 0 12px rgba(0,0,0,0.6);
    pointer-events: none;
    transition: opacity 0.5s ease;
    z-index: 3;
  }
  .map-marker-year {
    display: none;
    position: absolute;
    top: 26px; left: 50%;
    transform: translateX(-50%);
    font-family: var(--mono);
    font-size: 0.55rem;
    font-weight: 600;
    color: rgba(255,255,255,0.9);
    white-space: nowrap;
    letter-spacing: 0.05em;
    text-shadow: 0 1px 4px rgba(0,0,0,0.95), 0 0 8px rgba(0,0,0,0.7);
    pointer-events: none;
    transition: opacity 0.5s ease;
    z-index: 3;
  }

  /* Map thread arcs */
  .thread-arc {
    fill: none;
    stroke: rgba(124,111,247,0.5);
    stroke-width: 2.5;
    stroke-linecap: round;
    filter: drop-shadow(0 0 6px rgba(124,111,247,0.4));
  }

  /* Map header bar */
  .map-header {
    position: fixed;
    top: 0; left: 0; right: 0;
    z-index: 70;
    background: rgba(10,10,15,0.95);
    backdrop-filter: blur(20px);
    border-bottom: 1px solid var(--border);
    padding: 14px 32px;
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
  .map-header h1 {
    font-size: 1.4rem; font-weight: 700;
    background: linear-gradient(135deg, var(--accent), var(--art));
    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  }
  .map-header .subtitle { color: var(--text-dim); font-size: 0.85rem; margin-left: 12px; }

  .map-thread-banner {
    display: none;
    position: fixed;
    top: 72px; left: 50%;
    transform: translateX(-50%);
    z-index: 1100; /* above Leaflet popups (z-index ~700) */
    align-items: center;
    gap: 10px;
    padding: 8px 18px;
    background: rgba(10,10,15,0.95);
    backdrop-filter: blur(20px);
    border: 1px solid var(--accent);
    border-radius: 10px;
    font-size: 0.8rem;
    color: var(--text);
    animation: fadeIn 0.2s ease;
    cursor: pointer; /* whole banner is clickable to dismiss */
  }
  .map-thread-banner.visible { display: flex; }
  .map-thread-banner .thread-name { font-weight: 600; color: var(--accent); }
  .map-thread-banner .thread-close {
    margin-left: auto; cursor: pointer;
    color: var(--text-dim); font-size: 1.2rem;
    padding: 4px 8px;
    border-radius: 4px;
    transition: background 0.15s ease, color 0.15s ease;
  }
  .map-thread-banner .thread-close:hover { color: var(--text); background: rgba(255,255,255,0.1); }

  @media (max-width: 768px) {
    .map-time-control { padding: 12px 16px calc(16px + env(safe-area-inset-bottom, 0px)); }
    .time-year-display { font-size: 1.1rem; min-width: 55px; }
    .time-slider { touch-action: none; height: 6px; }
    .time-slider::-webkit-slider-thumb { width: 26px; height: 26px; }
    .time-slider::-moz-range-thumb { width: 26px; height: 26px; }
    .map-marker-label { display: none; }
    .map-marker-year { display: block; }
    .map-header .subtitle { display: none; }
    /* Move thread banner above time controls on mobile to avoid popup overlap */
    .map-thread-banner {
      top: auto;
      bottom: 100px;
      left: 16px;
      right: 16px;
      transform: none;
      max-width: none;
      font-size: 0.75rem;
    }
  }
</style>
</head>
<body>

<header>
  <div class="header-top">
    <div class="header-left">
      <h1>Time Slices</h1>
      <span class="subtitle" id="subtitle">Cross-disciplinary history exploration</span>
    </div>
    <div class="header-right">
      <button class="view-toggle" id="viewToggle"></button>
      <button class="lang-btn active" data-lang="en">EN</button>
      <button class="lang-btn" data-lang="it">IT</button>
    </div>
  </div>
  <div class="thread-banner" id="threadBanner">
    <span>üßµ Thread: <span class="thread-name" id="threadName"></span></span>
    <span class="thread-count" id="threadCount"></span>
    <span class="thread-close" id="threadClose">‚úï</span>
  </div>
</header>

<div class="quick-actions" id="quickActions">
  <button class="quick-btn" id="coffeeBtn">‚òï</button>
  <button class="quick-btn" id="diceBtn">üé≤</button>
</div>

<div class="timeline-container">
  <div class="timeline-line"></div>
  <div id="timeline"></div>
</div>

<!-- Map View -->
<div id="mapView">
  <div class="map-header">
    <div style="display:flex;align-items:baseline;">
      <h1>Time Slices</h1>
      <span class="subtitle" id="mapSubtitle"></span>
    </div>
    <div style="display:flex;align-items:center;gap:8px;">
      <button class="view-toggle active" id="mapBackBtn"></button>
      <button class="lang-btn" data-lang="en" data-map="1">EN</button>
      <button class="lang-btn" data-lang="it" data-map="1">IT</button>
    </div>
  </div>
  <div class="map-thread-banner" id="mapThreadBanner">
    <span>üßµ <span id="mapThreadLabel"></span>: <span class="thread-name" id="mapThreadName"></span></span>
    <span class="thread-close" id="mapThreadClose">‚úï</span>
  </div>
  <div id="map"></div>
</div>

<div class="map-time-control" id="mapTimeControl">
  <div class="time-slider-row">
    <button class="time-play-btn" id="timePlayBtn"><span class="play-icon"></span><span class="pause-icon"><span></span><span></span></span></button>
    <span class="time-year-display" id="timeYearDisplay">762</span>
    <input type="range" class="time-slider" id="timeSlider" min="700" max="2026" value="2026" step="1">
  </div>
</div>

<script>
let SLICES = [];
let activeThread = null;
let currentLang = (navigator.language || '').startsWith('it') ? 'it' : 'en';
let _slicesReadyResolve;
let slicesReady = new Promise(r => { _slicesReadyResolve = r; });

const DIM_ICONS = { art: 'üé®', lit: 'üìñ', phil: 'üß†', hist: '‚öîÔ∏è', conn: 'üîó' };

const I18N = {
  en: {
    subtitle: 'Cross-disciplinary history exploration',
    all: 'All', art: 'üé® Art', lit: 'üìñ Literature', phil: 'üß† Philosophy', hist: '‚öîÔ∏è History', conn: 'üîó Connections',
    thread: 'Thread', entries: 'entries', entry: 'entry',
    expandHint: 'Click to explore ‚Üí', sources: 'Sources',
    yearsLater: 'years later‚Ä¶',
    slicesFile: 'slices.json',
    viewMap: 'Map',
    viewTimeline: 'Timeline',
    viewInTimeline: 'View in timeline ‚Üí',
    freshEntry: "Today's fresh entry",
    randomSlice: 'Random slice',
  },
  it: {
    subtitle: 'Esplorazione interdisciplinare della storia',
    all: 'Tutti', art: 'üé® Arte', lit: 'üìñ Letteratura', phil: 'üß† Filosofia', hist: '‚öîÔ∏è Storia', conn: 'üîó Connessioni',
    thread: 'Filo', entries: 'voci', entry: 'voce',
    expandHint: 'Clicca per esplorare ‚Üí', sources: 'Fonti',
    yearsLater: 'anni dopo‚Ä¶',
    slicesFile: 'slices.it.json',
    viewMap: 'Mappa',
    viewTimeline: 'Cronologia',
    viewInTimeline: 'Vedi nella cronologia ‚Üí',
    freshEntry: 'Voce fresca di oggi',
    randomSlice: 'Voce casuale',
  }
};

function t(key) { return I18N[currentLang][key] || I18N.en[key] || key; }
const THREAD_LABELS = {
  en: {
    'translation-movement': 'Translation as Power',
    'rationalism': 'Rationalism',
    'islamic-golden-age': 'Islamic Golden Age',
    'cosmopolitanism': 'Cosmopolitanism',
    'geometry-as-ideology': 'Geometry as Ideology',
    'renaissance-humanism': 'Renaissance Humanism',
    'neoplatonism': 'Neoplatonism',
    'classical-revival': 'Classical Revival',
    'art-and-power': 'Art & Power',
    'christian-humanism': 'Christian Humanism',
    'post-impressionism': 'Post-Impressionism',
    'crisis-of-positivism': 'Crisis of Positivism',
    'modernity': 'Modernity',
    'death-of-god': 'Death of God',
    'expressionism': 'Expressionism',
    'symbolism': 'Symbolism',
    'modernism': 'Modernism',
    'fragmentation': 'Fragmentation',
    'logical-positivism': 'Logical Positivism',
    'existentialism': 'Existentialism',
    'totalitarianism': 'Totalitarianism',
    'memento-mori': 'Memento Mori',
    'nominalism': 'Nominalism',
    'vernacular-literature': 'Vernacular Literature',
    'baroque': 'Baroque',
    'westphalian-sovereignty': 'Westphalian Sovereignty',
    'dutch-golden-age': 'Dutch Golden Age',
  },
  it: {
    'translation-movement': 'Traduzione come potere',
    'rationalism': 'Razionalismo',
    'islamic-golden-age': 'Et√† d\'oro islamica',
    'cosmopolitanism': 'Cosmopolitismo',
    'geometry-as-ideology': 'Geometria come ideologia',
    'renaissance-humanism': 'Umanesimo rinascimentale',
    'neoplatonism': 'Neoplatonismo',
    'classical-revival': 'Rinascita classica',
    'art-and-power': 'Arte e potere',
    'christian-humanism': 'Umanesimo cristiano',
    'post-impressionism': 'Post-impressionismo',
    'crisis-of-positivism': 'Crisi del positivismo',
    'modernity': 'Modernit√†',
    'death-of-god': 'Morte di Dio',
    'expressionism': 'Espressionismo',
    'symbolism': 'Simbolismo',
    'modernism': 'Modernismo',
    'fragmentation': 'Frammentazione',
    'logical-positivism': 'Positivismo logico',
    'existentialism': 'Esistenzialismo',
    'totalitarianism': 'Totalitarismo',
    'memento-mori': 'Memento Mori',
    'nominalism': 'Nominalismo',
    'vernacular-literature': 'Letteratura in volgare',
    'baroque': 'Barocco',
    'westphalian-sovereignty': 'Sovranit√† vestfaliana',
    'dutch-golden-age': 'Secolo d\'oro olandese',
  }
};

const MARKERS = [
  { year: -3000, label: { en: "First writing (Sumer)", it: "Prima scrittura (Sumeri)" } },
  { year: -776, label: { en: "First Olympics", it: "Prime Olimpiadi" } },
  { year: -509, label: { en: "Roman Republic founded", it: "Fondazione della Repubblica Romana" } },
  { year: -323, label: { en: "Death of Alexander the Great", it: "Morte di Alessandro Magno" } },
  { year: 0, label: { en: "Year Zero", it: "Anno Zero" } },
  { year: 476, label: { en: "Fall of Western Rome", it: "Caduta dell'Impero Romano d'Occidente" } },
  { year: 622, label: { en: "Hijra ‚Äî birth of Islam", it: "Egira ‚Äî nascita dell'Islam" } },
  { year: 800, label: { en: "Charlemagne crowned Emperor", it: "Carlo Magno incoronato Imperatore" } },
  { year: 1066, label: { en: "Norman Conquest", it: "Conquista normanna" } },
  { year: 1215, label: { en: "Magna Carta", it: "Magna Carta" } },
  { year: 1347, label: { en: "Black Death arrives in Europe", it: "La Peste Nera arriva in Europa" } },
  { year: 1453, label: { en: "Fall of Constantinople", it: "Caduta di Costantinopoli" } },
  { year: 1492, label: { en: "Columbus reaches the Americas", it: "Colombo raggiunge le Americhe" } },
  { year: 1517, label: { en: "Luther's 95 Theses", it: "Le 95 tesi di Lutero" } },
  { year: 1648, label: { en: "Peace of Westphalia", it: "Pace di Vestfalia" } },
  { year: 1776, label: { en: "American Independence", it: "Indipendenza americana" } },
  { year: 1789, label: { en: "French Revolution", it: "Rivoluzione francese" } },
  { year: 1815, label: { en: "Waterloo", it: "Waterloo" } },
  { year: 1914, label: { en: "World War I begins", it: "Inizio della Prima Guerra Mondiale" } },
  { year: 1945, label: { en: "World War II ends", it: "Fine della Seconda Guerra Mondiale" } },
  { year: 1969, label: { en: "Moon landing", it: "Sbarco sulla Luna" } },
  { year: 1989, label: { en: "Fall of the Berlin Wall", it: "Caduta del Muro di Berlino" } },
];

const timeline = document.getElementById('timeline');

function formatThreadId(id) {
  const labels = THREAD_LABELS[currentLang] || THREAD_LABELS.en;
  return labels[id] || id.split('-').map(w => w[0].toUpperCase() + w.slice(1)).join(' ');
}

function renderSlice(slice, isFresh = false) {
  const dims = Object.entries(slice.dimensions).map(([key, dim]) => {
    const funFact = dim.funFact ? `<div class="fun-fact">${dim.funFact}</div>` : '';
    return `
      <div class="dimension" data-dim="${key}">
        <div class="dim-header">
          <span class="dim-icon">${DIM_ICONS[key]}</span>
          <span class="dim-label-${key}">${dim.label}</span>
        </div>
        <div class="dim-content">${dim.content}${funFact}</div>
      </div>
    `;
  }).join('');

  const threads = (slice.threads || []).map(t =>
    `<span class="thread-tag" data-thread="${t}">${formatThreadId(t)}</span>`
  ).join('');

  const sources = (slice.sources || []).map(s =>
    `<a href="${s.url}" target="_blank" rel="noopener">${s.title}</a>`
  ).join('');
  const sourcesHtml = sources ? `
    <details class="card-sources" onclick="event.stopPropagation()">
      <summary>${t('sources')}</summary>
      ${sources}
    </details>` : '';

  const imageInlineHtml = slice.image ? `
    <img class="card-image-inline" data-src="${slice.image.url}" alt="${slice.image.caption}">
    <div class="card-image-caption-inline">${slice.image.caption}</div>` : '';

  const floatingImageHtml = slice.image ? `
    <div class="floating-image">
      <img data-src="${slice.image.url}" alt="${slice.image.caption}">
      <div class="floating-caption">${slice.image.caption}</div>
      ${slice.image.attribution ? `<div class="floating-attribution">${slice.image.attribution}</div>` : ''}
    </div>` : '';

  const mapLink = slice.location ? `<span class="card-map-link" data-year="${slice.year}" title="${slice.location.place}">üìç</span>` : '';

  const el = document.createElement('div');
  el.className = 'entry';
  el.dataset.year = slice.year;
  el.dataset.threads = JSON.stringify(slice.threads || []);
  const freshBadgeHtml = isFresh ? '<div class="fresh-badge">‚òï</div>' : '';

  el.innerHTML = `
    ${floatingImageHtml}
    <div class="card">
      ${freshBadgeHtml}
      ${imageInlineHtml}
      <div class="card-body">
        <div class="card-year">${slice.year}${mapLink}</div>
        <div class="card-title">${slice.title}</div>
        <div class="card-teaser">${slice.teaser}</div>
        <div class="card-threads">${threads}</div>
        <div class="expand-hint">${t('expandHint')}</div>
        <div class="card-details">
          ${dims}
          ${sourcesHtml}
        </div>
      </div>
    </div>
  `;

  // Expand/collapse
  el.addEventListener('click', (e) => {
    if (e.target.closest('.thread-tag') || e.target.closest('.card-sources') || e.target.closest('.card-map-link')) return;
    const details = el.querySelector('.card-details');
    if (el.classList.contains('expanded')) {
      details.style.maxHeight = details.scrollHeight + 'px';
      requestAnimationFrame(() => { details.style.maxHeight = '0'; });
      el.classList.remove('expanded');
    } else {
      el.classList.add('expanded');
      details.style.maxHeight = details.scrollHeight + 'px';
      details.addEventListener('transitionend', function handler() {
        if (el.classList.contains('expanded')) {
          details.style.maxHeight = 'none';
        }
        details.removeEventListener('transitionend', handler);
      });
      // Eagerly load floating image
      const floatImg = el.querySelector('.floating-image img[data-src]');
      if (floatImg && !floatImg.src) {
        floatImg.src = floatImg.dataset.src;
      }
    }
  });

  // Thread tag clicks
  el.querySelectorAll('.thread-tag').forEach(tag => {
    tag.addEventListener('click', (e) => {
      e.stopPropagation();
      const thread = tag.dataset.thread;
      if (activeThread === thread) {
        clearThread();
      } else {
        activateThread(thread);
      }
    });
  });

  // Map pin link
  const mapLinkEl = el.querySelector('.card-map-link');
  if (mapLinkEl) {
    mapLinkEl.addEventListener('click', (e) => {
      e.stopPropagation();
      flyToEntry(mapLinkEl.dataset.year);
    });
  }

  return el;
}

function renderMarker(marker) {
  const el = document.createElement('div');
  el.className = 'marker';
  const yearStr = marker.year < 0 ? `${Math.abs(marker.year)} BC` : marker.year === 0 ? '0' : marker.year;
  const labelText = typeof marker.label === 'object' ? (marker.label[currentLang] || marker.label.en) : marker.label;
  el.innerHTML = `
    <div class="marker-line"></div>
    <span class="marker-label">${yearStr} ‚Äî ${labelText}</span>
  `;
  return el;
}

// Thread logic
// Narrative connectors between thread entries
const THREAD_NARRATIVES = {
  en: {
    'death-of-god': {
      '1347‚Üí1648': 'The plague made God\'s order illegible; three centuries later, the wars of religion made it lethal. Westphalia\'s solution was radical: stop asking which God is right and let sovereignty decide. Ockham\'s nominalism planted the seed; Descartes\' cogito grew from the same doubt.',
      '1347‚Üí1889': 'The Black Death made God\'s order illegible five centuries before Nietzsche declared Him dead. Ockham\'s razor stripped away metaphysical certainties; by 1889, Nietzsche finished the job ‚Äî and collapsed under the weight of it.',
      '1347‚Üí1922': 'From plague to wasteland: the crisis of divine authority that began when prayers couldn\'t stop the Black Death reaches its modernist conclusion in Eliot\'s fragments and Wittgenstein\'s silence about what cannot be said.',
      '1648‚Üí1889': 'Westphalia removed God from international politics; Nietzsche removed Him from philosophy. Between them, two and a half centuries of Enlightenment slowly replaced divine authority with human reason ‚Äî until reason itself began to crack.',
      '1648‚Üí1922': 'The Peace of Westphalia made religion a private matter of state; by 1922, God had become a private matter of the individual ‚Äî or nobody\'s matter at all. Eliot\'s wasteland is what Westphalia\'s secular order looks like after the trenches.',
      '1889‚Üí1922': 'Nietzsche declared God dead in 1882. By 1922, the void he predicted had swallowed certainty itself ‚Äî Eliot\'s <em>Waste Land</em> mapped the wreckage, while logical positivism tried to rebuild meaning from scratch.',
    },
    'rationalism': {
      '762‚Üí1648': 'The Mu\'tazila argued that reason could determine religious truth; eight centuries later, Descartes used reason to bypass religious truth entirely. Baghdad\'s translation movement preserved the Greek rationalism that Descartes inherited ‚Äî the cogito\'s ancestors spoke Arabic.',
    },
    'modernity': {
      '1648‚Üí1889': 'Westphalia invented the modern state; the Eiffel Tower celebrated what the modern state could build. Between them: the Enlightenment, the Industrial Revolution, the nation-state. The 1889 World\'s Fair was Westphalian sovereignty made festive ‚Äî competing nations showing off in iron and glass.',
    },
    'fragmentation': {
      '1347‚Üí1922': 'The plague shattered medieval unity ‚Äî Church authority, feudal order, demographic stability, all broken at once. Six centuries later, modernism made fragmentation into an art form, shattering narrative, painting, and language with the same democratic indifference.',
    },
  },
  it: {
    'death-of-god': {
      '1347‚Üí1648': 'La peste rese illeggibile l\'ordine di Dio; tre secoli dopo, le guerre di religione lo resero letale. La soluzione di Vestfalia fu radicale: smettere di chiedersi quale Dio avesse ragione e lasciare decidere alla sovranit√†. Il nominalismo di Ockham piant√≤ il seme; il cogito di Cartesio crebbe dallo stesso dubbio.',
      '1347‚Üí1889': 'La Peste Nera rese illeggibile l\'ordine divino cinque secoli prima che Nietzsche ne dichiarasse la morte. Il rasoio di Ockham aveva gi√† spogliato le certezze metafisiche; nel 1889, Nietzsche complet√≤ l\'opera ‚Äî e croll√≤ sotto il suo peso.',
      '1347‚Üí1922': 'Dalla peste alla terra desolata: la crisi dell\'autorit√† divina, iniziata quando le preghiere non fermarono la Morte Nera, raggiunge la sua conclusione modernista nei frammenti di Eliot e nel silenzio di Wittgenstein su ci√≤ che non si pu√≤ dire.',
      '1648‚Üí1889': 'Vestfalia rimosse Dio dalla politica internazionale; Nietzsche lo rimosse dalla filosofia. Fra i due, due secoli e mezzo di Illuminismo sostituirono lentamente l\'autorit√† divina con la ragione umana ‚Äî finch√© la ragione stessa cominci√≤ a incrinarsi.',
      '1648‚Üí1922': 'La Pace di Vestfalia fece della religione un affare privato degli Stati; nel 1922, Dio era diventato un affare privato dell\'individuo ‚Äî o di nessuno. La terra desolata di Eliot √® l\'aspetto dell\'ordine secolare vestfaliano dopo le trincee.',
      '1889‚Üí1922': 'Nietzsche dichiar√≤ morto Dio nel 1882. Entro il 1922, il vuoto che aveva predetto aveva inghiottito la certezza stessa ‚Äî <em>La terra desolata</em> di Eliot ne mappava le macerie, mentre il positivismo logico tentava di ricostruire il significato da zero.',
    },
    'rationalism': {
      '762‚Üí1648': 'I Mu\'tazila sostenevano che la ragione potesse determinare la verit√† religiosa; otto secoli dopo, Cartesio us√≤ la ragione per aggirare del tutto la verit√† religiosa. Il movimento di traduzione di Baghdad preserv√≤ il razionalismo greco che Cartesio eredit√≤ ‚Äî gli antenati del cogito parlavano arabo.',
    },
    'modernity': {
      '1648‚Üí1889': 'Vestfalia invent√≤ lo Stato moderno; la Tour Eiffel celebr√≤ ci√≤ che lo Stato moderno sapeva costruire. Fra i due: l\'Illuminismo, la Rivoluzione industriale, lo Stato-nazione. L\'Esposizione Universale del 1889 fu la sovranit√† vestfaliana in festa ‚Äî nazioni in competizione che si mettevano in mostra in ferro e vetro.',
    },
    'fragmentation': {
      '1347‚Üí1922': 'La peste frantum√≤ l\'unit√† medievale ‚Äî autorit√† della Chiesa, ordine feudale, stabilit√† demografica, tutto spezzato in una volta. Sei secoli dopo, il modernismo fece della frammentazione una forma d\'arte, frantumando narrazione, pittura e linguaggio con la stessa democratica indifferenza.',
    },
  },
};

function getThreadNarrative(threadId, yearFrom, yearTo) {
  const key = `${yearFrom}‚Üí${yearTo}`;
  const langNarratives = THREAD_NARRATIVES[currentLang] || THREAD_NARRATIVES.en;
  const narratives = langNarratives[threadId];
  return narratives && narratives[key] ? narratives[key] : null;
}

function activateThread(threadId) {
  activeThread = threadId;
  mapActiveThread = threadId; // keep both views in sync
  const entries = document.querySelectorAll('.entry');
  const matchingEntries = [];

  // Dim the main timeline line
  document.querySelector('.timeline-line').classList.add('thread-active');

  // First: record max-height of non-matching entries before hiding
  entries.forEach(entry => {
    const threads = JSON.parse(entry.dataset.threads || '[]');
    if (threads.includes(threadId)) {
      entry.classList.remove('thread-hidden');
      entry.classList.add('thread-highlighted');
      matchingEntries.push(entry);
    } else {
      // Store current height for smooth collapse
      entry.style.maxHeight = entry.scrollHeight + 'px';
      entry.classList.remove('thread-highlighted');
      requestAnimationFrame(() => {
        entry.classList.add('thread-hidden');
        entry.style.maxHeight = '0';
      });
    }
  });

  // Hide markers
  document.querySelectorAll('.marker').forEach(m => m.classList.add('thread-hidden'));

  // Remove old narratives
  document.querySelectorAll('.thread-narrative').forEach(n => n.remove());

  // Insert narrative connectors between matching entries
  for (let i = 0; i < matchingEntries.length - 1; i++) {
    const fromYear = matchingEntries[i].dataset.year;
    const toYear = matchingEntries[i + 1].dataset.year;
    const narrative = getThreadNarrative(threadId, fromYear, toYear);

    const connector = document.createElement('div');
    connector.className = 'thread-narrative';

    if (narrative) {
      connector.innerHTML = `<span class="narrative-arrow">‚Üì</span>${narrative}`;
    } else {
      const gap = parseInt(toYear) - parseInt(fromYear);
      connector.innerHTML = `<span class="narrative-arrow">‚Üì</span><em>${gap} ${t('yearsLater')}</em>`;
    }

    // Insert after the current matching entry
    matchingEntries[i].after(connector);
  }

  // Draw SVG thread lines
  drawThreadLines(matchingEntries);

  // Update all thread tags
  document.querySelectorAll('.thread-tag').forEach(t => {
    t.classList.toggle('active', t.dataset.thread === threadId);
  });

  // Show banner
  const count = matchingEntries.length;
  document.getElementById('threadName').textContent = formatThreadId(threadId);
  document.getElementById('threadCount').textContent = `${count} ${count === 1 ? t('entry') : t('entries')}`;
  document.getElementById('threadBanner').classList.add('visible');

  // Scroll to first matching entry
  if (matchingEntries.length > 0) {
    setTimeout(() => {
      matchingEntries[0].scrollIntoView({ behavior: 'smooth', block: 'center' });
    }, 300);
  }
}

function clearThread() {
  activeThread = null;
  mapActiveThread = null; // keep both views in sync

  // Restore timeline line
  document.querySelector('.timeline-line').classList.remove('thread-active');

  document.querySelectorAll('.entry').forEach(e => {
    e.classList.remove('thread-hidden', 'thread-highlighted');
    e.style.maxHeight = '';
  });
  document.querySelectorAll('.marker').forEach(m => m.classList.remove('thread-hidden'));
  document.querySelectorAll('.thread-tag').forEach(t => t.classList.remove('active'));
  document.querySelectorAll('.thread-narrative').forEach(n => n.remove());
  clearThreadLines();
  document.getElementById('threadBanner').classList.remove('visible');
}

// SVG thread lines
function drawThreadLines(matchingEntries) {
  clearThreadLines();
  if (matchingEntries.length < 2) return;

  // Delay drawing until layout has settled after hide/show transitions
  setTimeout(() => {
    const container = document.querySelector('.timeline-container');
    const containerRect = container.getBoundingClientRect();
    const scrollTop = container.scrollTop || 0;

    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.classList.add('thread-lines-svg');
    // Set SVG to cover the full scrollable height of the container
    const fullHeight = container.scrollHeight;
    svg.setAttribute('width', '100%');
    svg.setAttribute('height', fullHeight + 'px');
    svg.style.height = fullHeight + 'px';
    container.appendChild(svg);

    // Add glow filter
    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    defs.innerHTML = `
      <filter id="threadGlow" x="-50%" y="-50%" width="200%" height="200%">
        <feGaussianBlur stdDeviation="4" result="blur"/>
        <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
      </filter>
    `;
    svg.appendChild(defs);

    const timelineX = container.offsetWidth / 2;

    for (let i = 0; i < matchingEntries.length - 1; i++) {
      const fromEntry = matchingEntries[i];
      const toEntry = matchingEntries[i + 1];

      const fromRect = fromEntry.getBoundingClientRect();
      const toRect = toEntry.getBoundingClientRect();

      // Dot is at top: 24px of the entry, offset from container top
      const fromY = fromRect.top - containerRect.top + scrollTop + 30;
      const toY = toRect.top - containerRect.top + scrollTop + 30;

      const midY = (fromY + toY) / 2;
      const curveOffset = 30;

      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute('d', `M ${timelineX} ${fromY} Q ${timelineX + curveOffset} ${midY} ${timelineX} ${toY}`);
      path.setAttribute('fill', 'none');
      path.setAttribute('stroke', 'rgba(124,111,247,0.35)');
      path.setAttribute('stroke-width', '3');
      path.setAttribute('stroke-linecap', 'round');
      path.setAttribute('filter', 'url(#threadGlow)');

      // Animate
      const length = path.getTotalLength ? path.getTotalLength() : 500;
      path.setAttribute('stroke-dasharray', length);
      path.setAttribute('stroke-dashoffset', length);
      path.style.transition = `stroke-dashoffset 0.8s ease ${i * 0.2}s`;

      svg.appendChild(path);

      requestAnimationFrame(() => {
        path.setAttribute('stroke-dashoffset', '0');
      });
    }
  }, 500); // wait for hide/show transitions to finish
}

function clearThreadLines() {
  document.querySelectorAll('.thread-lines-svg').forEach(s => s.remove());
}

document.getElementById('threadClose').addEventListener('click', clearThread);

// Lazy image loading
function lazyLoadImages() {
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(e => {
      if (e.isIntersecting) {
        const img = e.target;
        img.src = img.dataset.src;
        img.onload = () => img.classList.add('loaded');
        observer.unobserve(img);
      }
    });
  }, { rootMargin: '200px' });

  document.querySelectorAll('[data-src]').forEach(img => observer.observe(img));
}

// Scroll reveal
function setupScrollReveal() {
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(e => { if (e.isIntersecting) e.target.classList.add('visible'); });
  }, { threshold: 0.1 });
  document.querySelectorAll('.entry').forEach(el => observer.observe(el));
}

// Update UI labels for current language
function updateUILabels() {
  document.getElementById('subtitle').textContent = t('subtitle');
  document.querySelectorAll('#filters .filter-btn').forEach(btn => {
    btn.textContent = t(btn.dataset.dim);
  });
  document.querySelector('.thread-banner span:first-child').innerHTML =
    `üßµ ${t('thread')}: <span class="thread-name" id="threadName"></span>`;
  document.documentElement.lang = currentLang;

  // Toggle button: update to current language
  const toggle = document.getElementById('viewToggle');
  const isMapActive = toggle.classList.contains('active');
  toggle.textContent = isMapActive ? t('viewTimeline') : t('viewMap');

  // Quick action button titles
  document.getElementById('coffeeBtn').title = t('freshEntry');
  document.getElementById('diceBtn').title = t('randomSlice');

  // Map view labels
  document.getElementById('mapSubtitle').textContent = t('viewMap');
  document.getElementById('mapBackBtn').textContent = t('viewTimeline');
}

// Load slices for current language and rebuild timeline
function loadSlices(restoreYear) {
  // Reset the ready promise so buttons wait for the new data
  slicesReady = new Promise(r => { _slicesReadyResolve = r; });

  // If no explicit year to restore, find the entry currently in view
  if (!restoreYear) {
    const viewportCenter = window.innerHeight / 2;
    const entries = document.querySelectorAll('.entry[data-year]');
    let closest = null, closestDist = Infinity;
    entries.forEach(el => {
      const rect = el.getBoundingClientRect();
      const dist = Math.abs(rect.top + rect.height / 2 - viewportCenter);
      if (dist < closestDist) { closestDist = dist; closest = el; }
    });
    if (closest) restoreYear = closest.dataset.year;
  }

  // Clear active thread
  if (activeThread) clearThread();

  fetch(t('slicesFile'))
    .then(r => r.json())
    .then(data => {
      SLICES = data;
      timeline.innerHTML = '';

      // Determine the most recently added entry (by addedDate, fallback to last in array)
      const freshestDate = SLICES.reduce((max, s) => {
        const d = s.addedDate || '';
        return d > max ? d : max;
      }, '');
      const freshestYear = freshestDate
        ? SLICES.filter(s => s.addedDate === freshestDate).pop()?.year
        : SLICES[SLICES.length - 1]?.year;

      const items = [
        ...SLICES.map(s => ({ type: 'slice', year: parseInt(s.year), data: s })),
        ...MARKERS.map(m => ({ type: 'marker', year: m.year, data: m })),
      ];
      items.sort((a, b) => a.year - b.year || (a.type === 'marker' ? -1 : 1));

      items.forEach((item) => {
        if (item.type === 'slice') {
          timeline.appendChild(renderSlice(item.data, item.data.year === freshestYear));
        } else {
          timeline.appendChild(renderMarker(item.data));
        }
      });

      lazyLoadImages();
      setupScrollReveal();

      // Signal that slices are ready for dice/coffee buttons
      _slicesReadyResolve();

      // Restore scroll position to the same entry
      if (restoreYear) {
        requestAnimationFrame(() => {
          const target = document.querySelector(`.entry[data-year="${restoreYear}"]`);
          if (target) target.scrollIntoView({ block: 'center' });
        });
      }
    });
}

// Language switcher
document.querySelectorAll('.lang-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    const lang = btn.dataset.lang;
    if (lang === currentLang) return;
    currentLang = lang;
    document.querySelectorAll('.lang-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    updateUILabels();
    loadSlices();
  });
});

// Init: set correct lang button active and load
(function init() {
  document.querySelectorAll('.lang-btn').forEach(b => {
    b.classList.toggle('active', b.dataset.lang === currentLang);
  });
  // Dim buttons until slices are loaded
  document.getElementById('coffeeBtn').classList.add('loading');
  document.getElementById('diceBtn').classList.add('loading');
  slicesReady.then(() => {
    document.getElementById('coffeeBtn').classList.remove('loading');
    document.getElementById('diceBtn').classList.remove('loading');
  });
  updateUILabels();
  loadSlices();
})();

// ========================================
// MAP VIEW
// ========================================

let map = null;
let mapMarkers = [];
let mapArcs = [];
let mapActiveThread = null;
let mapIsPlaying = false;

// Initialize Leaflet map (lazy ‚Äî only on first toggle)
function initMap() {
  if (map) return;

  map = L.map('map', {
    center: [42, 20],
    zoom: 4,
    zoomControl: false,
    attributionControl: false,
  });

  // CartoDB Dark Matter ‚Äî matches our aesthetic
  L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
    maxZoom: 18,
    subdomains: 'abcd',
  }).addTo(map);

  // Zoom control in bottom-right ‚Äî desktop only (mobile uses pinch)
  if (window.innerWidth > 768) {
    L.control.zoom({ position: 'bottomright' }).addTo(map);
  }
}

function createMapMarker(slice) {
  if (!slice.location) return null;

  const icon = L.divIcon({
    className: '',
    html: `<div class="map-marker-wrap">
             <div class="map-marker" data-year="${slice.year}"></div>
             <div class="map-marker-ring"></div>
             <div class="map-marker-label">${slice.year} ¬∑ ${slice.location.place}</div>
             <div class="map-marker-year">${slice.year}</div>
           </div>`,
    iconSize: [40, 40],
    iconAnchor: [20, 20],
    popupAnchor: [0, -24],
  });

  const marker = L.marker([slice.location.lat, slice.location.lon], { icon });

  // Build popup content
  const threads = (slice.threads || []).map(t =>
    `<span class="thread-tag" data-thread="${t}" onclick="event.stopPropagation(); activateMapThread('${t}')">${formatThreadId(t)}</span>`
  ).join('');

  const isMobile = window.innerWidth <= 768;
  const popup = L.popup({
    maxWidth: isMobile ? 260 : 320,
    minWidth: isMobile ? 180 : 240,
    closeButton: true,
    autoPanPaddingTopLeft: L.point(10, isMobile ? 10 : 80),
    autoPanPaddingBottomRight: L.point(10, isMobile ? 140 : 10),
  }).setContent(`
    <div class="map-popup-year">${slice.year}</div>
    <div class="map-popup-title">${slice.title}</div>
    <div class="map-popup-teaser">${slice.teaser}</div>
    <div class="map-popup-threads">${threads}</div>
    <a class="map-popup-link" onclick="scrollToEntry('${slice.year}')">${t('viewInTimeline')}</a>
  `);

  marker.bindPopup(popup);
  marker._sliceYear = parseInt(slice.year);
  marker._sliceThreads = slice.threads || [];

  marker.on('popupopen', () => {
    const el = marker.getElement();
    if (el) {
      const lbl = el.querySelector('.map-marker-label');
      const yr = el.querySelector('.map-marker-year');
      if (lbl) lbl.style.opacity = '0';
      if (yr) yr.style.opacity = '0';
    }
  });
  marker.on('popupclose', () => {
    const el = marker.getElement();
    if (el) {
      const lbl = el.querySelector('.map-marker-label');
      const yr = el.querySelector('.map-marker-year');
      if (lbl) lbl.style.opacity = '';
      if (yr) yr.style.opacity = '';
    }
  });

  return marker;
}

function populateMap() {
  // Clear existing markers
  mapMarkers.forEach(m => map.removeLayer(m));
  mapMarkers = [];
  clearMapArcs();

  SLICES.forEach(slice => {
    const marker = createMapMarker(slice);
    if (marker) {
      marker.addTo(map);
      mapMarkers.push(marker);
    }
  });

  // Update slider range
  if (SLICES.length > 0) {
    const years = SLICES.map(s => parseInt(s.year)).sort((a, b) => a - b);
    const minY = Math.max(years[0] - 100, -3000);
    const maxY = new Date().getFullYear();
    const slider = document.getElementById('timeSlider');
    slider.min = minY;
    slider.max = maxY;
    slider.value = maxY;
    document.getElementById('timeYearDisplay').textContent = maxY;
  }

  // Fit bounds to show all markers (skip if thread active ‚Äî thread will fit its own)
  if (mapMarkers.length > 1 && !mapActiveThread) {
    const group = L.featureGroup(mapMarkers);
    map.fitBounds(group.getBounds().pad(0.3), { maxZoom: 6 });
  }

  // Update map lang buttons
  document.querySelectorAll('[data-map="1"]').forEach(b => {
    b.classList.toggle('active', b.dataset.lang === currentLang);
  });

  // Re-apply thread if active
  if (mapActiveThread) {
    activateMapThread(mapActiveThread);
  }
}

// Time slider logic
// Time window: entries visible within this many years of the slider position.
// They fade in over FADE_ZONE years before full visibility, fade out over FADE_ZONE after.
const TIME_WINDOW = 120;   // total half-window (entry visible ¬±120 years from its date)
const FADE_ZONE = 40;      // fade-in/out zone at edges

function updateTimeFilter(maxYear) {
  document.getElementById('timeYearDisplay').textContent = maxYear;

  mapMarkers.forEach(marker => {
    const markerEl = marker.getElement();
    if (!markerEl) return;
    const dot = markerEl.querySelector('.map-marker');
    const label = markerEl.querySelector('.map-marker-label');
    if (!dot) return;

    const year = marker._sliceYear;
    const isThreadMember = mapActiveThread && marker._sliceThreads.includes(mapActiveThread);

    // Thread mode (playing OR manual scrub): thread members always visible, others hidden
    if (mapActiveThread && isThreadMember) {
      dot.classList.remove('hidden-by-time');
      dot.style.opacity = 1;
      if (label) label.style.opacity = 1;
      return;
    }
    if (mapActiveThread && !isThreadMember) {
      dot.classList.add('hidden-by-time');
      dot.style.opacity = '';
      if (label) label.style.opacity = '0';
      if (marker.isPopupOpen()) marker.closePopup();
      return;
    }

    const diff = maxYear - year; // positive = slider is past this entry

    // Visible when slider is within [-TIME_WINDOW, +TIME_WINDOW] of entry year
    // i.e. entry appears TIME_WINDOW years before its date, disappears TIME_WINDOW after
    if (diff >= -TIME_WINDOW && diff <= TIME_WINDOW) {
      const wasHidden = dot.classList.contains('hidden-by-time');
      dot.classList.remove('hidden-by-time');

      // Calculate opacity for smooth fade at edges
      let opacity = 1;
      if (diff < -TIME_WINDOW + FADE_ZONE) {
        // Fading in (slider approaching from below)
        opacity = (diff + TIME_WINDOW) / FADE_ZONE;
      } else if (diff > TIME_WINDOW - FADE_ZONE) {
        // Fading out (slider moving past)
        opacity = (TIME_WINDOW - diff) / FADE_ZONE;
      }
      opacity = Math.max(0, Math.min(1, opacity));

      dot.style.opacity = opacity;
      if (label) label.style.opacity = opacity;

      // Close popup if marker has mostly faded
      if (opacity < 0.3 && marker.isPopupOpen()) marker.closePopup();

      if (wasHidden && opacity > 0.3) {
        dot.classList.add('arriving');
        setTimeout(() => dot.classList.remove('arriving'), 1000);
      }
    } else {
      dot.classList.add('hidden-by-time');
      dot.classList.remove('arriving');
      dot.style.opacity = '';
      if (label) label.style.opacity = '0';
      if (marker.isPopupOpen()) marker.closePopup();
    }
  });

  // Redraw arcs if thread is active (but not during tour ‚Äî tour draws its own)
  if (mapActiveThread && !mapIsPlaying) {
    drawMapArcs(mapActiveThread, maxYear);
  }

  // Fit map bounds to visible markers (debounced to avoid jitter during scrubbing)
  fitToVisibleMarkers(maxYear);
}

let _fitBoundsTimer = null;
let _lastFitSet = null;
let _lastVisibleSet = '';  // track which markers are visible to only refit on change
function fitToVisibleMarkers(maxYear) {
  if (_suppressAutoFit) return;
  // In thread mode (manual scrub), don't auto-fit ‚Äî user controls the camera
  if (mapActiveThread && !mapIsPlaying) return;

  const visible = mapMarkers.filter(m => Math.abs(maxYear - m._sliceYear) <= TIME_WINDOW);
  if (visible.length === 0) return;

  // Build a key from visible marker years to detect actual changes
  const visibleKey = visible.map(m => m._sliceYear).sort().join(',');

  if (mapIsPlaying) {
    // During autoplay: only refit when the visible set changes (marker enters/exits)
    if (visibleKey === _lastVisibleSet) return;
    _lastVisibleSet = visibleKey;
    if (visible.length === 1) {
      map.flyTo(visible[0].getLatLng(), 5, { duration: 1.0 });
    } else {
      const group = L.featureGroup(visible);
      map.flyToBounds(group.getBounds().pad(0.4), { maxZoom: 6, duration: 1.0 });
    }
  } else {
    // Manual scrubbing: throttle to one fit every 600ms
    const now = Date.now();
    if (_lastFitSet && now - _lastFitSet < 600) return;
    _lastFitSet = now;
    _lastVisibleSet = visibleKey;
    if (visible.length === 1) {
      map.flyTo(visible[0].getLatLng(), 5, { duration: 0.5 });
    } else {
      const group = L.featureGroup(visible);
      map.flyToBounds(group.getBounds().pad(0.4), { maxZoom: 6, duration: 0.5 });
    }
  }
}

document.getElementById('timeSlider').addEventListener('input', (e) => {
  // If a thread tour is playing, stop it ‚Äî user takes over
  if (mapIsPlaying) stopMapPlay();
  updateTimeFilter(parseInt(e.target.value));
});

// Auto-play ‚Äî density-proportional speed (normal mode)
// Thread tour ‚Äî sequential fly-between with arc animation (thread mode)
function startMapPlay() {
  if (mapActiveThread) {
    startThreadTour();
    return;
  }

  mapIsPlaying = true;
  _lastVisibleSet = '';  // reset so first frame triggers a fit
  document.getElementById('timePlayBtn').classList.add('playing');

  const slider = document.getElementById('timeSlider');
  const min = parseInt(slider.min);
  const max = parseInt(slider.max);
  const current = parseInt(slider.value);

  // Only reset to start if slider is at the end; otherwise resume from current position
  if (current >= max) {
    slider.value = min;
    updateTimeFilter(min);
  }

  // Build a speed map: faster in empty stretches, slower near entries
  const entryYears = SLICES.map(s => parseInt(s.year)).sort((a, b) => a - b);

  function getSpeed(year) {
    // Find distance to nearest entry
    let minDist = Infinity;
    for (const ey of entryYears) {
      minDist = Math.min(minDist, Math.abs(year - ey));
    }

    // Near an entry (within 30 years): slow ‚Äî 2 years/frame
    // Far from any entry (>200 years): fast ‚Äî 15 years/frame
    // In between: interpolate
    if (minDist <= 30) return 2;
    if (minDist >= 200) return 15;
    return 2 + (minDist - 30) / (200 - 30) * 13;
  }

  // Pause briefly when hitting an entry
  let pauseFrames = 0;

  function tick() {
    if (!mapIsPlaying) return;

    const current = parseInt(slider.value);
    if (current >= max) {
      stopMapPlay();
      return;
    }

    // If pausing at an entry, count down
    if (pauseFrames > 0) {
      pauseFrames--;
      requestAnimationFrame(tick);
      return;
    }

    const speed = getSpeed(current);
    const next = Math.min(current + Math.round(speed), max);
    slider.value = next;
    updateTimeFilter(next);

    // Check if we just passed an entry ‚Äî pause for a beat
    for (const ey of entryYears) {
      if (ey > current && ey <= next) {
        pauseFrames = 45; // ~0.75 seconds at 60fps
        break;
      }
    }

    requestAnimationFrame(tick);
  }

  requestAnimationFrame(tick);
}

// Thread tour: guided journey through thread entries
let _threadTourAbort = false;

async function startThreadTour() {
  const threadId = mapActiveThread;
  if (!threadId) return;

  // Get thread entries sorted chronologically
  const threadSlices = SLICES
    .filter(s => (s.threads || []).includes(threadId) && s.location)
    .sort((a, b) => parseInt(a.year) - parseInt(b.year));

  if (threadSlices.length < 2) {
    // Not enough entries for a tour ‚Äî fall back to normal play
    mapActiveThread = null;
    startMapPlay();
    mapActiveThread = threadId;
    return;
  }

  mapIsPlaying = true;
  _threadTourAbort = false;
  document.getElementById('timePlayBtn').classList.add('playing');

  const slider = document.getElementById('timeSlider');

  // Clear existing arcs ‚Äî we'll draw them one by one
  clearMapArcs();

  // Helper: wait ms, checking for abort
  function wait(ms) {
    return new Promise(resolve => {
      const start = Date.now();
      function check() {
        if (_threadTourAbort || !mapIsPlaying) { resolve(); return; }
        if (Date.now() - start >= ms) { resolve(); return; }
        requestAnimationFrame(check);
      }
      check();
    });
  }

  // Helper: smoothly animate slider from current to target year
  function animateSlider(targetYear, durationMs) {
    return new Promise(resolve => {
      const startVal = parseInt(slider.value);
      const diff = targetYear - startVal;
      const startTime = performance.now();
      function frame(now) {
        if (_threadTourAbort || !mapIsPlaying) { resolve(); return; }
        const elapsed = now - startTime;
        const progress = Math.min(elapsed / durationMs, 1);
        // Ease in-out
        const eased = progress < 0.5
          ? 2 * progress * progress
          : 1 - Math.pow(-2 * progress + 2, 2) / 2;
        const val = Math.round(startVal + diff * eased);
        slider.value = val;
        updateTimeFilter(val);
        if (progress < 1) requestAnimationFrame(frame);
        else resolve();
      }
      requestAnimationFrame(frame);
    });
  }

  // Helper: draw a single arc between two markers, animated ‚Äî camera follows the tip
  function drawSingleArc(fromSlice, toSlice) {
    return new Promise(resolve => {
      const fromMarker = mapMarkers.find(m => m._sliceYear === parseInt(fromSlice.year));
      const toMarker = mapMarkers.find(m => m._sliceYear === parseInt(toSlice.year));
      if (!fromMarker || !toMarker) { resolve(); return; }

      const from = fromMarker.getLatLng();
      const to = toMarker.getLatLng();
      const latlngs = generateArc(from, to, 100);

      const glowArc = L.polyline([], {
        color: 'rgba(124,111,247,0.2)',
        weight: 8, lineCap: 'round', lineJoin: 'round', interactive: false,
      }).addTo(map);

      const arc = L.polyline([], {
        color: 'rgba(124,111,247,0.7)',
        weight: 3, lineCap: 'round', lineJoin: 'round', interactive: false,
      }).addTo(map);

      mapArcs.push(glowArc, arc);

      const gap = parseInt(toSlice.year) - parseInt(fromSlice.year);
      const midIdx = Math.floor(latlngs.length / 2);

      // Animate arc drawing ‚Äî 1 point per frame for ~1.7s at 60fps
      let frame = 0;
      const totalFrames = latlngs.length;
      // Pan camera every N frames to follow the arc tip smoothly
      const panEvery = 20;

      function animateArc() {
        if (_threadTourAbort || !mapIsPlaying) { resolve(); return; }
        frame++;
        const partial = latlngs.slice(0, Math.min(frame, totalFrames));
        glowArc.setLatLngs(partial);
        arc.setLatLngs(partial);

        // Gently pan to keep arc tip in view
        if (frame % panEvery === 0 && frame < totalFrames) {
          const tip = latlngs[Math.min(frame, totalFrames - 1)];
          map.panTo(tip, { animate: true, duration: 0.5, noMoveStart: true });
        }

        if (frame < totalFrames) {
          requestAnimationFrame(animateArc);
        } else {
          // Add year label after arc completes
          const yearLabel = L.marker(latlngs[midIdx], {
            icon: L.divIcon({
              className: '',
              html: `<div style="
                color:rgba(255,255,255,0.95);
                font-family:var(--mono);
                font-size:0.65rem;
                font-weight:600;
                text-shadow:0 0 6px rgba(124,111,247,0.7), 0 0 12px rgba(124,111,247,0.4), 0 1px 3px rgba(0,0,0,0.9);
                white-space:nowrap;
                pointer-events:none;
                opacity:0;
                transition:opacity 0.4s ease;
              ">${gap} yrs ‚Üí</div>`,
              iconSize: [60, 16],
              iconAnchor: [30, 8],
            }),
            interactive: false,
          }).addTo(map);
          mapArcs.push(yearLabel);
          // Fade in label
          requestAnimationFrame(() => {
            const el = yearLabel.getElement();
            if (el) el.querySelector('div').style.opacity = '1';
          });
          resolve();
        }
      }
      animateArc();
    });
  }

  // Helper: pulse a marker
  function pulseMarker(year) {
    const marker = mapMarkers.find(m => m._sliceYear === parseInt(year));
    if (!marker) return;
    const el = marker.getElement();
    if (!el) return;
    const dot = el.querySelector('.map-marker');
    if (dot) {
      dot.classList.add('arriving');
      setTimeout(() => dot.classList.remove('arriving'), 1200);
    }
  }

  // Suppress auto-fit during tour ‚Äî we control the camera
  _suppressAutoFit = true;

  // Start: set slider just before first entry, show all thread markers
  const firstYear = parseInt(threadSlices[0].year);
  slider.value = firstYear;
  updateTimeFilter(firstYear);

  // Fly to first entry
  const firstLoc = threadSlices[0].location;
  map.flyTo([firstLoc.lat, firstLoc.lon], 5, { duration: 1.5, easeLinearity: 0.1 });
  await wait(1800);
  if (_threadTourAbort) { _suppressAutoFit = false; return; }

  pulseMarker(threadSlices[0].year);
  await wait(1000);
  if (_threadTourAbort) { _suppressAutoFit = false; return; }

  // Journey through each consecutive pair
  for (let i = 0; i < threadSlices.length - 1; i++) {
    if (_threadTourAbort || !mapIsPlaying) break;

    const current = threadSlices[i];
    const next = threadSlices[i + 1];
    const currentYear = parseInt(current.year);
    const nextYear = parseInt(next.year);

    // Gently fit both endpoints into view before drawing
    const fromMarker = mapMarkers.find(m => m._sliceYear === currentYear);
    const toMarker = mapMarkers.find(m => m._sliceYear === nextYear);
    if (fromMarker && toMarker) {
      const group = L.featureGroup([fromMarker, toMarker]);
      map.flyToBounds(group.getBounds().pad(0.6), { maxZoom: 5, duration: 1.5, easeLinearity: 0.1 });
      await wait(1800);
      if (_threadTourAbort) break;
    }

    // Animate slider while arc draws ‚Äî run both concurrently
    const sliderDuration = Math.min(Math.max((nextYear - currentYear) * 3, 800), 2000);
    const arcPromise = drawSingleArc(current, next);
    const sliderPromise = animateSlider(nextYear, sliderDuration);
    await Promise.all([arcPromise, sliderPromise]);
    if (_threadTourAbort) break;

    // Brief pause at destination
    pulseMarker(next.year);
    await wait(1000);
  }

  _suppressAutoFit = false;

  // End: zoom to fit all thread entries
  const threadMarkers = mapMarkers.filter(m => m._sliceThreads.includes(threadId));
  if (threadMarkers.length > 1) {
    const group = L.featureGroup(threadMarkers);
    map.flyToBounds(group.getBounds().pad(0.4), { maxZoom: 5, duration: 1.5, easeLinearity: 0.1 });
  }

  stopMapPlay();
}

function stopMapPlay() {
  mapIsPlaying = false;
  _threadTourAbort = true;
  _suppressAutoFit = false;
  document.getElementById('timePlayBtn').classList.remove('playing');
}

document.getElementById('timePlayBtn').addEventListener('click', () => {
  if (mapIsPlaying) stopMapPlay();
  else startMapPlay();
});

// Thread arcs on map
function activateMapThread(threadId) {
  mapActiveThread = threadId;

  // Close any open popup to avoid overlap with thread banner
  map.closePopup();

  // Also activate in timeline
  activeThread = threadId;

  // Dim non-matching markers, ensure thread members are visible regardless of time window
  mapMarkers.forEach(marker => {
    const el = marker.getElement();
    if (!el) return;
    const dot = el.querySelector('.map-marker');
    const label = el.querySelector('.map-marker-label');
    if (!dot) return;
    if (marker._sliceThreads.includes(threadId)) {
      dot.classList.remove('dimmed');
      dot.classList.remove('hidden-by-time');
      dot.style.opacity = 1;
      if (label) label.style.opacity = 1;
    } else {
      dot.classList.add('dimmed');
    }
  });

  // Draw arcs between all thread entries (ignore time window)
  drawMapArcsAll(threadId);

  // Show banner
  document.getElementById('mapThreadName').textContent = formatThreadId(threadId);
  document.getElementById('mapThreadLabel').textContent = t('thread');
  document.getElementById('mapThreadBanner').classList.add('visible');

  // Fit bounds to thread entries
  const threadMarkers = mapMarkers.filter(m => m._sliceThreads.includes(threadId));
  if (threadMarkers.length > 1) {
    const group = L.featureGroup(threadMarkers);
    map.fitBounds(group.getBounds().pad(0.4), { maxZoom: 6 });
  }

  // Narrow slider to thread year range
  const threadYears = SLICES.filter(s => (s.threads || []).includes(threadId))
    .map(s => parseInt(s.year)).sort((a, b) => a - b);
  if (threadYears.length >= 1) {
    const slider = document.getElementById('timeSlider');
    slider.min = threadYears[0];
    slider.max = threadYears[threadYears.length - 1];
    slider.value = slider.max;
    updateTimeFilter(parseInt(slider.max));
  }
}

function clearMapThread() {
  mapActiveThread = null;
  activeThread = null; // keep both views in sync

  mapMarkers.forEach(marker => {
    const el = marker.getElement();
    if (!el) return;
    const dot = el.querySelector('.map-marker');
    if (dot) dot.classList.remove('dimmed');
  });

  clearMapArcs();
  document.getElementById('mapThreadBanner').classList.remove('visible');

  // Restore full slider range
  if (SLICES.length > 0) {
    const years = SLICES.map(s => parseInt(s.year)).sort((a, b) => a - b);
    const slider = document.getElementById('timeSlider');
    slider.min = Math.max(years[0] - 100, -3000);
    slider.max = new Date().getFullYear();
    slider.value = slider.max;
    updateTimeFilter(parseInt(slider.max));
  }
}

function drawMapArcs(threadId, maxYear) {
  clearMapArcs();

  // All thread markers (always visible in thread mode), sorted chronologically
  const threadMarkers = mapMarkers
    .filter(m => m._sliceThreads.includes(threadId))
    .sort((a, b) => a._sliceYear - b._sliceYear);

  if (threadMarkers.length < 2) return;

  // Only draw arcs where the slider has reached the destination event
  for (let i = 0; i < threadMarkers.length - 1; i++) {
    const toYear = threadMarkers[i + 1]._sliceYear;
    if (toYear > maxYear) break; // slider hasn't reached this event yet

    const from = threadMarkers[i].getLatLng();
    const to = threadMarkers[i + 1].getLatLng();
    const latlngs = generateArc(from, to, 50);

    const glowArc = L.polyline(latlngs, {
      color: 'rgba(124,111,247,0.2)',
      weight: 8, lineCap: 'round', lineJoin: 'round', interactive: false,
    }).addTo(map);

    const arc = L.polyline(latlngs, {
      color: 'rgba(124,111,247,0.7)',
      weight: 3, lineCap: 'round', lineJoin: 'round', interactive: false,
    }).addTo(map);

    const midIdx = Math.floor(latlngs.length / 2);
    const gap = toYear - threadMarkers[i]._sliceYear;
    const yearLabel = L.marker(latlngs[midIdx], {
      icon: L.divIcon({
        className: '',
        html: `<div style="
          color:rgba(255,255,255,0.95);
          font-family:var(--mono);
          font-size:0.65rem;
          font-weight:600;
          text-shadow:0 0 6px rgba(124,111,247,0.7), 0 0 12px rgba(124,111,247,0.4), 0 1px 3px rgba(0,0,0,0.9);
          white-space:nowrap;
          pointer-events:none;
        ">${gap} yrs ‚Üí</div>`,
        iconSize: [60, 16],
        iconAnchor: [30, 8],
      }),
      interactive: false,
    }).addTo(map);

    mapArcs.push(glowArc, arc, yearLabel);
  }
}

// Draw arcs between ALL thread entries (no time window filter) ‚Äî used when thread is selected statically
function drawMapArcsAll(threadId) {
  clearMapArcs();

  const threadMarkers = mapMarkers
    .filter(m => m._sliceThreads.includes(threadId))
    .sort((a, b) => a._sliceYear - b._sliceYear);

  if (threadMarkers.length < 2) return;

  for (let i = 0; i < threadMarkers.length - 1; i++) {
    const from = threadMarkers[i].getLatLng();
    const to = threadMarkers[i + 1].getLatLng();
    const latlngs = generateArc(from, to, 50);

    const glowArc = L.polyline(latlngs, {
      color: 'rgba(124,111,247,0.2)',
      weight: 8, lineCap: 'round', lineJoin: 'round', interactive: false,
    }).addTo(map);

    const arc = L.polyline(latlngs, {
      color: 'rgba(124,111,247,0.7)',
      weight: 3, lineCap: 'round', lineJoin: 'round', interactive: false,
    }).addTo(map);

    // Staggered animation
    const animDelay = i * 400;
    glowArc.setLatLngs([]);
    arc.setLatLngs([]);
    let frame = 0;
    const totalFrames = latlngs.length;
    setTimeout(() => {
      function animateArc() {
        if (frame >= totalFrames) return;
        frame += 2;
        const partial = latlngs.slice(0, Math.min(frame, totalFrames));
        glowArc.setLatLngs(partial);
        arc.setLatLngs(partial);
        if (frame < totalFrames) requestAnimationFrame(animateArc);
      }
      animateArc();
    }, animDelay);

    const midIdx = Math.floor(latlngs.length / 2);
    const gap = threadMarkers[i + 1]._sliceYear - threadMarkers[i]._sliceYear;
    const yearLabel = L.marker(latlngs[midIdx], {
      icon: L.divIcon({
        className: '',
        html: `<div style="
          color:rgba(255,255,255,0.95);
          font-family:var(--mono);
          font-size:0.65rem;
          font-weight:600;
          text-shadow:0 0 6px rgba(124,111,247,0.7), 0 0 12px rgba(124,111,247,0.4), 0 1px 3px rgba(0,0,0,0.9);
          white-space:nowrap;
          pointer-events:none;
        ">${gap} yrs ‚Üí</div>`,
        iconSize: [60, 16],
        iconAnchor: [30, 8],
      }),
      interactive: false,
    }).addTo(map);

    mapArcs.push(glowArc, arc, yearLabel);
  }
}

function clearMapArcs() {
  if (map) mapArcs.forEach(a => map.removeLayer(a));
  mapArcs = [];
}

// Generate a curved arc between two points
function generateArc(from, to, numPoints) {
  const points = [];
  const latDiff = to.lat - from.lat;
  const lngDiff = to.lng - from.lng;
  const dist = Math.sqrt(latDiff * latDiff + lngDiff * lngDiff);

  for (let i = 0; i <= numPoints; i++) {
    const t = i / numPoints;
    const lat = from.lat + latDiff * t;
    const lng = from.lng + lngDiff * t;

    // Offset perpendicular to create curve
    // Curve height proportional to distance
    const curveHeight = dist * 0.15;
    const offset = Math.sin(t * Math.PI) * curveHeight;

    // Perpendicular direction
    const perpLat = -lngDiff / dist * offset;
    const perpLng = latDiff / dist * offset;

    points.push([lat + perpLat, lng + perpLng]);
  }
  return points;
}

// View toggle
function showMapView() {
  initMap();
  document.getElementById('mapView').classList.add('active');
  document.getElementById('mapTimeControl').classList.add('visible');
  document.getElementById('viewToggle').classList.add('active');
  document.getElementById('viewToggle').textContent = t('viewTimeline');
  document.getElementById('quickActions').style.display = 'none';

  // Hide timeline's thread banner ‚Äî header is z-100, above map z-50
  document.getElementById('threadBanner').classList.remove('visible');

  // Fix Leaflet rendering (needs invalidateSize after display:block)
  setTimeout(() => {
    map.invalidateSize();
    populateMap();
    // populateMap handles mapActiveThread re-activation
  }, 150);
}

function showTimelineView() {
  stopMapPlay();
  document.getElementById('mapView').classList.remove('active');
  document.getElementById('mapTimeControl').classList.remove('visible');
  document.getElementById('viewToggle').classList.remove('active');
  document.getElementById('viewToggle').textContent = t('viewMap');
  document.getElementById('quickActions').style.display = 'flex';

  // Sync thread state: apply whatever thread is active (or clear)
  if (activeThread) {
    // Re-apply visual state on the timeline DOM
    activateThread(activeThread);
  } else {
    clearThread();
  }
}

function scrollToEntry(year) {
  showTimelineView();
  setTimeout(() => {
    const entry = document.querySelector(`.entry[data-year="${year}"]`);
    if (entry) {
      entry.scrollIntoView({ behavior: 'smooth', block: 'center' });
      // Flash highlight
      entry.style.transition = 'box-shadow 0.3s ease';
      entry.querySelector('.card').style.boxShadow = '0 0 30px rgba(124,111,247,0.4)';
      setTimeout(() => {
        entry.querySelector('.card').style.boxShadow = '';
      }, 1500);
    }
  }, 200);
}

let _suppressAutoFit = false;

function flyToEntry(year) {
  const slice = SLICES.find(s => String(s.year) === String(year));
  if (!slice || !slice.location) return;
  showMapView();
  setTimeout(() => {
    // Set slider to the entry's year so it (and its contemporaries) are visible
    const slider = document.getElementById('timeSlider');
    const numYear = parseInt(year);
    slider.value = Math.max(parseInt(slider.min), Math.min(parseInt(slider.max), numYear));
    _suppressAutoFit = true;
    updateTimeFilter(parseInt(slider.value));
    setTimeout(() => { _suppressAutoFit = false; }, 500);

    map.flyTo([slice.location.lat, slice.location.lon], 5, { duration: 1.2 });
    // Open the marker popup
    const marker = mapMarkers.find(m => String(m._sliceYear) === String(year));
    if (marker) {
      setTimeout(() => marker.openPopup(), 1300);
    }
  }, 200);
}

document.getElementById('viewToggle').addEventListener('click', () => {
  if (document.getElementById('mapView').classList.contains('active')) {
    showTimelineView();
  } else {
    showMapView();
  }
});

document.getElementById('mapBackBtn').addEventListener('click', showTimelineView);
document.getElementById('mapThreadClose').addEventListener('click', clearMapThread);
document.getElementById('mapThreadBanner').addEventListener('click', clearMapThread);

// Map lang switcher
document.querySelectorAll('[data-map="1"]').forEach(btn => {
  btn.addEventListener('click', () => {
    const lang = btn.dataset.lang;
    if (lang === currentLang) return;
    currentLang = lang;
    // Update both header lang buttons
    document.querySelectorAll('.lang-btn').forEach(b => {
      b.classList.toggle('active', b.dataset.lang === currentLang);
    });
    updateUILabels();
    loadSlices();
    // Repopulate map after slices load
    setTimeout(populateMap, 500);
  });
});

// Helper: reveal all entries so scroll targets are visible
function revealAllEntries() {
  document.querySelectorAll('.entry:not(.visible)').forEach(el => el.classList.add('visible'));
}

// Helper: reveal entry, wait for layout, then smooth-scroll to it
function scrollToEntry(entry) {
  if (!entry) return;
  // 1. Make sure the target (and all others) are visible
  revealAllEntries();
  // 2. Force a layout reflow so the browser knows the entry's position
  entry.getBoundingClientRect();
  // 3. Use requestAnimationFrame to ensure paint is scheduled
  requestAnimationFrame(() => {
    entry.scrollIntoView({ behavior: 'smooth', block: 'center' });
    // 4. Briefly highlight the entry so user can spot it
    entry.style.transition = 'box-shadow 0.3s ease';
    entry.style.boxShadow = '0 0 20px rgba(209,154,102,0.5)';
    setTimeout(() => { entry.style.boxShadow = ''; }, 1500);
  });
}

// üé≤ Random dice ‚Äî scroll to a random slice
document.getElementById('diceBtn').addEventListener('click', async () => {
  const btn = document.getElementById('diceBtn');
  btn.classList.add('rolling');
  setTimeout(() => btn.classList.remove('rolling'), 500);

  await slicesReady;

  const entries = document.querySelectorAll('.entry');
  if (!entries.length) return;
  const target = entries[Math.floor(Math.random() * entries.length)];
  scrollToEntry(target);
});

// ‚òï Coffee button ‚Äî scroll to the freshest entry (the one with the badge)
document.getElementById('coffeeBtn').addEventListener('click', async () => {
  await slicesReady;

  const freshEntry = document.querySelector('.entry .fresh-badge');
  if (!freshEntry) return;
  const entry = freshEntry.closest('.entry');
  scrollToEntry(entry);
});
</script>

</body>
</html>
