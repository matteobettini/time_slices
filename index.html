<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>Time Slices</title>
<link rel="icon" type="image/svg+xml" href="favicon.svg">
<link rel="apple-touch-icon" href="favicon.svg">
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<style>
  :root {
    --bg: #0a0a0f;
    --surface: #14141f;
    --surface2: #1e1e2e;
    --border: #2a2a3a;
    --text: #e0e0e8;
    --text-dim: #8888a0;
    --accent: #7c6ff7;
    --art: #e06090;
    --lit: #60c0e0;
    --phil: #e0a050;
    --hist: #60e080;
    --conn: #c080e0;
    --font: 'Segoe UI', system-ui, -apple-system, sans-serif;
    --mono: 'SF Mono', 'Fira Code', 'Consolas', monospace;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: var(--font);
    overflow-x: hidden;
  }

  /* Header */
  header {
    position: fixed; top: 0; left: 0; right: 0; z-index: 100;
    background: rgba(10,10,15,0.95);
    backdrop-filter: blur(20px);
    border-bottom: 1px solid var(--border);
    padding: 14px 32px;
  }
  .header-top {
    display: flex; align-items: baseline; justify-content: space-between;
    margin-bottom: 10px;
  }
  .header-left { display: flex; align-items: baseline; }
  .header-right { display: flex; align-items: center; gap: 6px; }
  header h1 {
    font-size: 1.4rem; font-weight: 700;
    background: linear-gradient(135deg, var(--accent), var(--art));
    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  }
  header .subtitle { color: var(--text-dim); font-size: 0.85rem; margin-left: 12px; }

  /* Language switcher */
  .lang-btn {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 3px 10px;
    font-size: 0.75rem;
    font-family: var(--font);
    color: var(--text-dim);
    cursor: pointer;
    transition: all 0.2s ease;
    line-height: 1.4;
  }
  .lang-btn:hover { border-color: var(--text-dim); color: var(--text); }
  .lang-btn.active { background: var(--accent); border-color: var(--accent); color: #fff; }

  /* Thread banner */
  .thread-banner {
    display: none;
    align-items: center;
    gap: 10px;
    margin-top: 10px;
    padding: 8px 14px;
    background: var(--surface2);
    border: 1px solid var(--accent);
    border-radius: 10px;
    font-size: 0.8rem;
    color: var(--text);
    animation: fadeIn 0.2s ease;
  }
  .thread-banner.visible { display: flex; }
  .thread-banner .thread-name {
    font-weight: 600;
    color: var(--accent);
  }
  .thread-banner .thread-close {
    cursor: pointer;
    color: var(--text-dim);
    font-size: 1.2rem;
    padding: 4px 8px;
    border-radius: 4px;
    transition: background 0.15s ease, color 0.15s ease;
  }
  .thread-banner .thread-close:hover { color: var(--text); background: rgba(255,255,255,0.1); }
  .thread-banner .thread-count { color: var(--text-dim); }
  .thread-banner .thread-play-all {
    margin-left: auto;
    background: var(--accent);
    color: #fff;
    border: none;
    padding: 4px 12px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.85rem;
    font-weight: 500;
    transition: background 0.15s ease, opacity 0.15s ease;
  }
  .thread-banner .thread-play-all:hover { background: #6358d4; }
  .thread-banner .thread-play-all.playing { background: var(--accent); }
  .thread-banner .thread-close { margin-left: 12px; }

  /* Timeline container */
  .timeline-container {
    margin-top: 110px;
    padding: 40px 32px 80px;
    position: relative;
  }

  /* Central line */
  .timeline-line {
    position: absolute;
    left: 50%;
    top: 0; bottom: 0;
    width: 2px;
    background: linear-gradient(to bottom, transparent, var(--border) 80px, var(--border) calc(100% - 80px), transparent);
    transform: translateX(-50%);
    transition: opacity 0.4s ease;
  }
  .timeline-line.thread-active { opacity: 0.15; }

  /* Entry */
  .entry {
    position: relative;
    width: 45%;
    margin-bottom: 48px;
    cursor: pointer;
    transition: transform 0.2s ease, opacity 0.3s ease, max-height 0.4s ease, margin-bottom 0.4s ease;
    scroll-margin-top: 100px;
    z-index: 1;
  }
  .entry:hover { transform: translateY(-2px); z-index: 2; }
  .entry.expanded { z-index: 3; }
  .entry:nth-child(odd) { margin-left: 5%; }
  .entry:nth-child(even) { margin-left: 50%; }
  .entry.thread-hidden {
    max-height: 0;
    margin-bottom: 0;
    opacity: 0;
    pointer-events: none;
    overflow: hidden;
    transition: max-height 0.4s ease, margin-bottom 0.4s ease, opacity 0.3s ease;
  }
  .entry.thread-highlighted { opacity: 1; }

  /* Kill all entry transitions during thread switching to prevent layout drift */
  .no-transition .entry,
  .no-transition .entry.thread-hidden {
    transition: none !important;
  }

  /* Dot on timeline */
  .entry::before {
    content: '';
    position: absolute;
    top: 24px;
    width: 14px; height: 14px;
    border-radius: 50%;
    background: var(--accent);
    border: 3px solid var(--bg);
    z-index: 2;
    transition: transform 0.2s, box-shadow 0.2s;
  }
  .entry:hover::before {
    transform: scale(1.3);
    box-shadow: 0 0 16px var(--accent);
  }
  .entry:nth-child(odd)::before { right: -32px; }
  .entry:nth-child(even)::before { left: -32px; }

  /* Connector line */
  .entry::after {
    content: '';
    position: absolute;
    top: 30px;
    width: 24px; height: 2px;
    background: var(--border);
  }
  .entry:nth-child(odd)::after { right: -24px; }
  .entry:nth-child(even)::after { left: -24px; }

  /* Card */
  .card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 12px;
    overflow: hidden;
    transition: border-color 0.2s, box-shadow 0.2s;
    position: relative;
    max-width: 100%;
    box-sizing: border-box;
  }

  /* ‚òï Fresh entry badge */
  .fresh-badge {
    position: absolute;
    top: 12px;
    right: 12px;
    width: 36px;
    height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.1rem;
    border-radius: 50%;
    background: rgba(124, 111, 247, 0.15);
    border: 2px solid var(--accent);
    z-index: 10;
    pointer-events: none;
    animation: freshPulse 3s ease-in-out infinite;
  }
  @keyframes freshPulse {
    0%, 100% { box-shadow: 0 0 0 0 rgba(124, 111, 247, 0.3); }
    50% { box-shadow: 0 0 12px 4px rgba(124, 111, 247, 0.15); }
  }

  /* üéß Podcast button */
  .podcast-btn {
    position: absolute;
    top: 12px;
    right: 56px;
    width: 36px;
    height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    background: rgba(124, 111, 247, 0.15);
    border: 2px solid var(--accent);
    color: var(--accent);
    z-index: 10;
    cursor: pointer;
    transition: background 0.2s, transform 0.2s;
    padding: 0;
    line-height: 1;
  }
  .podcast-btn svg { display: block; }
  .podcast-btn:hover {
    background: rgba(124, 111, 247, 0.3);
    transform: scale(1.1);
  }
  /* Shift right if no fresh-badge sibling */
  .card:not(:has(.fresh-badge)) .podcast-btn {
    right: 12px;
  }

  /* üéß Podcast player */
  .podcast-player {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px 14px;
    margin: 10px 0;
    background: rgba(124, 111, 247, 0.08);
    border: 1px solid rgba(124, 111, 247, 0.2);
    border-radius: 10px;
    user-select: none;
  }
  .podcast-player audio { display: none; }
  .pp-play {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    border: 2px solid var(--accent);
    background: rgba(124, 111, 247, 0.15);
    color: var(--accent);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    transition: background 0.2s;
    padding: 0;
  }
  .pp-play svg { display: block; }
  .pp-play:hover { background: rgba(124, 111, 247, 0.3); }
  .pp-progress-wrap {
    flex: 1;
    min-width: 0;
  }
  .pp-progress-bar {
    height: 8px;
    background: rgba(255,255,255,0.1);
    border-radius: 4px;
    cursor: pointer;
    position: relative;
    overflow: hidden;
    touch-action: none;
  }
  .pp-progress-fill {
    height: 100%;
    background: var(--accent);
    border-radius: 4px;
    width: 0%;
    transition: width 0.1s linear;
  }
  .pp-time {
    font-size: 0.7rem;
    color: var(--text-muted);
    margin-top: 4px;
    display: flex;
    gap: 2px;
  }

  /* üé≤ Random dice button */
  /* Floating action buttons below header */
  .quick-actions {
    position: fixed;
    top: 72px;
    right: 32px;
    z-index: 99;
    display: flex;
    gap: 10px;
    align-items: center;
  }
  .quick-btn {
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.3rem;
    border: none;
    border-radius: 50%;
    background: rgba(124, 111, 247, 0.12);
    border: 1.5px solid var(--accent);
    color: var(--text);
    cursor: pointer;
    transition: transform 0.3s ease, box-shadow 0.3s ease, background 0.2s ease;
    backdrop-filter: blur(8px);
  }
  .quick-btn:hover {
    transform: scale(1.12);
    box-shadow: 0 0 16px rgba(124, 111, 247, 0.3);
    background: rgba(124, 111, 247, 0.25);
  }
  .quick-btn:active { transform: scale(0.95); }
  .quick-btn.loading { opacity: 0.4; pointer-events: none; }
  .quick-btn.rolling { animation: diceRoll 0.5s ease-out; }
  .quick-btn.playing { background: var(--accent); border-color: var(--accent); }
  .quick-btn.playing:hover { background: #6358d4; box-shadow: 0 0 16px rgba(124, 111, 247, 0.4); }
  @keyframes diceRoll {
    0% { transform: rotate(0deg) scale(1); }
    25% { transform: rotate(90deg) scale(1.2); }
    50% { transform: rotate(180deg) scale(1); }
    75% { transform: rotate(270deg) scale(1.1); }
    100% { transform: rotate(360deg) scale(1); }
  }
  @media (max-width: 600px) {
    .quick-actions { top: 68px; right: 16px; gap: 8px; }
    .quick-btn { width: 36px; height: 36px; font-size: 1.1rem; }
  }
  .entry:hover .card {
    border-color: var(--accent);
    box-shadow: 0 4px 24px rgba(124,111,247,0.15);
  }
  .entry.expanded .card {
    border-color: var(--accent);
    box-shadow: 0 8px 32px rgba(124,111,247,0.2);
  }

  /* Hero image ‚Äî inline (collapsed state + mobile) */
  .card-image-inline {
    width: 100%;
    height: 500px;
    object-fit: cover;
    object-position: center 20%;
    display: block;
    background: var(--surface2);
    opacity: 0;
    transition: opacity 0.4s ease;
  }
  .card-image-inline.loaded { opacity: 1; }
  .entry.expanded .card-image-inline { display: none; }

  .card-image-caption-inline {
    font-size: 0.7rem;
    color: var(--text-dim);
    padding: 4px 24px 0;
    opacity: 0.6;
    font-style: italic;
  }
  .entry.expanded .card-image-caption-inline { display: none; }

  /* Floating image ‚Äî opposite side (expanded state, desktop only) */
  .floating-image {
    display: none;
    position: absolute;
    top: 0;
    width: 50%;
    z-index: 10;
    animation: fadeIn 0.4s ease;
  }
  .entry.expanded .floating-image { display: block; }
  /* Odd entries are on the left ‚Üí image floats right */
  .entry:nth-child(odd) .floating-image { left: calc(100% + 56px); }
  /* Even entries are on the right ‚Üí image floats left */
  .entry:nth-child(even) .floating-image { right: calc(100% + 56px); }

  .floating-image img {
    width: 100%;
    max-height: 500px;
    object-fit: contain;
    border-radius: 12px;
    background: transparent;
    border: none;
    display: block;
  }
  .floating-image .floating-caption {
    font-size: 0.7rem;
    color: var(--text-dim);
    padding: 6px 4px 0;
    opacity: 0.6;
    font-style: italic;
    text-align: center;
  }
  .floating-image .floating-attribution {
    font-size: 0.6rem;
    color: var(--text-dim);
    opacity: 0.4;
    text-align: center;
    padding-top: 2px;
  }

  .card-body {
    padding: 20px 24px;
    overflow-wrap: break-word;
    word-wrap: break-word;
    word-break: break-word;
    min-width: 0;
  }

  .card-year {
    font-family: var(--mono);
    font-size: 0.75rem;
    color: var(--accent);
    letter-spacing: 0.1em;
    text-transform: uppercase;
    margin-bottom: 6px;
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .card-map-link {
    font-size: 0.7rem;
    color: var(--text-dim);
    cursor: pointer;
    opacity: 0.5;
    transition: opacity 0.2s ease, color 0.2s ease;
    text-decoration: none;
    font-family: system-ui, sans-serif;
  }
  .card-map-link:hover {
    opacity: 1;
    color: var(--accent);
  }
  .card-title {
    font-size: 1.15rem;
    font-weight: 600;
    margin-bottom: 8px;
    line-height: 1.3;
  }
  .card-teaser {
    font-size: 0.9rem;
    color: var(--text-dim);
    line-height: 1.5;
  }

  /* Thread tags */
  .card-threads {
    display: flex; flex-wrap: wrap; gap: 6px;
    margin-top: 12px;
  }
  .thread-tag {
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 2px 10px;
    font-size: 0.7rem;
    color: var(--text-dim);
    cursor: pointer;
    transition: all 0.2s ease;
  }
  .thread-tag:hover {
    border-color: var(--accent);
    color: var(--accent);
    background: rgba(124,111,247,0.1);
  }
  .thread-tag.active {
    border-color: var(--accent);
    color: #fff;
    background: var(--accent);
  }

  /* Expanded content */
  .card-details {
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.5s ease, opacity 0.3s ease;
    opacity: 0;
  }
  .entry.expanded .card-details {
    opacity: 1;
    overflow: visible;
    overflow-wrap: break-word;
    word-wrap: break-word;
    word-break: break-word;
  }

  /* Dimension sections */
  .dimension {
    padding: 14px 0;
    border-top: 1px solid var(--border);
    transition: opacity 0.3s ease, max-height 0.3s ease;
  }
  .dimension:first-child { border-top: none; }
  .dim-header {
    display: flex; align-items: center; gap: 8px;
    font-weight: 600; font-size: 0.9rem;
    margin-bottom: 8px;
  }
  .dim-icon { font-size: 1.1rem; }
  .dim-label-art { color: var(--art); }
  .dim-label-lit { color: var(--lit); }
  .dim-label-phil { color: var(--phil); }
  .dim-label-hist { color: var(--hist); }
  .dim-label-conn { color: var(--conn); }

  .dim-content {
    font-size: 0.88rem;
    line-height: 1.7;
    color: var(--text-dim);
    overflow-wrap: break-word;
    word-wrap: break-word;
    word-break: break-word;
  }
  .dim-content strong { color: var(--text); font-weight: 500; }
  .dim-content em { color: var(--text); font-style: italic; }

  /* Fun fact callout */
  .fun-fact {
    background: var(--surface2);
    border-left: 3px solid var(--border);
    border-radius: 0 8px 8px 0;
    padding: 10px 14px;
    margin-top: 10px;
    font-size: 0.85rem;
    color: var(--text-dim);
    transition: border-color 0.4s ease, background 0.4s ease;
    overflow-wrap: break-word;
    word-wrap: break-word;
    word-break: break-word;
  }
  .fun-fact::before { content: 'üí° '; }
  .entry.expanded .fun-fact {
    border-left-color: var(--accent);
    background: rgba(124,111,247,0.06);
  }

  /* Sources */
  .card-sources {
    padding-top: 12px;
    border-top: 1px solid var(--border);
    margin-top: 4px;
  }
  .card-sources summary {
    font-size: 0.75rem;
    color: var(--text-dim);
    cursor: pointer;
    opacity: 0.6;
  }
  .card-sources summary:hover { opacity: 1; }
  .card-sources a {
    display: block;
    font-size: 0.72rem;
    color: var(--accent);
    text-decoration: none;
    padding: 2px 0;
    opacity: 0.7;
  }
  .card-sources a:hover { opacity: 1; text-decoration: underline; }

  /* Expand hint */
  .expand-hint {
    font-size: 0.75rem;
    color: var(--text-dim);
    margin-top: 10px;
    opacity: 0.6;
    transition: opacity 0.2s;
  }
  .entry:hover .expand-hint { opacity: 1; }
  .entry.expanded .expand-hint { display: none; }

  /* Reference markers */
  .marker {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 12px;
    height: 28px;
  }
  .marker.thread-hidden { display: none; }

  /* Thread narrative connector */
  .thread-narrative {
    position: relative;
    width: 50%;
    margin: 32px auto;
    padding: 14px 20px;
    background: var(--bg);
    border: 1px solid rgba(124,111,247,0.25);
    border-radius: 10px;
    font-size: 0.82rem;
    line-height: 1.6;
    color: var(--text-dim);
    text-align: center;
    animation: fadeIn 0.4s ease;
    z-index: 50;
    /* Cover the timeline line behind */
    box-shadow: 0 0 0 12px var(--bg), 0 0 20px rgba(124,111,247,0.08);
    clear: both;
  }
  .thread-narrative .narrative-arrow {
    color: var(--accent);
    opacity: 0.5;
    display: block;
    font-size: 1.2rem;
    margin-bottom: 6px;
  }
  .thread-narrative strong { color: var(--text); font-weight: 500; }
  .thread-narrative em { color: var(--accent); }

  /* SVG thread lines overlay */
  .thread-lines-svg {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 0;
    overflow: visible;
  }
  .marker-line {
    position: absolute;
    left: calc(50% - 60px);
    width: 120px;
    height: 1px;
    background: var(--border);
    opacity: 0.6;
  }
  .marker-label {
    position: relative;
    z-index: 2;
    font-family: var(--mono);
    font-size: 0.65rem;
    color: var(--text-dim);
    letter-spacing: 0.08em;
    background: var(--bg);
    padding: 2px 10px;
    border: 1px solid var(--border);
    border-radius: 10px;
    white-space: nowrap;
    opacity: 0.5;
    transition: opacity 0.2s;
  }
  .marker:hover .marker-label { opacity: 1; }

  /* Responsive */
  @media (max-width: 768px) {
    .timeline-line { left: 24px; }
    .entry { width: calc(100% - 60px); margin-left: 50px !important; }
    .entry::before { left: -33px !important; right: auto !important; }
    .entry::after { left: -24px !important; right: auto !important; }
    header { padding: 10px 16px; }
    .header-top { margin-bottom: 8px; }
    .timeline-container { padding: 40px 16px 80px; margin-top: 120px; }
    .subtitle { display: none; }
    .card-image-inline { max-height: none; height: auto; object-fit: contain; object-position: center; }
    /* On mobile: no floating image, keep inline visible when expanded */
    .floating-image { display: none !important; }
    .entry.expanded .card-image-inline { display: block; }
    .entry.expanded .card-image-caption-inline { display: block; }
    .thread-narrative { width: 80%; }
    .thread-lines-svg { display: none; }
  }

  /* Scroll animation */
  .entry { opacity: 0; transform: translateY(20px); transition: opacity 0.5s ease, transform 0.5s ease; }
  .entry.visible { opacity: 1; transform: translateY(0); }
  .entry:hover.visible { transform: translateY(-2px); }
  .entry.thread-hidden.visible { opacity: 0; transform: translateY(0); }

  @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

  /* Thread dropdown */
  .thread-dropdown {
    position: relative;
    margin-right: 10px;
  }
  .thread-dropdown-btn {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 3px 10px;
    font-size: 0.85rem;
    font-family: var(--font);
    color: var(--text-dim);
    cursor: pointer;
    transition: all 0.2s ease;
    line-height: 1.4;
  }
  .thread-dropdown-btn:hover { border-color: var(--text-dim); color: var(--text); }
  .thread-dropdown-btn.active { border-color: var(--accent); color: var(--accent); }
  .thread-dropdown-menu {
    display: none;
    position: absolute;
    top: 100%;
    right: 0;
    margin-top: 6px;
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 8px 0;
    min-width: 220px;
    max-height: 400px;
    overflow-y: auto;
    box-shadow: 0 8px 32px rgba(0,0,0,0.4);
    z-index: 1000;
  }
  .thread-dropdown-menu.open { display: block; }
  .thread-dropdown-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 14px;
    font-size: 0.85rem;
    color: var(--text-dim);
    cursor: pointer;
    transition: background 0.15s ease, color 0.15s ease;
  }
  .thread-dropdown-item:hover { background: rgba(124,111,247,0.1); color: var(--text); }
  .thread-dropdown-item.active { background: rgba(124,111,247,0.15); color: var(--accent); }
  .thread-dropdown-item .thread-count { 
    font-size: 0.75rem; 
    color: var(--text-dim); 
    background: rgba(255,255,255,0.05);
    padding: 2px 6px;
    border-radius: 10px;
  }

  /* View toggle */
  .view-toggle {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 3px 10px;
    font-size: 0.85rem;
    font-family: var(--font);
    color: var(--text-dim);
    cursor: pointer;
    transition: all 0.2s ease;
    line-height: 1.4;
    margin-right: 10px;
  }
  .view-toggle:hover { border-color: var(--text-dim); color: var(--text); }
  .view-toggle.active { background: var(--accent); border-color: var(--accent); color: #fff; }

  /* Map container */
  #mapView {
    display: none;
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    z-index: 50;
    background: var(--bg);
  }
  #mapView.active { display: block; }

  #map {
    position: absolute;
    top: 56px;
    left: 0; right: 0;
    bottom: 72px;
  }

  /* Override Leaflet popups */
  .leaflet-popup-content-wrapper {
    background: var(--surface) !important;
    border: 1px solid var(--accent) !important;
    border-radius: 12px !important;
    color: var(--text) !important;
    box-shadow: 0 8px 32px rgba(124,111,247,0.2) !important;
  }
  .leaflet-popup-tip-container {
    overflow: visible !important;
    margin-top: -1px !important;
  }
  .leaflet-popup-tip {
    background: var(--surface) !important;
    border-right: 1px solid var(--accent) !important;
    border-bottom: 1px solid var(--accent) !important;
    border-top: none !important;
    border-left: none !important;
    box-shadow: none !important;
  }
  .leaflet-popup-tip::after {
    display: none;
  }
  .leaflet-popup-content {
    margin: 14px 18px !important;
    font-family: var(--font) !important;
    font-size: 0.88rem !important;
    line-height: 1.5 !important;
  }
  .leaflet-popup-close-button {
    color: var(--text-dim) !important;
    font-size: 1.2rem !important;
  }
  .leaflet-popup-close-button:hover { color: var(--text) !important; }

  .map-popup-year {
    font-family: var(--mono);
    font-size: 0.72rem;
    color: var(--accent);
    letter-spacing: 0.1em;
    margin-bottom: 4px;
  }
  .map-popup-title {
    font-size: 1rem;
    font-weight: 600;
    margin-bottom: 6px;
  }
  .map-popup-teaser {
    font-size: 0.82rem;
    color: var(--text-dim);
    margin-bottom: 10px;
    line-height: 1.5;
  }
  .map-popup-threads {
    display: flex; flex-wrap: wrap; gap: 4px;
    margin-bottom: 10px;
  }
  .map-popup-link {
    display: inline-block;
    font-size: 0.78rem;
    color: var(--accent);
    text-decoration: none;
    cursor: pointer;
  }
  .map-popup-link:hover { text-decoration: underline; }

  .map-popup-audio {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 10px;
    padding: 6px 10px;
    border-radius: 8px;
    background: rgba(255,255,255,0.05);
    border: 1px solid var(--border);
    cursor: pointer;
    transition: background 0.2s;
  }
  .map-popup-audio:hover { background: rgba(255,255,255,0.1); }
  .map-popup-audio .mpa-icon {
    flex-shrink: 0;
    color: var(--accent);
    display: flex;
    align-items: center;
  }
  .map-popup-audio .mpa-label {
    font-size: 0.75rem;
    color: var(--text-dim);
    flex: 1;
  }
  .map-popup-audio .mpa-duration {
    font-size: 0.7rem;
    color: var(--text-dim);
    font-family: var(--mono);
    opacity: 0.7;
  }
  .map-popup-audio.playing .mpa-icon { color: #f44; }
  .map-popup-audio.playing { border-color: var(--accent); }

  /* Map time slider */
  .map-time-control {
    position: fixed;
    bottom: 0; left: 0; right: 0;
    z-index: 60;
    background: rgba(10,10,15,0.95);
    backdrop-filter: blur(20px);
    border-top: 1px solid var(--border);
    padding: 16px 32px calc(20px + env(safe-area-inset-bottom, 0px));
    display: none;
  }
  .map-time-control.visible { display: block; }

  .time-slider-row {
    display: flex;
    align-items: center;
    gap: 16px;
  }
  .time-year-display {
    font-family: var(--mono);
    font-size: 1.4rem;
    color: var(--accent);
    font-weight: 700;
    min-width: 70px;
    text-align: center;
  }
  .time-slider {
    flex: 1;
    -webkit-appearance: none;
    appearance: none;
    height: 4px;
    background: var(--border);
    border-radius: 2px;
    outline: none;
    cursor: pointer;
  }
  .time-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 18px; height: 18px;
    border-radius: 50%;
    background: var(--accent);
    box-shadow: 0 0 12px rgba(124,111,247,0.5);
    cursor: pointer;
    transition: transform 0.15s ease;
  }
  .time-slider::-webkit-slider-thumb:hover { transform: scale(1.3); }
  .time-slider::-moz-range-thumb {
    width: 18px; height: 18px;
    border-radius: 50%;
    background: var(--accent);
    border: none;
    box-shadow: 0 0 12px rgba(124,111,247,0.5);
    cursor: pointer;
  }
  .time-play-btn {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 50%;
    width: 36px; height: 36px;
    font-size: 1rem;
    color: var(--text-dim);
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex; align-items: center; justify-content: center;
    position: relative;
  }
  .time-play-btn .play-icon,
  .time-play-btn .pause-icon { display: flex; align-items: center; justify-content: center; }
  .time-play-btn .play-icon {
    width: 0; height: 0;
    border-style: solid;
    border-width: 6px 0 6px 10px;
    border-color: transparent transparent transparent var(--text-dim);
    margin-left: 2px;
    transition: border-color 0.2s ease;
  }
  .time-play-btn .pause-icon {
    display: none;
    gap: 3px;
  }
  .time-play-btn .pause-icon span {
    width: 3px; height: 12px;
    background: #fff;
    border-radius: 1px;
  }
  .time-play-btn:hover .play-icon { border-left-color: var(--accent); }
  .time-play-btn.playing { background: var(--accent); border-color: var(--accent); }
  .time-play-btn.playing .play-icon { display: none; }
  .time-play-btn.playing .pause-icon { display: flex; }

  /* Map marker pulse */
  @keyframes markerPulse {
    0% { box-shadow: 0 0 0 0 rgba(124,111,247,0.6); }
    70% { box-shadow: 0 0 0 16px rgba(124,111,247,0); }
    100% { box-shadow: 0 0 0 0 rgba(124,111,247,0); }
  }
  .map-marker-wrap {
    position: relative;
    width: 40px; height: 40px;
    display: flex; align-items: center; justify-content: center;
    cursor: pointer;
  }
  .map-marker {
    width: 22px; height: 22px;
    border-radius: 50%;
    background: var(--accent);
    border: 3px solid var(--bg);
    box-shadow: 0 0 16px rgba(124,111,247,0.5);
    transition: opacity 0.5s ease, transform 0.3s ease;
    position: relative;
    z-index: 2;
  }
  .map-marker-wrap:hover .map-marker { transform: scale(1.3); }
  .map-marker.arriving {
    animation: markerPulse 1.2s ease-out;
  }
  .map-marker-ring {
    position: absolute;
    width: 36px; height: 36px;
    border-radius: 50%;
    border: 2px solid rgba(124,111,247,0.25);
    top: 2px; left: 2px;
    z-index: 1;
    transition: opacity 0.5s ease;
  }
  .map-marker.dimmed { opacity: 0.15; pointer-events: none; }
  .map-marker.dimmed + .map-marker-ring { opacity: 0.1; pointer-events: none; }
  .map-marker.dimmed ~ .map-marker-label { opacity: 0.15; pointer-events: none; }
  .map-marker.dimmed ~ .map-marker-year { opacity: 0.15; pointer-events: none; }
  .map-marker.hidden-by-time { opacity: 0; pointer-events: none; }
  .map-marker.hidden-by-time + .map-marker-ring { opacity: 0; }
  .map-marker.hidden-by-time ~ .map-marker-label { opacity: 0; }
  .map-marker.hidden-by-time ~ .map-marker-year { opacity: 0; }

  .map-marker-label {
    position: absolute;
    top: 38px; left: 50%;
    transform: translateX(-50%);
    font-family: var(--mono);
    font-size: 0.65rem;
    color: var(--text);
    white-space: nowrap;
    letter-spacing: 0.05em;
    text-shadow: 0 1px 6px rgba(0,0,0,0.9), 0 0 12px rgba(0,0,0,0.6);
    pointer-events: none;
    transition: opacity 0.5s ease;
    z-index: 3;
  }
  .map-marker-year {
    display: none;
    position: absolute;
    top: 26px; left: 50%;
    transform: translateX(-50%);
    font-family: var(--mono);
    font-size: 0.55rem;
    font-weight: 600;
    color: rgba(255,255,255,0.9);
    white-space: nowrap;
    letter-spacing: 0.05em;
    text-shadow: 0 1px 4px rgba(0,0,0,0.95), 0 0 8px rgba(0,0,0,0.7);
    pointer-events: none;
    transition: opacity 0.5s ease;
    z-index: 3;
  }

  /* Map thread arcs */
  .thread-arc {
    fill: none;
    stroke: rgba(124,111,247,0.5);
    stroke-width: 2.5;
    stroke-linecap: round;
    filter: drop-shadow(0 0 6px rgba(124,111,247,0.4));
  }

  /* Map header bar */
  .map-header {
    position: fixed;
    top: 0; left: 0; right: 0;
    z-index: 70;
    background: rgba(10,10,15,0.95);
    backdrop-filter: blur(20px);
    border-bottom: 1px solid var(--border);
    padding: 14px 32px;
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
  .map-header h1 {
    font-size: 1.4rem; font-weight: 700;
    background: linear-gradient(135deg, var(--accent), var(--art));
    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  }
  .map-header .subtitle { color: var(--text-dim); font-size: 0.85rem; margin-left: 12px; }

  .map-thread-banner {
    display: none;
    position: fixed;
    top: 72px; left: 50%;
    transform: translateX(-50%);
    z-index: 1100; /* above Leaflet popups (z-index ~700) */
    align-items: center;
    gap: 10px;
    padding: 8px 18px;
    background: rgba(10,10,15,0.95);
    backdrop-filter: blur(20px);
    border: 1px solid var(--accent);
    border-radius: 10px;
    font-size: 0.8rem;
    color: var(--text);
    animation: fadeIn 0.2s ease;
    cursor: pointer; /* whole banner is clickable to dismiss */
  }
  .map-thread-banner.visible { display: flex; }
  .map-thread-banner .thread-name { font-weight: 600; color: var(--accent); }
  .map-thread-banner .thread-close {
    margin-left: auto; cursor: pointer;
    color: var(--text-dim); font-size: 1.2rem;
    padding: 4px 8px;
    border-radius: 4px;
    transition: background 0.15s ease, color 0.15s ease;
  }
  .map-thread-banner .thread-close:hover { color: var(--text); background: rgba(255,255,255,0.1); }

  @media (max-width: 768px) {
    .map-time-control { padding: 12px 16px calc(16px + env(safe-area-inset-bottom, 0px)); }
    .time-year-display { font-size: 1.1rem; min-width: 55px; }
    .time-slider { touch-action: none; height: 6px; }
    .time-slider::-webkit-slider-thumb { width: 26px; height: 26px; }
    .time-slider::-moz-range-thumb { width: 26px; height: 26px; }
    .map-marker-label { display: none; }
    .map-marker-year { display: block; }
    .map-header .subtitle { display: none; }
    /* Move thread banner above time controls on mobile to avoid popup overlap */
    .map-thread-banner {
      top: auto;
      bottom: 100px;
      left: 16px;
      right: 16px;
      transform: none;
      max-width: none;
      font-size: 0.75rem;
    }
  }
</style>
</head>
<body>

<header>
  <div class="header-top">
    <div class="header-left">
      <h1>Time Slices</h1>
      <span class="subtitle" id="subtitle">Cross-disciplinary history exploration</span>
    </div>
    <div class="header-right">
      <div class="thread-dropdown" id="threadDropdown">
        <button class="thread-dropdown-btn" id="threadDropdownBtn">üßµ Threads</button>
        <div class="thread-dropdown-menu" id="threadDropdownMenu"></div>
      </div>
      <button class="view-toggle" id="viewToggle"></button>
      <button class="lang-btn active" data-lang="en">EN</button>
      <button class="lang-btn" data-lang="it">IT</button>
    </div>
  </div>
  <div class="thread-banner" id="threadBanner">
    <span>üßµ Thread: <span class="thread-name" id="threadName"></span></span>
    <span class="thread-count" id="threadCount"></span>
    <button class="thread-play-all" id="threadPlayAll" title="Play all podcasts in thread"><svg viewBox="0 0 24 24" fill="currentColor" width="12" height="12" style="vertical-align:middle;margin-right:4px"><polygon points="6,3 20,12 6,21"/></svg>Play All</button>
    <span class="thread-close" id="threadClose">‚úï</span>
  </div>
</header>

<div class="quick-actions" id="quickActions">
  <button class="quick-btn" id="globalPlayAll" title="Play all podcasts"><svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16"><polygon points="6,3 20,12 6,21"/></svg></button>
  <button class="quick-btn" id="coffeeBtn">‚òï</button>
  <button class="quick-btn" id="diceBtn">üé≤</button>
</div>

<div class="timeline-container">
  <div class="timeline-line"></div>
  <div id="timeline"></div>
</div>

<!-- Map View -->
<div id="mapView">
  <div class="map-header">
    <div style="display:flex;align-items:baseline;">
      <h1>Time Slices</h1>
      <span class="subtitle" id="mapSubtitle"></span>
    </div>
    <div style="display:flex;align-items:center;gap:8px;">
      <button class="view-toggle active" id="mapBackBtn"></button>
      <button class="lang-btn" data-lang="en" data-map="1">EN</button>
      <button class="lang-btn" data-lang="it" data-map="1">IT</button>
    </div>
  </div>
  <div class="map-thread-banner" id="mapThreadBanner">
    <span>üßµ <span id="mapThreadLabel"></span>: <span class="thread-name" id="mapThreadName"></span></span>
    <span class="thread-close" id="mapThreadClose">‚úï</span>
  </div>
  <div id="map"></div>
</div>

<div class="map-time-control" id="mapTimeControl">
  <div class="time-slider-row">
    <button class="time-play-btn" id="timePlayBtn"><span class="play-icon"></span><span class="pause-icon"><span></span><span></span></span></button>
    <span class="time-year-display" id="timeYearDisplay">762</span>
    <input type="range" class="time-slider" id="timeSlider" min="700" max="2026" value="2026" step="1">
  </div>
</div>

<script>
let SLICES = [];
let activeThread = null;
let activePodcastAudio = null; // Track the currently playing podcast
let activePodcastYear = null;  // Year of the currently playing podcast (for cross-component sync)
let currentLang = (navigator.language || '').startsWith('it') ? 'it' : 'en';
let _slicesReadyResolve;
let slicesReady = new Promise(r => { _slicesReadyResolve = r; });

const DIM_ICONS = { art: 'üé®', lit: 'üìñ', phil: 'üß†', hist: '‚öîÔ∏è', conn: 'üîó' };

const I18N = {
  en: {
    subtitle: 'Cross-disciplinary history exploration',
    all: 'All', art: 'üé® Art', lit: 'üìñ Literature', phil: 'üß† Philosophy', hist: '‚öîÔ∏è History', conn: 'üîó Connections',
    thread: 'Thread', entries: 'entries', entry: 'entry',
    expandHint: 'Click to explore ‚Üí', sources: 'Sources',
    yearsLater: 'years later‚Ä¶',
    slicesFile: 'slices.json',
    viewMap: 'Map',
    viewTimeline: 'Timeline',
    viewInTimeline: 'View in timeline ‚Üí',
    freshEntry: "Today's fresh entry",
    randomSlice: 'Random slice',
    listenPodcast: 'Listen to podcast',
  },
  it: {
    subtitle: 'Esplorazione interdisciplinare della storia',
    all: 'Tutti', art: 'üé® Arte', lit: 'üìñ Letteratura', phil: 'üß† Filosofia', hist: '‚öîÔ∏è Storia', conn: 'üîó Connessioni',
    thread: 'Filo', entries: 'voci', entry: 'voce',
    expandHint: 'Clicca per esplorare ‚Üí', sources: 'Fonti',
    yearsLater: 'anni dopo‚Ä¶',
    slicesFile: 'slices.it.json',
    viewMap: 'Mappa',
    viewTimeline: 'Cronologia',
    viewInTimeline: 'Vedi nella cronologia ‚Üí',
    freshEntry: 'Voce fresca di oggi',
    randomSlice: 'Voce casuale',
    listenPodcast: 'Ascolta il podcast',
  }
};

function t(key) { return I18N[currentLang][key] || I18N.en[key] || key; }
function formatYear(y) {
  const n = parseInt(y);
  if (n < 0) return currentLang === 'it' ? `${Math.abs(n)} a.C.` : `${Math.abs(n)} BCE`;
  return String(y);
}
const THREAD_LABELS = {
  en: {
    'translation-movement': 'Translation as Power',
    'rationalism': 'Rationalism',
    'islamic-golden-age': 'Islamic Golden Age',
    'cosmopolitanism': 'Cosmopolitanism',
    'geometry-as-ideology': 'Geometry as Ideology',
    'renaissance-humanism': 'Renaissance Humanism',
    'neoplatonism': 'Neoplatonism',
    'classical-revival': 'Classical Revival',
    'art-and-power': 'Art & Power',
    'christian-humanism': 'Christian Humanism',
    'post-impressionism': 'Post-Impressionism',
    'crisis-of-positivism': 'Crisis of Positivism',
    'modernity': 'Modernity',
    'death-of-god': 'Death of God',
    'expressionism': 'Expressionism',
    'symbolism': 'Symbolism',
    'modernism': 'Modernism',
    'fragmentation': 'Fragmentation',
    'logical-positivism': 'Logical Positivism',
    'existentialism': 'Existentialism',
    'totalitarianism': 'Totalitarianism',
    'memento-mori': 'Memento Mori',
    'nominalism': 'Nominalism',
    'vernacular-literature': 'Vernacular Literature',
    'baroque': 'Baroque',
    'westphalian-sovereignty': 'Westphalian Sovereignty',
    'dutch-golden-age': 'Dutch Golden Age',
    'enlightenment': 'Enlightenment',
    'stoicism': 'Stoicism',
    'imperial-architecture': 'Imperial Architecture',
    'biography': 'Biography',
    'byzantine-empire': 'Byzantine Empire',
    'christian-architecture': 'Christian Architecture',
    'liturgical-drama': 'Liturgical Drama',
    'scientific-revolution': 'Scientific Revolution',
    'empiricism': 'Empiricism',
    'mechanical-philosophy': 'Mechanical Philosophy',
    'courts-and-patronage': 'Courts & Patronage',
    'reformation': 'Reformation',
    'printing-revolution': 'Printing Revolution',
    'sola-scriptura': 'Sola Scriptura',
  },
  it: {
    'translation-movement': 'Traduzione come potere',
    'rationalism': 'Razionalismo',
    'islamic-golden-age': 'Et√† d\'oro islamica',
    'cosmopolitanism': 'Cosmopolitismo',
    'geometry-as-ideology': 'Geometria come ideologia',
    'renaissance-humanism': 'Umanesimo rinascimentale',
    'neoplatonism': 'Neoplatonismo',
    'classical-revival': 'Rinascita classica',
    'art-and-power': 'Arte e potere',
    'christian-humanism': 'Umanesimo cristiano',
    'post-impressionism': 'Post-impressionismo',
    'crisis-of-positivism': 'Crisi del positivismo',
    'modernity': 'Modernit√†',
    'death-of-god': 'Morte di Dio',
    'expressionism': 'Espressionismo',
    'symbolism': 'Simbolismo',
    'modernism': 'Modernismo',
    'fragmentation': 'Frammentazione',
    'logical-positivism': 'Positivismo logico',
    'existentialism': 'Esistenzialismo',
    'totalitarianism': 'Totalitarismo',
    'memento-mori': 'Memento Mori',
    'nominalism': 'Nominalismo',
    'vernacular-literature': 'Letteratura in volgare',
    'baroque': 'Barocco',
    'westphalian-sovereignty': 'Sovranit√† vestfaliana',
    'dutch-golden-age': 'Secolo d\'oro olandese',
    'enlightenment': 'Illuminismo',
    'stoicism': 'Stoicismo',
    'imperial-architecture': 'Architettura imperiale',
    'biography': 'Biografia',
    'byzantine-empire': 'Impero bizantino',
    'christian-architecture': 'Architettura cristiana',
    'liturgical-drama': 'Dramma liturgico',
    'scientific-revolution': 'Rivoluzione scientifica',
    'empiricism': 'Empirismo',
    'mechanical-philosophy': 'Filosofia meccanica',
    'courts-and-patronage': 'Corti e mecenatismo',
    'reformation': 'Riforma protestante',
    'printing-revolution': 'Rivoluzione della stampa',
    'sola-scriptura': 'Sola Scriptura',
  }
};

const MARKERS = [
  { year: -3000, label: { en: "First writing (Sumer)", it: "Prima scrittura (Sumeri)" } },
  { year: -776, label: { en: "First Olympics", it: "Prime Olimpiadi" } },
  { year: -509, label: { en: "Roman Republic founded", it: "Fondazione della Repubblica Romana" } },
  { year: -323, label: { en: "Death of Alexander the Great", it: "Morte di Alessandro Magno" } },
  { year: 0, label: { en: "Year Zero", it: "Anno Zero" } },
  { year: 476, label: { en: "Fall of Western Rome", it: "Caduta dell'Impero Romano d'Occidente" } },
  { year: 622, label: { en: "Hijra ‚Äî birth of Islam", it: "Egira ‚Äî nascita dell'Islam" } },
  { year: 800, label: { en: "Charlemagne crowned Emperor", it: "Carlo Magno incoronato Imperatore" } },
  { year: 1066, label: { en: "Norman Conquest", it: "Conquista normanna" } },
  { year: 1215, label: { en: "Magna Carta", it: "Magna Carta" } },
  { year: 1347, label: { en: "Black Death arrives in Europe", it: "La Peste Nera arriva in Europa" } },
  { year: 1453, label: { en: "Fall of Constantinople", it: "Caduta di Costantinopoli" } },
  { year: 1492, label: { en: "Columbus reaches the Americas", it: "Colombo raggiunge le Americhe" } },
  { year: 1517, label: { en: "Luther's 95 Theses", it: "Le 95 tesi di Lutero" } },
  { year: 1648, label: { en: "Peace of Westphalia", it: "Pace di Vestfalia" } },
  { year: 1664, label: { en: "Halfway to 1784", it: "A met√† strada verso il 1784" } },
  { year: 1776, label: { en: "American Independence", it: "Indipendenza americana" } },
  { year: 1789, label: { en: "French Revolution", it: "Rivoluzione francese" } },
  { year: 1815, label: { en: "Waterloo", it: "Waterloo" } },
  { year: 1914, label: { en: "World War I begins", it: "Inizio della Prima Guerra Mondiale" } },
  { year: 1945, label: { en: "World War II ends", it: "Fine della Seconda Guerra Mondiale" } },
  { year: 1969, label: { en: "Moon landing", it: "Sbarco sulla Luna" } },
  { year: 1989, label: { en: "Fall of the Berlin Wall", it: "Caduta del Muro di Berlino" } },
];

const timeline = document.getElementById('timeline');

function formatThreadId(id) {
  const labels = THREAD_LABELS[currentLang] || THREAD_LABELS.en;
  return labels[id] || id.split('-').map(w => w[0].toUpperCase() + w.slice(1)).join(' ');
}

function renderSlice(slice, isFresh = false) {
  const dims = Object.entries(slice.dimensions).map(([key, dim]) => {
    const funFact = dim.funFact ? `<div class="fun-fact">${dim.funFact}</div>` : '';
    return `
      <div class="dimension" data-dim="${key}">
        <div class="dim-header">
          <span class="dim-icon">${DIM_ICONS[key]}</span>
          <span class="dim-label-${key}">${dim.label}</span>
        </div>
        <div class="dim-content">${dim.content}${funFact}</div>
      </div>
    `;
  }).join('');

  const threads = (slice.threads || []).map(t =>
    `<span class="thread-tag" data-thread="${t}">${formatThreadId(t)}</span>`
  ).join('');

  const sources = (slice.sources || []).map(s =>
    `<a href="${s.url}" target="_blank" rel="noopener">${s.title}</a>`
  ).join('');
  const sourcesHtml = sources ? `
    <details class="card-sources" onclick="event.stopPropagation()">
      <summary>${t('sources')}</summary>
      ${sources}
    </details>` : '';

  const imageInlineHtml = slice.image ? `
    <img class="card-image-inline" data-src="${slice.image.url}" alt="${slice.image.caption}">
    <div class="card-image-caption-inline">${slice.image.caption}</div>` : '';

  const floatingImageHtml = slice.image ? `
    <div class="floating-image">
      <img data-src="${slice.image.url}" alt="${slice.image.caption}">
      <div class="floating-caption">${slice.image.caption}</div>
      ${slice.image.attribution ? `<div class="floating-attribution">${slice.image.attribution}</div>` : ''}
    </div>` : '';

  const mapLink = slice.location ? `<span class="card-map-link" data-year="${slice.year}" title="${slice.location.place}">üìç</span>` : '';

  const el = document.createElement('div');
  el.className = 'entry';
  el.id = `entry-${slice.id}`;
  el.dataset.year = slice.year;
  el.dataset.threads = JSON.stringify(slice.threads || []);
  const freshBadgeHtml = isFresh ? '<div class="fresh-badge">‚òï</div>' : '';
  const hasPodcast = slice.podcast && typeof slice.podcast === 'object' && slice.podcast.url;
  const podcastBtnHtml = hasPodcast ? `<button class="podcast-btn" title="${t('listenPodcast')}" aria-label="${t('listenPodcast')}"><svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18"><path d="M12 3a9 9 0 0 0-9 9v7c0 1.1.9 2 2 2h1c1.1 0 2-.9 2-2v-3c0-1.1-.9-2-2-2H5v-2a7 7 0 0 1 14 0v2h-1c-1.1 0-2 .9-2 2v3c0 1.1.9 2 2 2h1c1.1 0 2-.9 2-2v-7a9 9 0 0 0-9-9z"/></svg></button>` : '';

  el.innerHTML = `
    ${floatingImageHtml}
    <div class="card">
      ${freshBadgeHtml}
      ${podcastBtnHtml}
      ${imageInlineHtml}
      <div class="card-body">
        <div class="card-year">${formatYear(slice.year)}${mapLink}</div>
        <div class="card-title">${slice.title}</div>
        <div class="card-teaser">${slice.teaser}</div>
        <div class="card-threads">${threads}</div>
        <div class="expand-hint">${t('expandHint')}</div>
        <div class="card-details">
          ${dims}
          ${sourcesHtml}
        </div>
      </div>
    </div>
  `;

  // Expand/collapse
  el.addEventListener('click', (e) => {
    if (e.target.closest('.thread-tag') || e.target.closest('.card-sources') || e.target.closest('.card-map-link') || e.target.closest('.podcast-btn') || e.target.closest('.podcast-player')) return;
    const details = el.querySelector('.card-details');
    if (el.classList.contains('expanded')) {
      // Stop & remove podcast player when closing card
      if (activePodcastYear === el.dataset.year) {
        stopAllPodcasts();
      }
      // Always remove player bar from collapsing card
      const playerBar = el.querySelector('.podcast-player');
      if (playerBar) playerBar.remove();
      details.style.maxHeight = details.scrollHeight + 'px';
      requestAnimationFrame(() => { details.style.maxHeight = '0'; });
      el.classList.remove('expanded');
      // Redraw thread lines after collapse animation
      if (activeThread) {
        setTimeout(() => redrawThreadLines(), 450);
      }
    } else {
      el.classList.add('expanded');
      details.style.maxHeight = details.scrollHeight + 'px';
      details.addEventListener('transitionend', function handler() {
        if (el.classList.contains('expanded')) {
          details.style.maxHeight = 'none';
          // Redraw thread lines after expand animation
          if (activeThread) {
            redrawThreadLines();
          }
        }
        details.removeEventListener('transitionend', handler);
      });
      // Eagerly load floating image
      const floatImg = el.querySelector('.floating-image img[data-src]');
      if (floatImg && !floatImg.src) {
        floatImg.src = floatImg.dataset.src;
      }
      // Auto-show podcast player bar on expand (don't stop other audio)
      if (hasPodcast && !el.querySelector('.podcast-player')) {
        showPodcastPlayer(el, slice.podcast.url, slice.podcast.duration, { autoStop: false });
      }
    }
  });

  // Thread tag clicks
  el.querySelectorAll('.thread-tag').forEach(tag => {
    tag.addEventListener('click', (e) => {
      e.stopPropagation();
      const thread = tag.dataset.thread;
      if (activeThread === thread) {
        clearThread();
      } else {
        // Pass the entry element as scroll anchor so we stay put when switching
        activateThread(thread, el);
      }
    });
  });

  // Map pin link
  const mapLinkEl = el.querySelector('.card-map-link');
  if (mapLinkEl) {
    mapLinkEl.addEventListener('click', (e) => {
      e.stopPropagation();
      flyToEntry(mapLinkEl.dataset.year);
    });
  }

  // Podcast player
  const podcastBtn = el.querySelector('.podcast-btn');
  if (podcastBtn && hasPodcast) {
    podcastBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      togglePodcastPlayer(el, slice.podcast.url, slice.podcast.duration);
    });
  }

  return el;
}

function renderMarker(marker) {
  const el = document.createElement('div');
  el.className = 'marker';
  const yearStr = formatYear(marker.year);
  const labelText = typeof marker.label === 'object' ? (marker.label[currentLang] || marker.label.en) : marker.label;
  el.innerHTML = `
    <div class="marker-line"></div>
    <span class="marker-label">${yearStr} ‚Äî ${labelText}</span>
  `;
  return el;
}

// Thread logic
// Narrative connectors between thread entries
const THREAD_NARRATIVES = {
  en: {
    'death-of-god': {
      '1347‚Üí1648': 'The plague made God\'s order illegible; three centuries later, the wars of religion made it lethal. Westphalia\'s solution was radical: stop asking which God is right and let sovereignty decide. Ockham\'s nominalism planted the seed; Descartes\' cogito grew from the same doubt.',
      '1347‚Üí1889': 'The Black Death made God\'s order illegible five centuries before Nietzsche declared Him dead. Ockham\'s razor stripped away metaphysical certainties; by 1889, Nietzsche finished the job ‚Äî and collapsed under the weight of it.',
      '1347‚Üí1922': 'From plague to wasteland: the crisis of divine authority that began when prayers couldn\'t stop the Black Death reaches its modernist conclusion in Eliot\'s fragments and Wittgenstein\'s silence about what cannot be said.',
      '1648‚Üí1889': 'Westphalia removed God from international politics; Nietzsche removed Him from philosophy. Between them, two and a half centuries of Enlightenment slowly replaced divine authority with human reason ‚Äî until reason itself began to crack.',
      '1648‚Üí1922': 'The Peace of Westphalia made religion a private matter of state; by 1922, God had become a private matter of the individual ‚Äî or nobody\'s matter at all. Eliot\'s wasteland is what Westphalia\'s secular order looks like after the trenches.',
      '1889‚Üí1922': 'Nietzsche declared God dead in 1882. By 1922, the void he predicted had swallowed certainty itself ‚Äî Eliot\'s <em>Waste Land</em> mapped the wreckage, while logical positivism tried to rebuild meaning from scratch.',
    },
    'rationalism': {
      '-431‚Üí125': 'Anaxagoras argued that a rational principle (<em>Nous</em>) governed the cosmos rather than the caprice of gods. Five centuries later, the Stoics ‚Äî working from this same Greek rationalist tradition, filtered through Aristotle and the early Stoa ‚Äî taught that the universe was structured by <em>logos</em>, a rational order accessible to human reason. Epictetus, teaching in Nicopolis around 125 CE, inherited this lineage directly: Stoicism emerged from the Athenian philosophical milieu that Anaxagoras helped create, passed through Zeno of Citium (who studied at Plato\'s Academy) and Chrysippus. The Pantheon\'s mathematical perfection ‚Äî its dome a geometrically exact hemisphere ‚Äî is this rationalist conviction expressed in built form.',
      '-431‚Üí762': 'Anaxagoras\'s <em>Nous</em> ‚Äî a cosmic Mind that organises matter through reason ‚Äî is one of the Greek ideas that Baghdad\'s translators preserved. The Mu\'tazila inherited a twelve-century-old argument: that rational inquiry, not tradition, reveals truth. The texts Hunayn ibn Ishaq translated into Arabic were produced in the intellectual culture Anaxagoras helped create. The link is real but indirect ‚Äî mediated through Aristotle and the Neoplatonists, not through Anaxagoras directly.',
      '-431‚Üí1648': 'Anaxagoras declared the sun a mass of hot metal and was tried for impiety; Descartes published his cosmology and prudently moved to the Netherlands. Twenty-one centuries apart, both insisted that reason could explain the natural world without recourse to gods ‚Äî and both understood the danger. The Cartesian tradition inherited Greek natural philosophy through the Arabic-Latin translation chain that begins with the very texts Periclean Athens produced.',
      '-431‚Üí1784': 'When Kant wrote <em>sapere aude</em> ‚Äî dare to know ‚Äî he was echoing, through many intermediaries, the stance Anaxagoras took when he explained the sun as matter rather than divinity. Kant studied the Aristotelian tradition directly, and Aristotle studied at Plato\'s Academy, founded one generation after Anaxagoras\'s Athenian period. The lineage is traceable through documented teacher-student chains, though Kant himself looked to Descartes and Leibniz, not to the Pre-Socratics.',
      '125‚Üí762': 'The Stoic rationalism that Epictetus taught ‚Äî the universe as an intelligible order governed by <em>logos</em> ‚Äî was transmitted alongside Aristotelian and Neoplatonic texts through the late antique world. When the Abbasid translators in Baghdad rendered Greek philosophy into Arabic, the rational cosmology of the Stoics was part of the intellectual atmosphere they inherited, though they translated Aristotle and Plato more systematically. The Mu\'tazila\'s insistence on rational theology drew from the same deep well of Greek rationalism that Epictetus exemplified, mediated through the Syriac-speaking Christian scholars (Nestorians, Jacobites) who preserved Greek philosophical texts in the centuries between Rome\'s decline and Baghdad\'s rise.',
      '762‚Üí1648': 'The Mu\'tazila argued that reason could determine religious truth; eight centuries later, Descartes used reason to bypass religious truth entirely. Baghdad\'s translation movement preserved the Greek rationalism that Descartes inherited ‚Äî the cogito\'s ancestors spoke Arabic.',
      '762‚Üí1784': 'The transmission chain is real but long: Baghdad\'s translators (Hunayn ibn Ishaq and others) rendered Aristotle and Plato into Arabic; these passed through al-Andalus to Latin Europe via translators like Gerard of Cremona in Toledo (12th c.). Kant studied Aristotelian logic and engaged directly with the rationalist tradition that Descartes and Leibniz had built on these recovered texts. But Kant never cited the Mu\'tazila ‚Äî the parallel between their rational theology and his Enlightenment project is a historiographical observation, not a documented influence.',
      '1648‚Üí1784': 'Kant explicitly engaged with Descartes\' rationalism: the <em>Critique of Pure Reason</em> (1781) directly addresses and transforms the Cartesian project of grounding knowledge in reason alone. The link is documented and acknowledged. The political parallel ‚Äî Westphalia\'s principle of state sovereignty removed confessional allegiance as grounds for war; Kant\'s essay demanded that individuals exercise reason without deference to authority ‚Äî reflects a broader trajectory from religious to secular foundations of legitimacy, though the two events are not causally connected.',
    },
    'modernity': {
      '1648‚Üí1889': 'Westphalia invented the modern state; the Eiffel Tower celebrated what the modern state could build. Between them: the Enlightenment, the Industrial Revolution, the nation-state. The 1889 World\'s Fair was Westphalian sovereignty made festive ‚Äî competing nations showing off in iron and glass.',
    },
    'fragmentation': {
      '1347‚Üí1922': 'The plague shattered medieval unity ‚Äî Church authority, feudal order, demographic stability, all broken at once. Six centuries later, modernism made fragmentation into an art form, shattering narrative, painting, and language with the same democratic indifference.',
    },
    'classical-revival': {
      '-431‚Üí125': 'Rome absorbed Greek art not as imitation but as imperial inheritance. The Parthenon expressed democratic Athens\'s civic ideals through mathematical proportion; Hadrian\'s Pantheon translated the same mathematical ambition ‚Äî dome diameter equalling height, a perfect hemisphere ‚Äî into the language of imperial universality. The transmission was direct: Roman architects studied Greek buildings firsthand, and Hadrian\'s Villa at Tivoli explicitly recreated Greek structures (the Stoa Poikile, the Vale of Tempe). Meanwhile, Plutarch\'s <em>Parallel Lives</em> provided the intellectual framework ‚Äî Greek and Roman exemplars compared side by side, the classical tradition understood as a living inheritance rather than a lost age.',
      '-431‚Üí1504': 'This is the origin. When Florentine humanists spoke of recovering classical antiquity, they meant ‚Äî ultimately ‚Äî the Periclean achievement: the synthesis of mathematical proportion, idealised human form, and civic purpose that Phidias embodied. The recovery was indirect, filtered through Roman copies and Byzantine manuscripts, but the Parthenon\'s sculptural programme set the standard that Michelangelo and Leonardo measured themselves against. Ghiberti\'s <em>Commentarii</em> explicitly traced artistic lineage back to Phidias.',
      '-431‚Üí1784': 'Winckelmann\'s <em>Thoughts on the Imitation of Greek Works</em> (1755) ‚Äî the founding text of Neoclassicism ‚Äî argued that Greek art achieved \"noble simplicity and quiet grandeur\" because Greek society achieved freedom. He was describing, and idealising, Periclean Athens. David\'s generation absorbed this vision directly: the republican virtues they painted in classical dress were imagined as Athenian and Spartan virtues, read through Plutarch but aspiring to the visual language of the Parthenon.',
      '125‚Üí1504': 'The Pantheon survived the fall of Rome because Pope Boniface IV consecrated it as a church in 609. Florentine architects studied it obsessively: Brunelleschi travelled to Rome to measure its dome before designing his own for the Florence Cathedral (1420‚Äì36), which finally surpassed its 43.3-metre span. The Roman concrete techniques had been lost, but the ambition ‚Äî and the physical building ‚Äî endured. Renaissance humanism revived not just Greek ideals but their Roman institutional expression: the libraries, the patronage networks, the monumental architecture that Hadrian exemplified.',
      '125‚Üí1784': 'Neoclassicism drew more heavily on Rome than Greece ‚Äî because so much more Roman architecture survived. The Pantheon was the most studied building in Europe by the 18th century; its portico became the template for institutions from the British Museum to the Panth√©on in Paris. When Winckelmann idealised Greek art, he was largely looking at Roman copies. David\'s classical vocabulary was Roman classical vocabulary ‚Äî togas, fasces, Republican virtue ‚Äî mediated through what imperial Rome had preserved, built, and transmitted.',
      '1504‚Üí1784': 'David won the Prix de Rome in 1774 and spent five years in Italy studying Raphael, Michelangelo, and Roman antiquities firsthand. The lineage is direct and documented: Renaissance artists recovered classical forms; David inherited them through the Acad√©mie royale\'s curriculum, which made Rome pilgrimage mandatory. But where Renaissance Florence used antiquity as a language of idealised beauty, David\'s Neoclassicism ‚Äî shaped by Winckelmann\'s writings on Greek art as moral exemplar ‚Äî turned the same classical vocabulary toward republican virtue and political duty.',
    },
    'art-and-power': {
      '-431‚Üí1504': 'Pericles diverted the Delian League treasury to fund the Parthenon; Lorenzo de\' Medici diverted bank profits to fund Florence\'s artistic programme. In both cases, economic dominance was transmuted into cultural authority, and the patrons\' political opponents attacked the expenditure as illegitimate. Phidias was charged with embezzlement; the Medici were exiled in 1494. The pattern ‚Äî power expressed through beauty, challenged through accounting ‚Äî repeats across two millennia.',
      '-431‚Üí1784': 'The Parthenon was civic art funded by imperial tribute, legitimising Athenian democracy through aesthetic splendour. David\'s <em>Oath of the Horatii</em>, commissioned by the French Crown, was subverted by its creator into a republican manifesto. Both demonstrate art\'s capacity to serve and undermine power simultaneously ‚Äî but where Athens\' democratic assembly voted the funds openly, David\'s patron unwittingly funded his own ideological opposition.',
      '1504‚Üí1784': 'The Medici commissioned art to project civic power and cultural prestige ‚Äî Michelangelo\'s <em>David</em> was a public statement by the Florentine Republic. David\'s <em>Oath</em> was commissioned by the Crown (via d\'Angiviller) as moralising history painting, but the artist subverted the brief: audiences read it as a call to republican sacrifice against monarchy. The shift from Renaissance patron-as-author to Enlightenment artist-as-ideologue is visible in this single commission ‚Äî the state paid for its own critique.',
    },
    'geometry-as-ideology': {
      '-431‚Üí762': 'The Parthenon\'s optical refinements ‚Äî entasis, stylobate curvature, column inclination ‚Äî express a Greek conviction that mathematical order underlies reality, and that human craft can perfect what nature approximates. Thirteen centuries later, al-Mansur\'s Round City of Baghdad embodied the same conviction in urban form: a perfect circle with geometry dictating theology. Both are built environments that make philosophical claims about the cosmos through proportion, though the Islamic builders drew on Persian and Mesopotamian traditions as much as Greek ones.',
    },
    'cosmopolitanism': {
      '-431‚Üí762': 'Periclean Athens drew thinkers from across the Greek world ‚Äî Anaxagoras from Clazomenae in Ionia, Protagoras from Abdera in Thrace, Hippodamus from Miletus ‚Äî and synthesised their ideas into something new. Al-Mansur\'s Baghdad replicated this pattern at larger scale: scholars from Syria, Persia, India, and Central Asia converged on a single city designed to attract and organise knowledge. Both cities understood that intellectual power requires cosmopolitan intake ‚Äî and both enforced political hierarchies that contradicted their intellectual openness.',
    },
    'renaissance-humanism': {
      '1504‚Üí1517': 'Erasmus was the hinge. His 1516 Greek New Testament gave Luther the weapon (<em>metanoeite</em> means "repent," not "do penance") and his <em>Praise of Folly</em> mocked the same Church abuses Luther attacked. Renaissance scholarship made the Reformation possible ‚Äî then recoiled from what it unleashed.',
    },
    'christian-humanism': {
      '1504‚Üí1517': 'More and Erasmus wanted reform through education and satire; Luther wanted it through doctrine and confrontation. The Christian humanist programme ‚Äî return to sources, purify the Church from within ‚Äî was hijacked by someone willing to burn the house down.',
    },
  },
  it: {
    'death-of-god': {
      '1347‚Üí1648': 'La peste rese illeggibile l\'ordine di Dio; tre secoli dopo, le guerre di religione lo resero letale. La soluzione di Vestfalia fu radicale: smettere di chiedersi quale Dio avesse ragione e lasciare decidere alla sovranit√†. Il nominalismo di Ockham piant√≤ il seme; il cogito di Cartesio crebbe dallo stesso dubbio.',
      '1347‚Üí1889': 'La Peste Nera rese illeggibile l\'ordine divino cinque secoli prima che Nietzsche ne dichiarasse la morte. Il rasoio di Ockham aveva gi√† spogliato le certezze metafisiche; nel 1889, Nietzsche complet√≤ l\'opera ‚Äî e croll√≤ sotto il suo peso.',
      '1347‚Üí1922': 'Dalla peste alla terra desolata: la crisi dell\'autorit√† divina, iniziata quando le preghiere non fermarono la Morte Nera, raggiunge la sua conclusione modernista nei frammenti di Eliot e nel silenzio di Wittgenstein su ci√≤ che non si pu√≤ dire.',
      '1648‚Üí1889': 'Vestfalia rimosse Dio dalla politica internazionale; Nietzsche lo rimosse dalla filosofia. Fra i due, due secoli e mezzo di Illuminismo sostituirono lentamente l\'autorit√† divina con la ragione umana ‚Äî finch√© la ragione stessa cominci√≤ a incrinarsi.',
      '1648‚Üí1922': 'La Pace di Vestfalia fece della religione un affare privato degli Stati; nel 1922, Dio era diventato un affare privato dell\'individuo ‚Äî o di nessuno. La terra desolata di Eliot √® l\'aspetto dell\'ordine secolare vestfaliano dopo le trincee.',
      '1889‚Üí1922': 'Nietzsche dichiar√≤ morto Dio nel 1882. Entro il 1922, il vuoto che aveva predetto aveva inghiottito la certezza stessa ‚Äî <em>La terra desolata</em> di Eliot ne mappava le macerie, mentre il positivismo logico tentava di ricostruire il significato da zero.',
    },
    'rationalism': {
      '-431‚Üí125': 'Anassagora sosteneva che un principio razionale (<em>Nous</em>) governasse il cosmo piuttosto che il capriccio degli dei. Cinque secoli dopo, gli Stoici ‚Äî partendo dalla stessa tradizione razionalista greca, filtrata attraverso Aristotele e la prima Stoa ‚Äî insegnavano che l\'universo era strutturato dal <em>logos</em>, un ordine razionale accessibile alla ragione umana. Epitteto, che insegnava a Nicopoli intorno al 125 d.C., ereditava direttamente questa genealogia: lo stoicismo emerse dall\'ambiente filosofico ateniese che Anassagora contribu√¨ a creare, passando attraverso Zenone di Cizio (che studi√≤ all\'Accademia di Platone) e Crisippo. La perfezione matematica del Pantheon ‚Äî la cupola come emisfero geometricamente esatto ‚Äî √® questa convinzione razionalista espressa in forma costruita.',
      '-431‚Üí762': 'Il <em>Nous</em> di Anassagora ‚Äî una Mente cosmica che organizza la materia attraverso la ragione ‚Äî √® una delle idee greche che i traduttori di Baghdad preservarono. I Mu\'tazila ereditarono un argomento vecchio di dodici secoli: che l\'indagine razionale, non la tradizione, rivela la verit√†. I testi che Hunayn ibn Ishaq tradusse in arabo furono prodotti nella cultura intellettuale che Anassagora contribu√¨ a creare. Il legame √® reale ma indiretto ‚Äî mediato attraverso Aristotele e i neoplatonici, non attraverso Anassagora direttamente.',
      '-431‚Üí1648': 'Anassagora dichiar√≤ il sole una massa di metallo rovente e fu processato per empiet√†; Cartesio pubblic√≤ la sua cosmologia e prudentemente si trasfer√¨ nei Paesi Bassi. Ventuno secoli di distanza, entrambi insistettero che la ragione potesse spiegare il mondo naturale senza ricorso agli dei ‚Äî ed entrambi ne compresero il pericolo. La tradizione cartesiana eredit√≤ la filosofia naturale greca attraverso la catena di traduzione arabo-latina che inizia con i testi stessi prodotti dall\'Atene di Pericle.',
      '-431‚Üí1784': 'Quando Kant scrisse <em>sapere aude</em> ‚Äî osa sapere ‚Äî echeggiava, attraverso molti intermediari, la posizione che Anassagora assunse quando spieg√≤ il sole come materia piuttosto che divinit√†. Kant studi√≤ la tradizione aristotelica direttamente, e Aristotele studi√≤ all\'Accademia di Platone, fondata una generazione dopo il periodo ateniese di Anassagora. La genealogia √® tracciabile attraverso catene documentate maestro-allievo, sebbene Kant stesso guardasse a Cartesio e Leibniz, non ai Presocratici.',
      '125‚Üí762': 'Il razionalismo stoico insegnato da Epitteto ‚Äî l\'universo come ordine intelligibile governato dal <em>logos</em> ‚Äî fu trasmesso insieme ai testi aristotelici e neoplatonici attraverso il mondo tardoantico. Quando i traduttori abbasidi a Baghdad resero la filosofia greca in arabo, la cosmologia razionale degli Stoici faceva parte dell\'atmosfera intellettuale che avevano ereditato, sebbene traducessero Aristotele e Platone pi√π sistematicamente. L\'insistenza dei Mu\'tazila sulla teologia razionale attingeva allo stesso pozzo profondo del razionalismo greco che Epitteto esemplificava, mediato attraverso gli studiosi cristiani di lingua siriaca (Nestoriani, Giacobiti) che preservarono i testi filosofici greci nei secoli tra il declino di Roma e l\'ascesa di Baghdad.',
      '762‚Üí1648': 'I Mu\'tazila sostenevano che la ragione potesse determinare la verit√† religiosa; otto secoli dopo, Cartesio us√≤ la ragione per aggirare del tutto la verit√† religiosa. Il movimento di traduzione di Baghdad preserv√≤ il razionalismo greco che Cartesio eredit√≤ ‚Äî gli antenati del cogito parlavano arabo.',
      '762‚Üí1784': 'La catena di trasmissione √® reale ma lunga: i traduttori di Baghdad (Hunayn ibn Ishaq e altri) resero Aristotele e Platone in arabo; questi passarono attraverso al-Andalus all\'Europa latina tramite traduttori come Gerardo da Cremona a Toledo (XII sec.). Kant studi√≤ la logica aristotelica e si confront√≤ direttamente con la tradizione razionalista che Cartesio e Leibniz avevano costruito su quei testi recuperati. Ma Kant non cit√≤ mai i Mu\'tazila ‚Äî il parallelo tra la loro teologia razionale e il suo progetto illuminista √® un\'osservazione storiografica, non un\'influenza documentata.',
      '1648‚Üí1784': 'Kant si confront√≤ esplicitamente con il razionalismo cartesiano: la <em>Critica della ragion pura</em> (1781) affronta e trasforma direttamente il progetto cartesiano di fondare la conoscenza nella sola ragione. Il legame √® documentato e riconosciuto. Il parallelo politico ‚Äî il principio di sovranit√† statale di Vestfalia rimosse l\'appartenenza confessionale come casus belli; il saggio di Kant esigeva che gli individui esercitassero la ragione senza deferenza all\'autorit√† ‚Äî riflette una traiettoria pi√π ampia dalle fondamenta religiose a quelle laiche della legittimit√†, anche se i due eventi non sono causalmente connessi.',
    },
    'modernity': {
      '1648‚Üí1889': 'Vestfalia invent√≤ lo Stato moderno; la Tour Eiffel celebr√≤ ci√≤ che lo Stato moderno sapeva costruire. Fra i due: l\'Illuminismo, la Rivoluzione industriale, lo Stato-nazione. L\'Esposizione Universale del 1889 fu la sovranit√† vestfaliana in festa ‚Äî nazioni in competizione che si mettevano in mostra in ferro e vetro.',
    },
    'fragmentation': {
      '1347‚Üí1922': 'La peste frantum√≤ l\'unit√† medievale ‚Äî autorit√† della Chiesa, ordine feudale, stabilit√† demografica, tutto spezzato in una volta. Sei secoli dopo, il modernismo fece della frammentazione una forma d\'arte, frantumando narrazione, pittura e linguaggio con la stessa democratica indifferenza.',
    },
    'classical-revival': {
      '-431‚Üí125': 'Roma assorb√¨ l\'arte greca non come imitazione ma come eredit√† imperiale. Il Partenone esprimeva gli ideali civici dell\'Atene democratica attraverso la proporzione matematica; il Pantheon di Adriano tradusse la stessa ambizione matematica ‚Äî diametro della cupola pari all\'altezza, un emisfero perfetto ‚Äî nel linguaggio dell\'universalit√† imperiale. La trasmissione fu diretta: gli architetti romani studiavano gli edifici greci dal vero, e la Villa Adriana a Tivoli ricreava esplicitamente strutture greche (la Sto√† Pecile, la Valle di Tempe). Intanto, le <em>Vite parallele</em> di Plutarco fornivano la cornice intellettuale ‚Äî esemplari greci e romani a confronto, la tradizione classica intesa come eredit√† viva piuttosto che come epoca perduta.',
      '-431‚Üí1504': 'Questa √® l\'origine. Quando gli umanisti fiorentini parlavano di recuperare l\'antichit√† classica, intendevano ‚Äî in ultima istanza ‚Äî la conquista periclea: la sintesi di proporzione matematica, forma umana idealizzata e scopo civico che Fidia incarnava. Il recupero fu indiretto, filtrato attraverso copie romane e manoscritti bizantini, ma il programma scultoreo del Partenone fiss√≤ lo standard rispetto al quale Michelangelo e Leonardo si misuravano. I <em>Commentarii</em> di Ghiberti tracciavano esplicitamente la genealogia artistica fino a Fidia.',
      '-431‚Üí1784': 'Le <em>Considerazioni sull\'imitazione delle opere greche</em> di Winckelmann (1755) ‚Äî il testo fondante del Neoclassicismo ‚Äî sostenevano che l\'arte greca raggiungesse una ¬´nobile semplicit√† e quieta grandezza¬ª perch√© la societ√† greca aveva raggiunto la libert√†. Descriveva, idealizzandola, l\'Atene di Pericle. La generazione di David assorb√¨ questa visione direttamente: le virt√π repubblicane che dipingevano in vesti classiche erano immaginate come virt√π ateniesi e spartane, lette attraverso Plutarco ma aspirando al linguaggio visivo del Partenone.',
      '125‚Üí1504': 'Il Pantheon sopravvisse alla caduta di Roma perch√© papa Bonifacio IV lo consacr√≤ come chiesa nel 609. Gli architetti fiorentini lo studiarono ossessivamente: Brunelleschi si rec√≤ a Roma per misurarne la cupola prima di progettare la propria per la Cattedrale di Firenze (1420‚Äì36), che infine ne super√≤ la luce di 43,3 metri. Le tecniche costruttive romane in calcestruzzo erano andate perdute, ma l\'ambizione ‚Äî e l\'edificio fisico ‚Äî resistettero. L\'umanesimo rinascimentale riprese non solo gli ideali greci ma la loro espressione istituzionale romana: le biblioteche, le reti di mecenatismo, l\'architettura monumentale che Adriano aveva esemplificato.',
      '125‚Üí1784': 'Il Neoclassicismo attinse a Roma pi√π che alla Grecia ‚Äî perch√© molto pi√π dell\'architettura romana era sopravvissuto. Il Pantheon era l\'edificio pi√π studiato d\'Europa nel XVIII secolo; il suo portico divenne il modello per istituzioni dal British Museum al Panth√©on di Parigi. Quando Winckelmann idealizzava l\'arte greca, guardava in gran parte copie romane. Il vocabolario classico di David era un vocabolario classico romano ‚Äî toghe, fasci, virt√π repubblicana ‚Äî mediato da ci√≤ che la Roma imperiale aveva preservato, costruito e trasmesso.',
      '1504‚Üí1784': 'David vinse il Prix de Rome nel 1774 e trascorse cinque anni in Italia studiando Raffaello, Michelangelo e le antichit√† romane dal vivo. La genealogia √® diretta e documentata: gli artisti rinascimentali recuperarono le forme classiche; David le eredit√≤ attraverso il curriculum dell\'Acad√©mie royale, che rendeva obbligatorio il pellegrinaggio a Roma. Ma dove la Firenze rinascimentale usava l\'antichit√† come linguaggio di bellezza idealizzata, il Neoclassicismo di David ‚Äî plasmato dagli scritti di Winckelmann sull\'arte greca come exemplum morale ‚Äî volse lo stesso vocabolario classico verso la virt√π repubblicana e il dovere politico.',
    },
    'art-and-power': {
      '-431‚Üí1504': 'Pericle dirott√≤ il tesoro della Lega di Delo per finanziare il Partenone; Lorenzo de\' Medici dirott√≤ i profitti bancari per finanziare il programma artistico di Firenze. In entrambi i casi, il dominio economico fu trasmutato in autorit√† culturale, e gli oppositori politici dei mecenati contestarono la spesa come illegittima. Fidia fu accusato di appropriazione indebita; i Medici furono esiliati nel 1494. Lo schema ‚Äî potere espresso attraverso la bellezza, contestato attraverso la contabilit√† ‚Äî si ripete lungo due millenni.',
      '-431‚Üí1784': 'Il Partenone era arte civica finanziata da tributi imperiali, che legittimava la democrazia ateniese attraverso lo splendore estetico. Il <em>Giuramento degli Orazi</em> di David, commissionato dalla Corona francese, fu sovvertito dal suo creatore in un manifesto repubblicano. Entrambi dimostrano la capacit√† dell\'arte di servire e minare il potere simultaneamente ‚Äî ma dove l\'assemblea democratica di Atene vot√≤ i fondi apertamente, il mecenate di David finanzi√≤ involontariamente la propria opposizione ideologica.',
      '1504‚Üí1784': 'I Medici commissionavano arte per proiettare potere civico e prestigio culturale ‚Äî il <em>David</em> di Michelangelo era una dichiarazione pubblica della Repubblica fiorentina. Il <em>Giuramento</em> di David fu commissionato dalla Corona (tramite d\'Angiviller) come pittura storica moralizzante, ma l\'artista sovvert√¨ l\'incarico: il pubblico lo lesse come un appello al sacrificio repubblicano contro la monarchia. Il passaggio dal mecenate-autore del Rinascimento all\'artista-ideologo dell\'Illuminismo √® visibile in questa singola commissione ‚Äî lo stato pag√≤ la propria critica.',
    },
    'geometry-as-ideology': {
      '-431‚Üí762': 'Le correzioni ottiche del Partenone ‚Äî entasi, curvatura dello stilobate, inclinazione delle colonne ‚Äî esprimono la convinzione greca che l\'ordine matematico sia il fondamento della realt√†, e che l\'arte umana possa perfezionare ci√≤ che la natura approssima. Tredici secoli dopo, la Citt√† Rotonda di al-Mansur a Baghdad incarnava la stessa convinzione in forma urbana: un cerchio perfetto con la geometria che detta la teologia. Entrambi sono ambienti costruiti che avanzano pretese filosofiche sul cosmo attraverso la proporzione, sebbene i costruttori islamici attingessero a tradizioni persiane e mesopotamiche tanto quanto a quelle greche.',
    },
    'cosmopolitanism': {
      '-431‚Üí762': 'L\'Atene di Pericle attraeva pensatori da tutto il mondo greco ‚Äî Anassagora da Clazomene in Ionia, Protagora da Abdera in Tracia, Ippodamo da Mileto ‚Äî e ne sintetizzava le idee in qualcosa di nuovo. La Baghdad di al-Mansur replic√≤ questo schema su scala maggiore: studiosi da Siria, Persia, India e Asia centrale convergevano su una singola citt√† progettata per attrarre e organizzare il sapere. Entrambe le citt√† compresero che il potere intellettuale richiede un apporto cosmopolita ‚Äî ed entrambe imposero gerarchie politiche che contraddicevano la loro apertura intellettuale.',
    },
    'renaissance-humanism': {
      '1504‚Üí1517': 'Erasmo fu la cerniera. Il suo Nuovo Testamento greco del 1516 diede a Lutero l\'arma (<em>metanoeite</em> significa "pentiti," non "fai penitenza") e il suo <em>Elogio della follia</em> derideva gli stessi abusi ecclesiastici che Lutero attacc√≤. L\'erudizione rinascimentale rese possibile la Riforma ‚Äî poi indietreggi√≤ di fronte a ci√≤ che aveva scatenato.',
    },
    'christian-humanism': {
      '1504‚Üí1517': 'More ed Erasmo volevano la riforma attraverso l\'educazione e la satira; Lutero la voleva attraverso la dottrina e lo scontro. Il programma dell\'umanesimo cristiano ‚Äî ritorno alle fonti, purificare la Chiesa dall\'interno ‚Äî fu dirottato da qualcuno disposto a dare fuoco alla casa.',
    },
  },
};

function getThreadNarrative(threadId, yearFrom, yearTo) {
  const key = `${yearFrom}‚Üí${yearTo}`;
  const langNarratives = THREAD_NARRATIVES[currentLang] || THREAD_NARRATIVES.en;
  const narratives = langNarratives[threadId];
  return narratives && narratives[key] ? narratives[key] : null;
}

// --- Podcast Player ---

function formatTime(seconds) {
  const m = Math.floor(seconds / 60);
  const s = Math.floor(seconds % 60);
  return `${m}:${s.toString().padStart(2, '0')}`;
}

const SVG_PLAY = '<svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16"><polygon points="6,3 20,12 6,21"/></svg>';
const SVG_PAUSE = '<svg viewBox="0 0 24 24" fill="currentColor" width="16" height="16"><rect x="5" y="3" width="4" height="18"/><rect x="15" y="3" width="4" height="18"/></svg>';
const SVG_HEADPHONES = '<svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18"><path d="M12 3a9 9 0 0 0-9 9v7c0 1.1.9 2 2 2h1c1.1 0 2-.9 2-2v-3c0-1.1-.9-2-2-2H5v-2a7 7 0 0 1 14 0v2h-1c-1.1 0-2 .9-2 2v3c0 1.1.9 2 2 2h1c1.1 0 2-.9 2-2v-7a9 9 0 0 0-9-9z"/></svg>';
const SVG_STOP = '<svg viewBox="0 0 24 24" fill="currentColor" width="18" height="18"><rect x="4" y="4" width="16" height="16" rx="2"/></svg>';
// Button-sized icons for play all buttons
const SVG_PLAY_BTN = '<svg viewBox="0 0 24 24" fill="currentColor" width="14" height="14" style="vertical-align:middle"><polygon points="6,3 20,12 6,21"/></svg>';
const SVG_STOP_BTN = '<svg viewBox="0 0 24 24" fill="currentColor" width="14" height="14" style="vertical-align:middle"><rect x="4" y="4" width="16" height="16" rx="2"/></svg>';

// --- Podcast sync helpers ---
function syncMapPopupAudio(year, isPlaying) {
  // Update any open map popup audio button for this year
  document.querySelectorAll(`.map-popup-audio[data-year="${year}"]`).forEach(btn => {
    if (isPlaying) {
      btn.classList.add('playing');
      btn.querySelector('.mpa-icon').innerHTML = SVG_PAUSE;
    } else {
      btn.classList.remove('playing');
      btn.querySelector('.mpa-icon').innerHTML = SVG_PLAY;
    }
  });
}

function stopAllPodcasts() {
  // Stop audio
  if (activePodcastAudio) {
    activePodcastAudio.pause();
    activePodcastAudio.src = '';
  }
  // Reset all timeline player bars to idle (don't remove ‚Äî card may still be expanded)
  document.querySelectorAll('.podcast-player').forEach(player => {
    const entry = player.closest('.entry');
    const btn = entry?.querySelector('.podcast-btn');
    if (btn) btn.innerHTML = SVG_HEADPHONES;
    const playBtn = player.querySelector('.pp-play');
    if (playBtn) playBtn.innerHTML = SVG_PLAY;
    const progressFill = player.querySelector('.pp-progress-fill');
    if (progressFill) progressFill.style.width = '0%';
    const currentTimeEl = player.querySelector('.pp-current');
    if (currentTimeEl) currentTimeEl.textContent = '0:00';
    const audio = player.querySelector('audio');
    if (audio) audio.src = '';
  });
  // Clean up map popup buttons
  document.querySelectorAll('.map-popup-audio.playing').forEach(b => {
    b.classList.remove('playing');
    const icon = b.querySelector('.mpa-icon');
    if (icon) icon.innerHTML = SVG_PLAY;
  });
  activePodcastAudio = null;
  activePodcastYear = null;
  // Update global play button state
  if (typeof updateGlobalPlayButton === 'function') updateGlobalPlayButton();
}

function showPodcastPlayer(entryEl, audioUrl, duration, { autoStop = true } = {}) {
  // Only creates the player ‚Äî never removes it. Returns the player element.
  const existing = entryEl.querySelector('.podcast-player');
  if (existing) return existing;

  // Stop any other playing podcast (skip during batch restore)
  if (autoStop) stopAllPodcasts();

  const btn = entryEl.querySelector('.podcast-btn');
  const year = entryEl.dataset.year;

  // Create player
  const player = document.createElement('div');
  player.className = 'podcast-player';
  player.innerHTML = `
    <audio preload="auto"></audio>
    <button class="pp-play" aria-label="Play">${SVG_PLAY}</button>
    <div class="pp-progress-wrap">
      <div class="pp-progress-bar"><div class="pp-progress-fill"></div></div>
      <div class="pp-time"><span class="pp-current">0:00</span> / <span class="pp-total">${formatTime(duration || 0)}</span></div>
    </div>
  `;

  // Insert after the card-teaser, before card-threads
  const cardBody = entryEl.querySelector('.card-body');
  const teaser = entryEl.querySelector('.card-teaser');
  if (teaser && teaser.nextSibling) {
    cardBody.insertBefore(player, teaser.nextSibling);
  } else {
    cardBody.appendChild(player);
  }

  const audio = player.querySelector('audio');
  const playBtn = player.querySelector('.pp-play');
  const progressFill = player.querySelector('.pp-progress-fill');
  const progressWrap = player.querySelector('.pp-progress-bar');
  const currentTime = player.querySelector('.pp-current');
  const totalTime = player.querySelector('.pp-total');

  audio.dataset.podcastUrl = audioUrl; // Always store URL for recovery
  audio.src = audioUrl;
  if (!autoStop) {
    // Idle restoration ‚Äî don't preload or claim active state
    audio.preload = 'none';
    audio.src = '';
  } else {
    activePodcastAudio = audio;
    activePodcastYear = year;
  }

  // Auto-expand card if not expanded
  if (!entryEl.classList.contains('expanded')) {
    entryEl.classList.add('expanded');
    const details = entryEl.querySelector('.card-details');
    if (details) details.style.maxHeight = 'none';
  }

  playBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    // Get fresh reference to podcast button (may have been rebuilt)
    const btn = entryEl.querySelector('.podcast-btn');
    
    // Lazy-load audio if this was an idle restored player
    const needsLoad = !audio.src || audio.src === window.location.href || audio.readyState === 0;
    if (needsLoad && audio.dataset.podcastUrl) {
      if (threadPlayActive) stopThreadPlayAll();
      else if (globalPlayActive) stopGlobalPlayAll();
      else stopAllPodcasts();
      audio.src = audio.dataset.podcastUrl;
      audio.load(); // Force load
      activePodcastAudio = audio;
      activePodcastYear = year;
      // Update UI immediately
      playBtn.innerHTML = SVG_PAUSE;
      if (btn) btn.innerHTML = SVG_STOP;
      syncMapPopupAudio(year, true);
      updateGlobalPlayButton();
      // Play when ready
      audio.play().catch(() => {
        // Reset UI if play fails
        playBtn.innerHTML = SVG_PLAY;
        if (btn) btn.innerHTML = SVG_HEADPHONES;
        syncMapPopupAudio(year, false);
        updateGlobalPlayButton();
      });
      return;
    }
    
    if (audio.paused) {
      // Claim active state on play (in case another podcast was active)
      if (threadPlayActive) stopThreadPlayAll();
      else if (globalPlayActive) stopGlobalPlayAll();
      else if (activePodcastYear !== year) stopAllPodcasts();
      activePodcastAudio = audio;
      activePodcastYear = year;
      audio.play().catch(() => {});
      playBtn.innerHTML = SVG_PAUSE;
      if (btn) btn.innerHTML = SVG_STOP;
      syncMapPopupAudio(year, true);
      updateGlobalPlayButton();
    } else {
      audio.pause();
      playBtn.innerHTML = SVG_PLAY;
      if (btn) btn.innerHTML = SVG_HEADPHONES;
      syncMapPopupAudio(year, false);
      updateGlobalPlayButton();
    }
  });

  audio.addEventListener('timeupdate', () => {
    if (audio.duration) {
      const pct = (audio.currentTime / audio.duration) * 100;
      progressFill.style.width = pct + '%';
      currentTime.textContent = formatTime(audio.currentTime);
    }
  });

  audio.addEventListener('loadedmetadata', () => {
    totalTime.textContent = formatTime(audio.duration);
  });

  audio.addEventListener('ended', () => {
    const btn = entryEl.querySelector('.podcast-btn');
    playBtn.innerHTML = SVG_PLAY;
    if (btn) btn.innerHTML = SVG_HEADPHONES;
    progressFill.style.width = '0%';
    currentTime.textContent = '0:00';
    syncMapPopupAudio(year, false);
    activePodcastYear = null;
    updateGlobalPlayButton();
  });

  // Seek on click/touch
  const seekHandler = (e) => {
    e.stopPropagation();
    const rect = progressWrap.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const pct = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
    if (audio.duration) {
      audio.currentTime = pct * audio.duration;
    }
  };
  progressWrap.addEventListener('click', seekHandler);
  progressWrap.addEventListener('touchend', (e) => {
    e.stopPropagation();
    e.preventDefault();
    const rect = progressWrap.getBoundingClientRect();
    const touch = e.changedTouches[0];
    const pct = Math.max(0, Math.min(1, (touch.clientX - rect.left) / rect.width));
    if (audio.duration) {
      audio.currentTime = pct * audio.duration;
    }
  });

  return player;
}

function togglePodcastPlayer(entryEl, audioUrl, duration) {
  // Stop any play all if running
  if (threadPlayActive) {
    stopThreadPlayAll();
  } else if (globalPlayActive) {
    stopGlobalPlayAll();
  }
  
  const existing = entryEl.querySelector('.podcast-player');
  const btn = entryEl.querySelector('.podcast-btn');
  const year = entryEl.dataset.year;
  if (existing) {
    const audio = existing.querySelector('audio');
    const playBtn = existing.querySelector('.pp-play');
    if (audio && !audio.paused && audio.src) {
      // Playing ‚Üí pause and keep player visible
      audio.pause();
      if (playBtn) playBtn.innerHTML = SVG_PLAY;
      if (btn) btn.innerHTML = SVG_HEADPHONES;
      syncMapPopupAudio(year, false);
      activePodcastAudio = null;
      activePodcastYear = null;
    } else if (audio && audio.src && audio.currentTime > 0) {
      // Paused mid-track ‚Üí resume playback
      audio.play().then(() => {
        if (playBtn) playBtn.innerHTML = SVG_PAUSE;
        if (btn) btn.innerHTML = SVG_STOP;
        activePodcastAudio = audio;
        activePodcastYear = year;
        syncMapPopupAudio(year, true);
      }).catch(() => {});
    } else {
      // Idle/reset player bar ‚Üí re-arm and play
      stopAllPodcasts();
      audio.src = audioUrl;
      activePodcastAudio = audio;
      activePodcastYear = year;
      audio.play().then(() => {
        if (playBtn) playBtn.innerHTML = SVG_PAUSE;
        if (btn) btn.innerHTML = SVG_STOP;
        syncMapPopupAudio(year, true);
      }).catch(() => {
        if (playBtn) playBtn.innerHTML = SVG_PLAY;
      });
    }
    return;
  }

  // Show player and auto-play
  const player = showPodcastPlayer(entryEl, audioUrl, duration);
  const audio = player.querySelector('audio');
  const playBtn = player.querySelector('.pp-play');
  audio.play().then(() => {
    playBtn.innerHTML = SVG_PAUSE;
    if (btn) btn.innerHTML = SVG_STOP;
    syncMapPopupAudio(year, true);
  }).catch(() => {
    // Autoplay blocked ‚Äî user must click play
    playBtn.innerHTML = SVG_PLAY;
    syncMapPopupAudio(year, false);
  });
}

// --- Thread Filtering ---

function activateThread(threadId, anchorEntry) {
  // Stop global play all if running (thread will have its own play all)
  if (globalPlayActive) stopGlobalPlayAll();
  
  const wasSwitching = activeThread !== null;
  const timeline = document.getElementById('timeline');

  // Record anchor position BEFORE any DOM changes
  let anchorViewportTop = null;
  if (anchorEntry) {
    anchorViewportTop = anchorEntry.getBoundingClientRect().top;
  }

  // When switching or fresh-activating: disable CSS transitions so layout changes are instant.
  // This avoids the shaky scroll drift caused by entries animating height over 400ms.
  if (wasSwitching || anchorEntry) {
    timeline.classList.add('no-transition');
  }

  // --- Clean slate ---
  document.querySelectorAll('.entry').forEach(e => {
    e.classList.remove('thread-hidden', 'thread-highlighted');
    e.style.maxHeight = '';
  });
  document.querySelectorAll('.marker').forEach(m => m.classList.remove('thread-hidden'));
  document.querySelectorAll('.thread-narrative').forEach(n => n.remove());
  clearThreadLines();

  activeThread = threadId;
  mapActiveThread = threadId;
  updateThreadDropdownState();
  const entries = document.querySelectorAll('.entry');
  const matchingEntries = [];

  document.querySelector('.timeline-line').classList.add('thread-active');

  // --- Apply new thread state synchronously ---
  entries.forEach(entry => {
    const threads = JSON.parse(entry.dataset.threads || '[]');
    if (threads.includes(threadId)) {
      entry.classList.add('thread-highlighted');
      matchingEntries.push(entry);
    } else {
      entry.classList.add('thread-hidden');
      entry.style.maxHeight = '0';
    }
  });

  // Hide markers
  document.querySelectorAll('.marker').forEach(m => m.classList.add('thread-hidden'));

  // Insert narrative connectors
  for (let i = 0; i < matchingEntries.length - 1; i++) {
    const fromYear = matchingEntries[i].dataset.year;
    const toYear = matchingEntries[i + 1].dataset.year;
    const narrative = getThreadNarrative(threadId, fromYear, toYear);

    const connector = document.createElement('div');
    connector.className = 'thread-narrative';

    if (narrative) {
      connector.innerHTML = `<span class="narrative-arrow">‚Üì</span>${narrative}`;
    } else {
      const gap = parseInt(toYear) - parseInt(fromYear);
      connector.innerHTML = `<span class="narrative-arrow">‚Üì</span><em>${gap} ${t('yearsLater')}</em>`;
    }

    matchingEntries[i].after(connector);
  }

  // Draw SVG thread lines
  drawThreadLines(matchingEntries);

  // Update all thread tags
  document.querySelectorAll('.thread-tag').forEach(t => {
    t.classList.toggle('active', t.dataset.thread === threadId);
  });

  // Show banner
  const count = matchingEntries.length;
  document.getElementById('threadName').textContent = formatThreadId(threadId);
  document.getElementById('threadCount').textContent = `${count} ${count === 1 ? t('entry') : t('entries')}`;
  document.getElementById('threadBanner').classList.add('visible');
  // Hide global play button when thread is active (thread has its own play all)
  document.getElementById('globalPlayAll').style.display = 'none';

  // --- Scroll handling ---
  if (anchorEntry && anchorViewportTop !== null) {
    // Correct scroll so the clicked card stays put (works for both switch and fresh activation)
    const newTop = anchorEntry.getBoundingClientRect().top;
    const drift = newTop - anchorViewportTop;
    if (Math.abs(drift) > 1) {
      window.scrollBy(0, drift);
    }
    requestAnimationFrame(() => {
      timeline.classList.remove('no-transition');
    });
  } else if (anchorEntry) {
    // Have anchor but didn't capture position (fresh activation without wasSwitching)
    // Disable transitions, snap to anchor
    timeline.classList.add('no-transition');
    requestAnimationFrame(() => {
      anchorEntry.scrollIntoView({ block: 'center' });
      requestAnimationFrame(() => {
        timeline.classList.remove('no-transition');
      });
    });
  } else if (matchingEntries.length > 0) {
    // No anchor at all (e.g. programmatic activation) ‚Äî scroll to first match
    setTimeout(() => {
      highlightAndScroll(matchingEntries[0]);
    }, 300);
  }
}

function clearThread() {
  activeThread = null;
  mapActiveThread = null; // keep both views in sync
  updateThreadDropdownState();

  // Stop thread play all if active
  if (threadPlayActive) {
    stopThreadPlayAll();
  }

  // Restore timeline line
  document.querySelector('.timeline-line').classList.remove('thread-active');
  document.getElementById('timeline').classList.remove('no-transition');

  document.querySelectorAll('.entry').forEach(e => {
    e.classList.remove('thread-hidden', 'thread-highlighted');
    e.style.maxHeight = '';
  });
  document.querySelectorAll('.marker').forEach(m => m.classList.remove('thread-hidden'));
  document.querySelectorAll('.thread-tag').forEach(t => t.classList.remove('active'));
  document.querySelectorAll('.thread-narrative').forEach(n => n.remove());
  clearThreadLines();
  document.getElementById('threadBanner').classList.remove('visible');
  // Show global play button again
  document.getElementById('globalPlayAll').style.display = '';
}

// SVG thread lines
function drawThreadLines(matchingEntries) {
  clearThreadLines();
  if (matchingEntries.length < 2) return;

  // Delay drawing until layout has settled after hide/show transitions
  setTimeout(() => {
    const container = document.querySelector('.timeline-container');
    const containerRect = container.getBoundingClientRect();
    const scrollTop = container.scrollTop || 0;

    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.classList.add('thread-lines-svg');
    // Set SVG to cover the full scrollable height of the container
    const fullHeight = container.scrollHeight;
    svg.setAttribute('width', '100%');
    svg.setAttribute('height', fullHeight + 'px');
    svg.style.height = fullHeight + 'px';
    container.appendChild(svg);

    // Add glow filter
    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    defs.innerHTML = `
      <filter id="threadGlow" x="-50%" y="-50%" width="200%" height="200%">
        <feGaussianBlur stdDeviation="4" result="blur"/>
        <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
      </filter>
    `;
    svg.appendChild(defs);

    const timelineX = container.offsetWidth / 2;

    for (let i = 0; i < matchingEntries.length - 1; i++) {
      const fromEntry = matchingEntries[i];
      const toEntry = matchingEntries[i + 1];

      const fromRect = fromEntry.getBoundingClientRect();
      const toRect = toEntry.getBoundingClientRect();

      // Dot is at top: 24px of the entry, offset from container top
      const fromY = fromRect.top - containerRect.top + scrollTop + 30;
      const toY = toRect.top - containerRect.top + scrollTop + 30;

      // Determine which side the cards are on based on actual visual position
      const containerCenterX = containerRect.left + containerRect.width / 2;
      const fromCenterX = fromRect.left + fromRect.width / 2;
      const toCenterX = toRect.left + toRect.width / 2;
      
      const fromOnLeft = fromCenterX < containerCenterX;
      const toOnLeft = toCenterX < containerCenterX;
      
      // Curve away from where cards are
      let curveDirection;
      if (fromOnLeft && toOnLeft) {
        curveDirection = 1; // curve right (away from left cards)
      } else if (!fromOnLeft && !toOnLeft) {
        curveDirection = -1; // curve left (away from right cards)
      } else {
        // Cards on different sides - curve to the side with fewer/smaller cards
        // For simplicity, just alternate
        curveDirection = (i % 2 === 0) ? 1 : -1;
      }
      
      // Calculate curve intensity based on vertical distance
      const verticalDist = Math.abs(toY - fromY);
      const baseCurve = 80;
      const curveOffset = baseCurve + Math.min(verticalDist * 0.1, 100);

      const midY = (fromY + toY) / 2;
      const controlX = timelineX + (curveOffset * curveDirection);

      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute('d', `M ${timelineX} ${fromY} Q ${controlX} ${midY} ${timelineX} ${toY}`);
      path.setAttribute('fill', 'none');
      path.setAttribute('stroke', 'rgba(124,111,247,0.4)');
      path.setAttribute('stroke-width', '2.5');
      path.setAttribute('stroke-linecap', 'round');
      path.setAttribute('filter', 'url(#threadGlow)');

      // Animate
      const length = path.getTotalLength ? path.getTotalLength() : 500;
      path.setAttribute('stroke-dasharray', length);
      path.setAttribute('stroke-dashoffset', length);
      path.style.transition = `stroke-dashoffset 0.8s ease ${i * 0.2}s`;

      svg.appendChild(path);

      requestAnimationFrame(() => {
        path.setAttribute('stroke-dashoffset', '0');
      });
    }
  }, 500); // wait for hide/show transitions to finish
}

function redrawThreadLines() {
  if (!activeThread) return;
  const matchingEntries = Array.from(document.querySelectorAll('.entry.thread-highlighted'));
  if (matchingEntries.length < 2) return;
  
  clearThreadLines();
  
  const container = document.querySelector('.timeline-container');
  const containerRect = container.getBoundingClientRect();
  const scrollTop = container.scrollTop || 0;

  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  svg.classList.add('thread-lines-svg');
  const fullHeight = container.scrollHeight;
  svg.setAttribute('width', '100%');
  svg.setAttribute('height', fullHeight + 'px');
  svg.style.height = fullHeight + 'px';
  container.appendChild(svg);

  const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
  defs.innerHTML = `
    <filter id="threadGlow" x="-50%" y="-50%" width="200%" height="200%">
      <feGaussianBlur stdDeviation="4" result="blur"/>
      <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
    </filter>
  `;
  svg.appendChild(defs);

  const timelineX = container.offsetWidth / 2;

  for (let i = 0; i < matchingEntries.length - 1; i++) {
    const fromEntry = matchingEntries[i];
    const toEntry = matchingEntries[i + 1];

    const fromRect = fromEntry.getBoundingClientRect();
    const toRect = toEntry.getBoundingClientRect();

    const fromY = fromRect.top - containerRect.top + scrollTop + 30;
    const toY = toRect.top - containerRect.top + scrollTop + 30;

    const containerCenterX = containerRect.left + containerRect.width / 2;
    const fromCenterX = fromRect.left + fromRect.width / 2;
    const toCenterX = toRect.left + toRect.width / 2;
    
    const fromOnLeft = fromCenterX < containerCenterX;
    const toOnLeft = toCenterX < containerCenterX;
    
    let curveDirection;
    if (fromOnLeft && toOnLeft) {
      curveDirection = 1;
    } else if (!fromOnLeft && !toOnLeft) {
      curveDirection = -1;
    } else {
      curveDirection = (i % 2 === 0) ? 1 : -1;
    }
    
    const verticalDist = Math.abs(toY - fromY);
    const baseCurve = 80;
    const curveOffset = baseCurve + Math.min(verticalDist * 0.1, 100);

    const midY = (fromY + toY) / 2;
    const controlX = timelineX + (curveOffset * curveDirection);

    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', `M ${timelineX} ${fromY} Q ${controlX} ${midY} ${timelineX} ${toY}`);
    path.setAttribute('fill', 'none');
    path.setAttribute('stroke', 'rgba(124,111,247,0.4)');
    path.setAttribute('stroke-width', '2.5');
    path.setAttribute('stroke-linecap', 'round');
    path.setAttribute('filter', 'url(#threadGlow)');

    svg.appendChild(path);
  }
}

function clearThreadLines() {
  document.querySelectorAll('.thread-lines-svg').forEach(s => s.remove());
}

document.getElementById('threadClose').addEventListener('click', clearThread);

// Thread Play All
let threadPlayQueue = [];
let threadPlayIndex = -1;
let threadPlayActive = false;

document.getElementById('threadPlayAll').addEventListener('click', () => {
  const btn = document.getElementById('threadPlayAll');
  
  if (threadPlayActive) {
    // Stop playing
    stopThreadPlayAll();
    return;
  }
  
  // Build queue of entries in current thread that have podcasts
  const threadEntries = document.querySelectorAll('.entry.thread-highlighted');
  threadPlayQueue = [];
  threadEntries.forEach(el => {
    const slug = el.id.replace('entry-', '');
    const slice = SLICES.find(s => s.id === slug);
    if (slice && slice.podcast && slice.podcast.url) {
      threadPlayQueue.push({ el, slice });
    }
  });
  
  if (threadPlayQueue.length === 0) return;
  
  // Stop any currently playing podcast
  stopAllPodcasts();
  
  threadPlayActive = true;
  threadPlayIndex = 0;
  btn.innerHTML = SVG_STOP_BTN + ' Stop';
  btn.classList.add('playing');
  updateGlobalPlayButton();
  
  playThreadEntry(0);
});

function playThreadEntry(index) {
  if (index >= threadPlayQueue.length || !threadPlayActive) {
    stopThreadPlayAll();
    return;
  }
  
  const { el, slice } = threadPlayQueue[index];
  threadPlayIndex = index;
  
  // Scroll entry into view
  el.scrollIntoView({ behavior: 'smooth', block: 'center' });
  
  // Expand if needed
  if (!el.classList.contains('expanded')) {
    el.classList.add('expanded');
    const details = el.querySelector('.card-details');
    if (details) details.style.maxHeight = 'none';
  }
  
  // Show player and start playback
  setTimeout(() => {
    const player = showPodcastPlayer(el, slice.podcast.url, slice.podcast.duration);
    const audio = player.querySelector('audio');
    const playBtn = player.querySelector('.pp-play');
    const podcastBtn = el.querySelector('.podcast-btn');
    
    // Set up ended listener for auto-advance
    const onEnded = () => {
      audio.removeEventListener('ended', onEnded);
      if (threadPlayActive) {
        playThreadEntry(index + 1);
      }
    };
    audio.addEventListener('ended', onEnded);
    
    // Start playback
    audio.src = slice.podcast.url;
    activePodcastAudio = audio;
    activePodcastYear = el.dataset.year;
    audio.play().then(() => {
      playBtn.innerHTML = SVG_PAUSE;
      if (podcastBtn) podcastBtn.innerHTML = SVG_STOP;
      syncMapPopupAudio(el.dataset.year, true);
    }).catch(() => {
      // Skip to next on error
      if (threadPlayActive) playThreadEntry(index + 1);
    });
  }, 300);
}

function stopThreadPlayAll() {
  threadPlayActive = false;
  threadPlayIndex = -1;
  threadPlayQueue = [];
  stopAllPodcasts();
  const btn = document.getElementById('threadPlayAll');
  btn.innerHTML = SVG_PLAY_BTN + ' Play All';
  btn.classList.remove('playing');
  updateGlobalPlayButton();
}

// Global Play All (when no thread is active)
let globalPlayQueue = [];
let globalPlayIndex = -1;
let globalPlayActive = false;

// Update global play button to reflect any playback state
function updateGlobalPlayButton() {
  const btn = document.getElementById('globalPlayAll');
  if (!btn) return;
  const isAnythingPlaying = activePodcastAudio && !activePodcastAudio.paused;
  if (isAnythingPlaying || threadPlayActive || globalPlayActive) {
    btn.innerHTML = SVG_STOP;
    btn.classList.add('playing');
  } else {
    btn.innerHTML = SVG_PLAY;
    btn.classList.remove('playing');
  }
}

document.getElementById('globalPlayAll').addEventListener('click', () => {
  const btn = document.getElementById('globalPlayAll');
  
  // If anything is playing, stop it
  const isAnythingPlaying = activePodcastAudio && !activePodcastAudio.paused;
  if (isAnythingPlaying || threadPlayActive || globalPlayActive) {
    if (threadPlayActive) stopThreadPlayAll();
    else if (globalPlayActive) stopGlobalPlayAll();
    else stopAllPodcasts();
    updateGlobalPlayButton();
    return;
  }
  
  // Nothing playing ‚Äî start play all
  // If thread is active, use thread play all instead
  if (activeThread) {
    document.getElementById('threadPlayAll').click();
    return;
  }
  
  // Build queue of all visible entries with podcasts (sorted by year)
  const allEntries = document.querySelectorAll('.entry:not(.thread-hidden)');
  globalPlayQueue = [];
  allEntries.forEach(el => {
    const slug = el.id.replace('entry-', '');
    const slice = SLICES.find(s => s.id === slug);
    if (slice && slice.podcast && slice.podcast.url) {
      globalPlayQueue.push({ el, slice, year: parseInt(slice.year) });
    }
  });
  
  // Sort by year (oldest first)
  globalPlayQueue.sort((a, b) => a.year - b.year);
  
  if (globalPlayQueue.length === 0) return;
  
  globalPlayActive = true;
  globalPlayIndex = 0;
  updateGlobalPlayButton();
  
  playGlobalEntry(0);
});

function playGlobalEntry(index) {
  if (index >= globalPlayQueue.length || !globalPlayActive) {
    stopGlobalPlayAll();
    return;
  }
  
  const { el, slice } = globalPlayQueue[index];
  globalPlayIndex = index;
  
  // Scroll entry into view
  el.scrollIntoView({ behavior: 'smooth', block: 'center' });
  
  // Expand if needed
  if (!el.classList.contains('expanded')) {
    el.classList.add('expanded');
    const details = el.querySelector('.card-details');
    if (details) details.style.maxHeight = 'none';
    // Load floating image
    const floatImg = el.querySelector('.floating-image img[data-src]');
    if (floatImg && !floatImg.src) floatImg.src = floatImg.dataset.src;
  }
  
  // Show player and start playback
  setTimeout(() => {
    const player = showPodcastPlayer(el, slice.podcast.url, slice.podcast.duration, { autoStop: false });
    const audio = player.querySelector('audio');
    const playBtn = player.querySelector('.pp-play');
    const podcastBtn = el.querySelector('.podcast-btn');
    
    // Set up ended listener for auto-advance
    const onEnded = () => {
      audio.removeEventListener('ended', onEnded);
      if (globalPlayActive) {
        playGlobalEntry(index + 1);
      }
    };
    audio.addEventListener('ended', onEnded);
    
    // Start playback
    audio.src = slice.podcast.url;
    activePodcastAudio = audio;
    activePodcastYear = el.dataset.year;
    audio.play().then(() => {
      playBtn.innerHTML = SVG_PAUSE;
      if (podcastBtn) podcastBtn.innerHTML = SVG_STOP;
      syncMapPopupAudio(el.dataset.year, true);
    }).catch(() => {
      // Skip to next on error
      if (globalPlayActive) playGlobalEntry(index + 1);
    });
  }, 300);
}

function stopGlobalPlayAll() {
  globalPlayActive = false;
  globalPlayIndex = -1;
  globalPlayQueue = [];
  stopAllPodcasts();
  updateGlobalPlayButton();
}

// Lazy image loading
function lazyLoadImages() {
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(e => {
      if (e.isIntersecting) {
        const img = e.target;
        img.src = img.dataset.src;
        img.onload = () => img.classList.add('loaded');
        observer.unobserve(img);
      }
    });
  }, { rootMargin: '200px' });

  document.querySelectorAll('[data-src]').forEach(img => observer.observe(img));
}

// Scroll reveal
function setupScrollReveal() {
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(e => { if (e.isIntersecting) e.target.classList.add('visible'); });
  }, { threshold: 0.1 });
  document.querySelectorAll('.entry').forEach(el => observer.observe(el));
}

// Update UI labels for current language
function updateUILabels() {
  document.getElementById('subtitle').textContent = t('subtitle');
  document.querySelectorAll('#filters .filter-btn').forEach(btn => {
    btn.textContent = t(btn.dataset.dim);
  });
  document.querySelector('.thread-banner span:first-child').innerHTML =
    `üßµ ${t('thread')}: <span class="thread-name" id="threadName"></span>`;
  document.documentElement.lang = currentLang;

  // Toggle button: update to current language
  const toggle = document.getElementById('viewToggle');
  const isMapActive = toggle.classList.contains('active');
  toggle.textContent = isMapActive ? t('viewTimeline') : t('viewMap');

  // Quick action button titles
  document.getElementById('coffeeBtn').title = t('freshEntry');
  document.getElementById('diceBtn').title = t('randomSlice');

  // Map view labels
  document.getElementById('mapSubtitle').textContent = t('viewMap');
  document.getElementById('mapBackBtn').textContent = t('viewTimeline');
}

// Load slices for current language and rebuild timeline
function loadSlices(restoreId, restoreThread, restorePodcast) {
  // Reset the ready promise so buttons wait for the new data
  slicesReady = new Promise(r => { _slicesReadyResolve = r; });

  // Capture expanded entries before rebuild
  const expandedYears = new Set();
  document.querySelectorAll('.entry.expanded[data-year]').forEach(el => {
    expandedYears.add(el.dataset.year);
  });

  // Remember if we're at/near the top of the page
  const wasAtTop = window.scrollY < 80;

  // Record the entry currently in view AND its exact viewport offset
  let restoreOffset = 0;
  if (!restoreId && !wasAtTop) {
    const viewportCenter = window.innerHeight / 2;
    // Only consider visible entries (not thread-hidden)
    const entries = document.querySelectorAll('.entry[data-year]:not(.thread-hidden)');
    let closest = null, closestDist = Infinity;
    entries.forEach(el => {
      const rect = el.getBoundingClientRect();
      // Skip entries not in viewport
      if (rect.bottom < 0 || rect.top > window.innerHeight) return;
      const dist = Math.abs(rect.top + rect.height / 2 - viewportCenter);
      if (dist < closestDist) { closestDist = dist; closest = el; }
    });
    if (closest) {
      restoreId = closest.id.replace('entry-', '');
      restoreOffset = closest.getBoundingClientRect().top;
    }
  }

  // Clear active thread (will restore after if restoreThread is set)
  if (activeThread) clearThread();

  fetch(t('slicesFile'))
    .then(r => r.json())
    .then(data => {
      SLICES = data;
      timeline.innerHTML = '';

      // Determine the most recently added entry (by addedDate ISO timestamp)
      const freshestDate = SLICES.reduce((max, s) => {
        const d = s.addedDate || '';
        return d > max ? d : max;
      }, '');
      const freshestId = freshestDate
        ? SLICES.find(s => s.addedDate === freshestDate)?.id
        : SLICES[SLICES.length - 1]?.id;

      const items = [
        ...SLICES.map(s => ({ type: 'slice', year: parseInt(s.year), data: s })),
        ...MARKERS.map(m => ({ type: 'marker', year: m.year, data: m })),
      ];
      items.sort((a, b) => a.year - b.year || (a.type === 'marker' ? -1 : 1));

      items.forEach((item) => {
        if (item.type === 'slice') {
          timeline.appendChild(renderSlice(item.data, item.data.id === freshestId));
        } else {
          timeline.appendChild(renderMarker(item.data));
        }
      });

      lazyLoadImages();
      setupScrollReveal();

      // Signal that slices are ready for dice/coffee buttons
      _slicesReadyResolve();

      // Restore expanded entries + their podcast player bars
      if (expandedYears.size > 0) {
        expandedYears.forEach(year => {
          const el = document.querySelector(`.entry[data-year="${year}"]`);
          if (!el) return;
          el.classList.add('expanded');
          const details = el.querySelector('.card-details');
          if (details) details.style.maxHeight = 'none';
          // Eagerly load floating image
          const floatImg = el.querySelector('.floating-image img[data-src]');
          if (floatImg && !floatImg.src) floatImg.src = floatImg.dataset.src;
          // Restore podcast player bar if this entry has a podcast
          const slug = el.id.replace('entry-', '');
          const slice = SLICES.find(s => s.id === slug);
          if (slice && slice.podcast && slice.podcast.url && !el.querySelector('.podcast-player')) {
            showPodcastPlayer(el, slice.podcast.url, slice.podcast.duration, { autoStop: false });
          }
        });
      }

      // Restore scroll position ‚Äî exact pixel offset, not highlight-and-scroll
      if (wasAtTop) {
        window.scrollTo(0, 0);
      } else if (restoreId) {
        requestAnimationFrame(() => {
          const target = document.querySelector(`#entry-${restoreId}`);
          if (target) {
            // Reveal all entries instantly so layout is stable before measuring
            document.querySelectorAll('.entry:not(.visible)').forEach(el => {
              el.style.transition = 'none';
              el.classList.add('visible');
            });
            // Scroll so target has the same viewport offset as before
            const newRect = target.getBoundingClientRect();
            const scrollCorrection = newRect.top - restoreOffset;
            window.scrollBy(0, scrollCorrection);
          }
        });
      }

      // Restore thread if requested (after layout settles)
      if (restoreThread) {
        requestAnimationFrame(() => {
          setTimeout(() => activateThread(restoreThread), 50);
        });
      }

      // Restore playing podcast if requested
      if (restorePodcast && restorePodcast.year) {
        requestAnimationFrame(() => {
          setTimeout(() => {
            const el = document.querySelector(`.entry[data-year="${restorePodcast.year}"]`);
            if (!el) return;
            const slug = el.id.replace('entry-', '');
            const slice = SLICES.find(s => s.id === slug);
            if (!slice || !slice.podcast) return;
            
            // Create player if needed and start playback
            const player = showPodcastPlayer(el, slice.podcast.url, slice.podcast.duration, { autoStop: false });
            const audio = player.querySelector('audio');
            const playBtn = player.querySelector('.pp-play');
            const btn = el.querySelector('.podcast-btn');
            
            audio.src = slice.podcast.url;
            audio.currentTime = restorePodcast.time || 0;
            activePodcastAudio = audio;
            activePodcastYear = restorePodcast.year;
            
            // If was in thread play all mode, restore that state
            if (restorePodcast.wasThreadPlayAll && restoreThread) {
              // Rebuild the queue
              const threadEntries = document.querySelectorAll('.entry.thread-highlighted');
              threadPlayQueue = [];
              threadEntries.forEach(entry => {
                const entrySlug = entry.id.replace('entry-', '');
                const entrySlice = SLICES.find(s => s.id === entrySlug);
                if (entrySlice && entrySlice.podcast && entrySlice.podcast.url) {
                  threadPlayQueue.push({ el: entry, slice: entrySlice });
                }
              });
              
              // Find current index in queue
              threadPlayIndex = threadPlayQueue.findIndex(item => item.el.dataset.year === restorePodcast.year);
              if (threadPlayIndex === -1) threadPlayIndex = restorePodcast.threadPlayIdx || 0;
              
              threadPlayActive = true;
              const threadBtn = document.getElementById('threadPlayAll');
              threadBtn.innerHTML = SVG_STOP_BTN + ' Stop';
              threadBtn.classList.add('playing');
              
              // Set up ended listener for auto-advance
              const onEnded = () => {
                audio.removeEventListener('ended', onEnded);
                if (threadPlayActive) {
                  playThreadEntry(threadPlayIndex + 1);
                }
              };
              audio.addEventListener('ended', onEnded);
            }
            // If was in global play all mode, restore that state
            else if (restorePodcast.wasGlobalPlayAll && !restoreThread) {
              // Rebuild the queue
              const allEntries = document.querySelectorAll('.entry:not(.thread-hidden)');
              globalPlayQueue = [];
              allEntries.forEach(entry => {
                const entrySlug = entry.id.replace('entry-', '');
                const entrySlice = SLICES.find(s => s.id === entrySlug);
                if (entrySlice && entrySlice.podcast && entrySlice.podcast.url) {
                  globalPlayQueue.push({ el: entry, slice: entrySlice, year: parseInt(entrySlice.year) });
                }
              });
              globalPlayQueue.sort((a, b) => a.year - b.year);
              
              // Find current index in queue
              globalPlayIndex = globalPlayQueue.findIndex(item => item.el.dataset.year === restorePodcast.year);
              if (globalPlayIndex === -1) globalPlayIndex = restorePodcast.globalPlayIdx || 0;
              
              globalPlayActive = true;
              const globalBtn = document.getElementById('globalPlayAll');
              globalBtn.innerHTML = SVG_STOP;
              globalBtn.classList.add('playing');
              
              // Set up ended listener for auto-advance
              const onEnded = () => {
                audio.removeEventListener('ended', onEnded);
                if (globalPlayActive) {
                  playGlobalEntry(globalPlayIndex + 1);
                }
              };
              audio.addEventListener('ended', onEnded);
            }
            
            audio.play().then(() => {
              playBtn.innerHTML = SVG_PAUSE;
              if (btn) btn.innerHTML = SVG_STOP;
              syncMapPopupAudio(restorePodcast.year, true);
            }).catch(() => {});
          }, 100);
        });
      }
    });
}

// Thread dropdown
function populateThreadDropdown() {
  const menu = document.getElementById('threadDropdownMenu');
  if (!menu || !SLICES) return;
  
  // Count entries per thread
  const threadCounts = {};
  SLICES.forEach(slice => {
    (slice.threads || []).forEach(t => {
      threadCounts[t] = (threadCounts[t] || 0) + 1;
    });
  });
  
  // Sort threads: connected (2+) first by count, then orphans
  const threads = Object.entries(threadCounts)
    .sort((a, b) => {
      if (a[1] >= 2 && b[1] < 2) return -1;
      if (b[1] >= 2 && a[1] < 2) return 1;
      return b[1] - a[1] || a[0].localeCompare(b[0]);
    });
  
  menu.innerHTML = threads.map(([thread, count]) => {
    const label = THREAD_LABELS[currentLang]?.[thread] || formatThreadId(thread);
    return `<div class="thread-dropdown-item" data-thread="${thread}">
      <span>${label}</span>
      <span class="thread-count">${count}</span>
    </div>`;
  }).join('');
  
  // Add click handlers
  menu.querySelectorAll('.thread-dropdown-item').forEach(item => {
    item.addEventListener('click', () => {
      const thread = item.dataset.thread;
      closeThreadDropdown();
      activateThread(thread);
    });
  });
}

function openThreadDropdown() {
  const menu = document.getElementById('threadDropdownMenu');
  const btn = document.getElementById('threadDropdownBtn');
  populateThreadDropdown();
  menu.classList.add('open');
  btn.classList.add('active');
}

function closeThreadDropdown() {
  const menu = document.getElementById('threadDropdownMenu');
  const btn = document.getElementById('threadDropdownBtn');
  menu.classList.remove('open');
  btn.classList.remove('active');
}

function toggleThreadDropdown() {
  const menu = document.getElementById('threadDropdownMenu');
  if (menu.classList.contains('open')) {
    closeThreadDropdown();
  } else {
    openThreadDropdown();
  }
}

document.getElementById('threadDropdownBtn').addEventListener('click', (e) => {
  e.stopPropagation();
  toggleThreadDropdown();
});

// Close dropdown when clicking outside
document.addEventListener('click', (e) => {
  if (!e.target.closest('.thread-dropdown')) {
    closeThreadDropdown();
  }
});

// Update dropdown active state when thread changes
function updateThreadDropdownState() {
  const menu = document.getElementById('threadDropdownMenu');
  menu.querySelectorAll('.thread-dropdown-item').forEach(item => {
    if (item.dataset.thread === activeThread) {
      item.classList.add('active');
    } else {
      item.classList.remove('active');
    }
  });
}

// Language switcher
document.querySelectorAll('.lang-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    const lang = btn.dataset.lang;
    if (lang === currentLang) return;
    // Capture state before switching
    const threadToRestore = activeThread;
    const playingYear = activePodcastYear;
    const playingTime = activePodcastAudio ? activePodcastAudio.currentTime : 0;
    const wasPlaying = activePodcastAudio && !activePodcastAudio.paused;
    const wasThreadPlayAll = threadPlayActive;
    const threadPlayIdx = threadPlayIndex;
    const wasGlobalPlayAll = globalPlayActive;
    const globalPlayIdx = globalPlayIndex;
    currentLang = lang;
    document.querySelectorAll('.lang-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    stopAllPodcasts();
    // Reset play all states (will restore after)
    threadPlayActive = false;
    threadPlayIndex = -1;
    threadPlayQueue = [];
    globalPlayActive = false;
    globalPlayIndex = -1;
    globalPlayQueue = [];
    updateUILabels();
    loadSlices(null, threadToRestore, wasPlaying ? { year: playingYear, time: playingTime, wasThreadPlayAll, threadPlayIdx, wasGlobalPlayAll, globalPlayIdx } : null);
  });
});

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  // Don't capture if user is typing in an input
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
  
  // Space to play/pause active podcast
  if (e.code === 'Space' && activePodcastAudio) {
    e.preventDefault();
    if (activePodcastAudio.paused) {
      activePodcastAudio.play().catch(() => {});
      // Update UI
      const entry = document.querySelector(`.entry[data-year="${activePodcastYear}"]`);
      if (entry) {
        const playBtn = entry.querySelector('.pp-play');
        const podcastBtn = entry.querySelector('.podcast-btn');
        if (playBtn) playBtn.innerHTML = SVG_PAUSE;
        if (podcastBtn) podcastBtn.innerHTML = SVG_STOP;
        syncMapPopupAudio(activePodcastYear, true);
      }
    } else {
      activePodcastAudio.pause();
      // Update UI
      const entry = document.querySelector(`.entry[data-year="${activePodcastYear}"]`);
      if (entry) {
        const playBtn = entry.querySelector('.pp-play');
        const podcastBtn = entry.querySelector('.podcast-btn');
        if (playBtn) playBtn.innerHTML = SVG_PLAY;
        if (podcastBtn) podcastBtn.innerHTML = SVG_HEADPHONES;
        syncMapPopupAudio(activePodcastYear, false);
      }
    }
  }
  
  // Left/Right arrows to seek
  if (e.code === 'ArrowLeft' && activePodcastAudio && activePodcastAudio.duration) {
    e.preventDefault();
    activePodcastAudio.currentTime = Math.max(0, activePodcastAudio.currentTime - 10);
  }
  if (e.code === 'ArrowRight' && activePodcastAudio && activePodcastAudio.duration) {
    e.preventDefault();
    activePodcastAudio.currentTime = Math.min(activePodcastAudio.duration, activePodcastAudio.currentTime + 10);
  }
});

// Init: set correct lang button active and load
(function init() {
  document.querySelectorAll('.lang-btn').forEach(b => {
    b.classList.toggle('active', b.dataset.lang === currentLang);
  });
  updateUILabels();
  loadSlices();

  // Handle incoming hash links (e.g. #1784-europe-dare-to-know or legacy #1784)
  slicesReady.then(() => {
    const hash = window.location.hash.replace('#', '');
    if (!hash) return;
    // Try full id first, then legacy year-only lookup
    let entry = document.getElementById(`entry-${hash}`);
    if (!entry) {
      // Legacy: #1784 ‚Üí find entry whose data-year matches
      entry = document.querySelector(`.entry[data-year="${hash}"]`);
    }
    if (entry) {
      setTimeout(() => highlightAndScroll(entry), 300);
    }
  });
})();

// ========================================
// MAP VIEW
// ========================================

let map = null;
let mapMarkers = [];
let mapArcs = [];
let mapActiveThread = null;
let mapIsPlaying = false;

// Initialize Leaflet map (lazy ‚Äî only on first toggle)
function initMap() {
  if (map) return;

  map = L.map('map', {
    center: [42, 20],
    zoom: 4,
    zoomControl: false,
    attributionControl: false,
  });

  // CartoDB Dark Matter ‚Äî matches our aesthetic
  L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
    maxZoom: 18,
    subdomains: 'abcd',
  }).addTo(map);

  // Zoom control in bottom-right ‚Äî desktop only (mobile uses pinch)
  if (window.innerWidth > 768) {
    L.control.zoom({ position: 'bottomright' }).addTo(map);
  }
}

function createMapMarker(slice) {
  if (!slice.location) return null;

  const icon = L.divIcon({
    className: '',
    html: `<div class="map-marker-wrap">
             <div class="map-marker" data-year="${slice.year}"></div>
             <div class="map-marker-ring"></div>
             <div class="map-marker-label">${formatYear(slice.year)} ¬∑ ${slice.location.place}</div>
             <div class="map-marker-year">${formatYear(slice.year)}</div>
           </div>`,
    iconSize: [40, 40],
    iconAnchor: [20, 20],
    popupAnchor: [0, -24],
  });

  const marker = L.marker([slice.location.lat, slice.location.lon], { icon });

  // Build popup content
  const threads = (slice.threads || []).map(t =>
    `<span class="thread-tag" data-thread="${t}" onclick="event.stopPropagation(); activateMapThread('${t}')">${formatThreadId(t)}</span>`
  ).join('');

  const isMobile = window.innerWidth <= 768;
  const popup = L.popup({
    maxWidth: isMobile ? 260 : 320,
    minWidth: isMobile ? 180 : 240,
    closeButton: true,
    autoPanPaddingTopLeft: L.point(10, isMobile ? 10 : 80),
    autoPanPaddingBottomRight: L.point(10, isMobile ? 140 : 10),
  });

  const podcastHtml = (slice.podcast && typeof slice.podcast === 'object' && slice.podcast.url) ? `
    <div class="map-popup-audio" data-audio-url="${slice.podcast.url}" data-year="${slice.year}">
      <span class="mpa-icon">${SVG_PLAY}</span>
      <span class="mpa-label">${t('listenPodcast')}</span>
      <span class="mpa-duration">${formatTime(slice.podcast.duration || 0)}</span>
    </div>` : '';

  popup.setContent(`
    <div class="map-popup-year">${formatYear(slice.year)}</div>
    <div class="map-popup-title">${slice.title}</div>
    <div class="map-popup-teaser">${slice.teaser}</div>
    ${podcastHtml}
    <div class="map-popup-threads">${threads}</div>
    <a class="map-popup-link" onclick="scrollToEntry('${slice.id}')">${t('viewInTimeline')}</a>
  `);

  marker.bindPopup(popup);
  marker._sliceYear = parseInt(slice.year);
  marker._sliceThreads = slice.threads || [];

  marker.on('popupopen', () => {
    const el = marker.getElement();
    if (el) {
      const lbl = el.querySelector('.map-marker-label');
      const yr = el.querySelector('.map-marker-year');
      if (lbl) lbl.style.opacity = '0';
      if (yr) yr.style.opacity = '0';
    }
    // Wire up podcast button in popup
    const popupEl = marker.getPopup().getElement();
    if (popupEl) {
      const audioBtn = popupEl.querySelector('.map-popup-audio');
      if (audioBtn) {
        // Sync button state if this entry is already playing
        const year = audioBtn.dataset.year;
        if (activePodcastYear === year && activePodcastAudio && !activePodcastAudio.paused) {
          audioBtn.classList.add('playing');
          audioBtn.querySelector('.mpa-icon').innerHTML = SVG_PAUSE;
        }

        audioBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          const year = audioBtn.dataset.year;
          const isPlaying = activePodcastYear === year && activePodcastAudio && !activePodcastAudio.paused;

          // Find the timeline entry and delegate to the unified player
          const entryEl = document.querySelector(`.entry[data-year="${year}"]`);
          if (entryEl) {
            const slice = SLICES.find(s => String(s.year) === String(year));
            if (slice && slice.podcast) {
              if (isPlaying) {
                // Pause existing ‚Äî use the timeline player's pause
                const ppPlay = entryEl.querySelector('.podcast-player .pp-play');
                if (ppPlay) ppPlay.click();
                else {
                  // Fallback: stop directly
                  stopAllPodcasts();
                }
              } else if (activePodcastYear === year && activePodcastAudio && activePodcastAudio.paused) {
                // Resume existing ‚Äî use the timeline player's play
                const ppPlay = entryEl.querySelector('.podcast-player .pp-play');
                if (ppPlay) ppPlay.click();
              } else {
                // Start new ‚Äî open timeline player (which handles cleanup)
                togglePodcastPlayer(entryEl, slice.podcast.url, slice.podcast.duration);
              }
            }
          }
        });
      }
    }
  });
  marker.on('popupclose', () => {
    const el = marker.getElement();
    if (el) {
      const lbl = el.querySelector('.map-marker-label');
      const yr = el.querySelector('.map-marker-year');
      if (lbl) lbl.style.opacity = '';
      if (yr) yr.style.opacity = '';
    }
    // Audio keeps playing after popup close ‚Äî managed by the timeline player
  });

  return marker;
}

function populateMap() {
  // Clear existing markers
  mapMarkers.forEach(m => map.removeLayer(m));
  mapMarkers = [];
  clearMapArcs();

  SLICES.forEach(slice => {
    const marker = createMapMarker(slice);
    if (marker) {
      marker.addTo(map);
      mapMarkers.push(marker);
    }
  });

  // Update slider range
  if (SLICES.length > 0) {
    const years = SLICES.map(s => parseInt(s.year)).sort((a, b) => a - b);
    const minY = Math.max(years[0] - 100, -3000);
    const maxY = new Date().getFullYear();
    const slider = document.getElementById('timeSlider');
    slider.min = minY;
    slider.max = maxY;
    slider.value = maxY;
    document.getElementById('timeYearDisplay').textContent = maxY;
  }

  // Fit bounds to show all markers (skip if thread active ‚Äî thread will fit its own)
  if (mapMarkers.length > 1 && !mapActiveThread) {
    const group = L.featureGroup(mapMarkers);
    map.fitBounds(group.getBounds().pad(0.3), { maxZoom: 6 });
  }

  // Update map lang buttons
  document.querySelectorAll('[data-map="1"]').forEach(b => {
    b.classList.toggle('active', b.dataset.lang === currentLang);
  });

  // Re-apply thread if active
  if (mapActiveThread) {
    activateMapThread(mapActiveThread);
  }
}

// Time slider logic
// Time window: entries visible within this many years of the slider position.
// They fade in over FADE_ZONE years before full visibility, fade out over FADE_ZONE after.
const TIME_WINDOW = 120;   // total half-window (entry visible ¬±120 years from its date)
const FADE_ZONE = 40;      // fade-in/out zone at edges

function updateTimeFilter(maxYear) {
  document.getElementById('timeYearDisplay').textContent = maxYear;

  mapMarkers.forEach(marker => {
    const markerEl = marker.getElement();
    if (!markerEl) return;
    const dot = markerEl.querySelector('.map-marker');
    const label = markerEl.querySelector('.map-marker-label');
    if (!dot) return;

    const year = marker._sliceYear;
    const isThreadMember = mapActiveThread && marker._sliceThreads.includes(mapActiveThread);

    // Thread mode (playing OR manual scrub): thread members always visible, others hidden
    if (mapActiveThread && isThreadMember) {
      dot.classList.remove('hidden-by-time');
      dot.style.opacity = 1;
      if (label) label.style.opacity = 1;
      return;
    }
    if (mapActiveThread && !isThreadMember) {
      dot.classList.add('hidden-by-time');
      dot.style.opacity = '';
      if (label) label.style.opacity = '0';
      if (marker.isPopupOpen()) marker.closePopup();
      return;
    }

    const diff = maxYear - year; // positive = slider is past this entry

    // Visible when slider is within [-TIME_WINDOW, +TIME_WINDOW] of entry year
    // i.e. entry appears TIME_WINDOW years before its date, disappears TIME_WINDOW after
    if (diff >= -TIME_WINDOW && diff <= TIME_WINDOW) {
      const wasHidden = dot.classList.contains('hidden-by-time');
      dot.classList.remove('hidden-by-time');

      // Calculate opacity for smooth fade at edges
      let opacity = 1;
      if (diff < -TIME_WINDOW + FADE_ZONE) {
        // Fading in (slider approaching from below)
        opacity = (diff + TIME_WINDOW) / FADE_ZONE;
      } else if (diff > TIME_WINDOW - FADE_ZONE) {
        // Fading out (slider moving past)
        opacity = (TIME_WINDOW - diff) / FADE_ZONE;
      }
      opacity = Math.max(0, Math.min(1, opacity));

      dot.style.opacity = opacity;
      if (label) label.style.opacity = opacity;

      // Close popup if marker has mostly faded
      if (opacity < 0.3 && marker.isPopupOpen()) marker.closePopup();

      if (wasHidden && opacity > 0.3) {
        dot.classList.add('arriving');
        setTimeout(() => dot.classList.remove('arriving'), 1000);
      }
    } else {
      dot.classList.add('hidden-by-time');
      dot.classList.remove('arriving');
      dot.style.opacity = '';
      if (label) label.style.opacity = '0';
      if (marker.isPopupOpen()) marker.closePopup();
    }
  });

  // Redraw arcs if thread is active (but not during tour ‚Äî tour draws its own)
  if (mapActiveThread && !mapIsPlaying) {
    drawMapArcs(mapActiveThread, maxYear);
  }

  // Fit map bounds to visible markers (debounced to avoid jitter during scrubbing)
  fitToVisibleMarkers(maxYear);
}

let _fitBoundsTimer = null;
let _lastFitSet = null;
let _lastVisibleSet = '';  // track which markers are visible to only refit on change
function fitToVisibleMarkers(maxYear) {
  if (_suppressAutoFit) return;
  // In thread mode (manual scrub), don't auto-fit ‚Äî user controls the camera
  if (mapActiveThread && !mapIsPlaying) return;

  const visible = mapMarkers.filter(m => Math.abs(maxYear - m._sliceYear) <= TIME_WINDOW);
  if (visible.length === 0) return;

  // Build a key from visible marker years to detect actual changes
  const visibleKey = visible.map(m => m._sliceYear).sort().join(',');

  if (mapIsPlaying) {
    // During autoplay: only refit when the visible set changes (marker enters/exits)
    if (visibleKey === _lastVisibleSet) return;
    _lastVisibleSet = visibleKey;
    if (visible.length === 1) {
      map.flyTo(visible[0].getLatLng(), 5, { duration: 1.0 });
    } else {
      const group = L.featureGroup(visible);
      map.flyToBounds(group.getBounds().pad(0.4), { maxZoom: 6, duration: 1.0 });
    }
  } else {
    // Manual scrubbing: throttle to one fit every 600ms
    const now = Date.now();
    if (_lastFitSet && now - _lastFitSet < 600) return;
    _lastFitSet = now;
    _lastVisibleSet = visibleKey;
    if (visible.length === 1) {
      map.flyTo(visible[0].getLatLng(), 5, { duration: 0.5 });
    } else {
      const group = L.featureGroup(visible);
      map.flyToBounds(group.getBounds().pad(0.4), { maxZoom: 6, duration: 0.5 });
    }
  }
}

document.getElementById('timeSlider').addEventListener('input', (e) => {
  // If a thread tour is playing, stop it ‚Äî user takes over
  if (mapIsPlaying) stopMapPlay();
  updateTimeFilter(parseInt(e.target.value));
});

// Auto-play ‚Äî density-proportional speed (normal mode)
// Thread tour ‚Äî sequential fly-between with arc animation (thread mode)
function startMapPlay() {
  if (mapActiveThread) {
    startThreadTour();
    return;
  }

  mapIsPlaying = true;
  _lastVisibleSet = '';  // reset so first frame triggers a fit
  document.getElementById('timePlayBtn').classList.add('playing');

  const slider = document.getElementById('timeSlider');
  const min = parseInt(slider.min);
  const max = parseInt(slider.max);
  const current = parseInt(slider.value);

  // Only reset to start if slider is at the end; otherwise resume from current position
  if (current >= max) {
    slider.value = min;
    updateTimeFilter(min);
  }

  // Build a speed map: faster in empty stretches, slower near entries
  const entryYears = SLICES.map(s => parseInt(s.year)).sort((a, b) => a - b);

  function getSpeed(year) {
    // Find distance to nearest entry
    let minDist = Infinity;
    for (const ey of entryYears) {
      minDist = Math.min(minDist, Math.abs(year - ey));
    }

    // Near an entry (within 30 years): slow ‚Äî 2 years/frame
    // Far from any entry (>200 years): fast ‚Äî 15 years/frame
    // In between: interpolate
    if (minDist <= 30) return 2;
    if (minDist >= 200) return 15;
    return 2 + (minDist - 30) / (200 - 30) * 13;
  }

  // Pause briefly when hitting an entry
  let pauseFrames = 0;

  function tick() {
    if (!mapIsPlaying) return;

    const current = parseInt(slider.value);
    if (current >= max) {
      stopMapPlay();
      return;
    }

    // If pausing at an entry, count down
    if (pauseFrames > 0) {
      pauseFrames--;
      requestAnimationFrame(tick);
      return;
    }

    const speed = getSpeed(current);
    const next = Math.min(current + Math.round(speed), max);
    slider.value = next;
    updateTimeFilter(next);

    // Check if we just passed an entry ‚Äî pause for a beat
    for (const ey of entryYears) {
      if (ey > current && ey <= next) {
        pauseFrames = 45; // ~0.75 seconds at 60fps
        break;
      }
    }

    requestAnimationFrame(tick);
  }

  requestAnimationFrame(tick);
}

// Thread tour: guided journey through thread entries
let _threadTourAbort = false;

async function startThreadTour() {
  const threadId = mapActiveThread;
  if (!threadId) return;

  // Get thread entries sorted chronologically
  const threadSlices = SLICES
    .filter(s => (s.threads || []).includes(threadId) && s.location)
    .sort((a, b) => parseInt(a.year) - parseInt(b.year));

  if (threadSlices.length < 2) {
    // Not enough entries for a tour ‚Äî fall back to normal play
    mapActiveThread = null;
    startMapPlay();
    mapActiveThread = threadId;
    return;
  }

  mapIsPlaying = true;
  _threadTourAbort = false;
  document.getElementById('timePlayBtn').classList.add('playing');

  const slider = document.getElementById('timeSlider');

  // Clear existing arcs ‚Äî we'll draw them one by one
  clearMapArcs();

  // Helper: wait ms, checking for abort
  function wait(ms) {
    return new Promise(resolve => {
      const start = Date.now();
      function check() {
        if (_threadTourAbort || !mapIsPlaying) { resolve(); return; }
        if (Date.now() - start >= ms) { resolve(); return; }
        requestAnimationFrame(check);
      }
      check();
    });
  }

  // Helper: smoothly animate slider from current to target year
  function animateSlider(targetYear, durationMs) {
    return new Promise(resolve => {
      const startVal = parseInt(slider.value);
      const diff = targetYear - startVal;
      const startTime = performance.now();
      function frame(now) {
        if (_threadTourAbort || !mapIsPlaying) { resolve(); return; }
        const elapsed = now - startTime;
        const progress = Math.min(elapsed / durationMs, 1);
        // Ease in-out
        const eased = progress < 0.5
          ? 2 * progress * progress
          : 1 - Math.pow(-2 * progress + 2, 2) / 2;
        const val = Math.round(startVal + diff * eased);
        slider.value = val;
        updateTimeFilter(val);
        if (progress < 1) requestAnimationFrame(frame);
        else resolve();
      }
      requestAnimationFrame(frame);
    });
  }

  // Helper: draw a single arc between two markers, animated ‚Äî camera follows the tip
  function drawSingleArc(fromSlice, toSlice) {
    return new Promise(resolve => {
      const fromMarker = mapMarkers.find(m => m._sliceYear === parseInt(fromSlice.year));
      const toMarker = mapMarkers.find(m => m._sliceYear === parseInt(toSlice.year));
      if (!fromMarker || !toMarker) { resolve(); return; }

      const from = fromMarker.getLatLng();
      const to = toMarker.getLatLng();
      const latlngs = generateArc(from, to, 100);

      const glowArc = L.polyline([], {
        color: 'rgba(124,111,247,0.2)',
        weight: 8, lineCap: 'round', lineJoin: 'round', interactive: false,
      }).addTo(map);

      const arc = L.polyline([], {
        color: 'rgba(124,111,247,0.7)',
        weight: 3, lineCap: 'round', lineJoin: 'round', interactive: false,
      }).addTo(map);

      mapArcs.push(glowArc, arc);

      const gap = parseInt(toSlice.year) - parseInt(fromSlice.year);
      const midIdx = Math.floor(latlngs.length / 2);

      // Animate arc drawing ‚Äî 1 point per frame for ~1.7s at 60fps
      let frame = 0;
      const totalFrames = latlngs.length;
      // Pan camera every N frames to follow the arc tip smoothly
      const panEvery = 20;

      function animateArc() {
        if (_threadTourAbort || !mapIsPlaying) { resolve(); return; }
        frame++;
        const partial = latlngs.slice(0, Math.min(frame, totalFrames));
        glowArc.setLatLngs(partial);
        arc.setLatLngs(partial);

        // Gently pan to keep arc tip in view
        if (frame % panEvery === 0 && frame < totalFrames) {
          const tip = latlngs[Math.min(frame, totalFrames - 1)];
          map.panTo(tip, { animate: true, duration: 0.5, noMoveStart: true });
        }

        if (frame < totalFrames) {
          requestAnimationFrame(animateArc);
        } else {
          // Add year label after arc completes
          const yearLabel = L.marker(latlngs[midIdx], {
            icon: L.divIcon({
              className: '',
              html: `<div style="
                color:rgba(255,255,255,0.95);
                font-family:var(--mono);
                font-size:0.65rem;
                font-weight:600;
                text-shadow:0 0 6px rgba(124,111,247,0.7), 0 0 12px rgba(124,111,247,0.4), 0 1px 3px rgba(0,0,0,0.9);
                white-space:nowrap;
                pointer-events:none;
                opacity:0;
                transition:opacity 0.4s ease;
              ">${gap} yrs ‚Üí</div>`,
              iconSize: [60, 16],
              iconAnchor: [30, 8],
            }),
            interactive: false,
          }).addTo(map);
          mapArcs.push(yearLabel);
          // Fade in label
          requestAnimationFrame(() => {
            const el = yearLabel.getElement();
            if (el) el.querySelector('div').style.opacity = '1';
          });
          resolve();
        }
      }
      animateArc();
    });
  }

  // Helper: pulse a marker
  function pulseMarker(year) {
    const marker = mapMarkers.find(m => m._sliceYear === parseInt(year));
    if (!marker) return;
    const el = marker.getElement();
    if (!el) return;
    const dot = el.querySelector('.map-marker');
    if (dot) {
      dot.classList.add('arriving');
      setTimeout(() => dot.classList.remove('arriving'), 1200);
    }
  }

  // Suppress auto-fit during tour ‚Äî we control the camera
  _suppressAutoFit = true;

  // Start: set slider just before first entry, show all thread markers
  const firstYear = parseInt(threadSlices[0].year);
  slider.value = firstYear;
  updateTimeFilter(firstYear);

  // Fly to first entry
  const firstLoc = threadSlices[0].location;
  map.flyTo([firstLoc.lat, firstLoc.lon], 5, { duration: 1.5, easeLinearity: 0.1 });
  await wait(1800);
  if (_threadTourAbort) { _suppressAutoFit = false; return; }

  pulseMarker(threadSlices[0].year);
  await wait(1000);
  if (_threadTourAbort) { _suppressAutoFit = false; return; }

  // Journey through each consecutive pair
  for (let i = 0; i < threadSlices.length - 1; i++) {
    if (_threadTourAbort || !mapIsPlaying) break;

    const current = threadSlices[i];
    const next = threadSlices[i + 1];
    const currentYear = parseInt(current.year);
    const nextYear = parseInt(next.year);

    // Gently fit both endpoints into view before drawing
    const fromMarker = mapMarkers.find(m => m._sliceYear === currentYear);
    const toMarker = mapMarkers.find(m => m._sliceYear === nextYear);
    if (fromMarker && toMarker) {
      const group = L.featureGroup([fromMarker, toMarker]);
      map.flyToBounds(group.getBounds().pad(0.6), { maxZoom: 5, duration: 1.5, easeLinearity: 0.1 });
      await wait(1800);
      if (_threadTourAbort) break;
    }

    // Animate slider while arc draws ‚Äî run both concurrently
    const sliderDuration = Math.min(Math.max((nextYear - currentYear) * 3, 800), 2000);
    const arcPromise = drawSingleArc(current, next);
    const sliderPromise = animateSlider(nextYear, sliderDuration);
    await Promise.all([arcPromise, sliderPromise]);
    if (_threadTourAbort) break;

    // Brief pause at destination
    pulseMarker(next.year);
    await wait(1000);
  }

  _suppressAutoFit = false;

  // End: zoom to fit all thread entries
  const threadMarkers = mapMarkers.filter(m => m._sliceThreads.includes(threadId));
  if (threadMarkers.length > 1) {
    const group = L.featureGroup(threadMarkers);
    map.flyToBounds(group.getBounds().pad(0.4), { maxZoom: 5, duration: 1.5, easeLinearity: 0.1 });
  }

  stopMapPlay();
}

function stopMapPlay() {
  mapIsPlaying = false;
  _threadTourAbort = true;
  _suppressAutoFit = false;
  document.getElementById('timePlayBtn').classList.remove('playing');
}

document.getElementById('timePlayBtn').addEventListener('click', () => {
  if (mapIsPlaying) stopMapPlay();
  else startMapPlay();
});

// Thread arcs on map
function activateMapThread(threadId) {
  mapActiveThread = threadId;

  // Close any open popup to avoid overlap with thread banner
  map.closePopup();

  // Also activate in timeline
  activeThread = threadId;

  // Dim non-matching markers, ensure thread members are visible regardless of time window
  mapMarkers.forEach(marker => {
    const el = marker.getElement();
    if (!el) return;
    const dot = el.querySelector('.map-marker');
    const wrap = el.querySelector('.map-marker-wrap');
    const label = el.querySelector('.map-marker-label');
    if (!dot) return;
    if (marker._sliceThreads.includes(threadId)) {
      dot.classList.remove('dimmed');
      dot.classList.remove('hidden-by-time');
      dot.style.opacity = 1;
      if (label) label.style.opacity = 1;
      if (wrap) wrap.style.pointerEvents = '';
      el.style.pointerEvents = '';
    } else {
      dot.classList.add('dimmed');
      if (wrap) wrap.style.pointerEvents = 'none';
      el.style.pointerEvents = 'none';
    }
  });

  // Draw arcs between all thread entries (ignore time window)
  drawMapArcsAll(threadId);

  // Show banner
  document.getElementById('mapThreadName').textContent = formatThreadId(threadId);
  document.getElementById('mapThreadLabel').textContent = t('thread');
  document.getElementById('mapThreadBanner').classList.add('visible');

  // Fit bounds to thread entries
  const threadMarkers = mapMarkers.filter(m => m._sliceThreads.includes(threadId));
  if (threadMarkers.length > 1) {
    const group = L.featureGroup(threadMarkers);
    map.fitBounds(group.getBounds().pad(0.4), { maxZoom: 6 });
  }

  // Narrow slider to thread year range
  const threadYears = SLICES.filter(s => (s.threads || []).includes(threadId))
    .map(s => parseInt(s.year)).sort((a, b) => a - b);
  if (threadYears.length >= 1) {
    const slider = document.getElementById('timeSlider');
    slider.min = threadYears[0];
    slider.max = threadYears[threadYears.length - 1];
    slider.value = slider.max;
    updateTimeFilter(parseInt(slider.max));
  }
}

function clearMapThread() {
  mapActiveThread = null;
  activeThread = null; // keep both views in sync

  mapMarkers.forEach(marker => {
    const el = marker.getElement();
    if (!el) return;
    const dot = el.querySelector('.map-marker');
    const wrap = el.querySelector('.map-marker-wrap');
    if (dot) dot.classList.remove('dimmed');
    if (wrap) wrap.style.pointerEvents = '';
    el.style.pointerEvents = '';
  });

  clearMapArcs();
  document.getElementById('mapThreadBanner').classList.remove('visible');

  // Restore full slider range
  if (SLICES.length > 0) {
    const years = SLICES.map(s => parseInt(s.year)).sort((a, b) => a - b);
    const slider = document.getElementById('timeSlider');
    slider.min = Math.max(years[0] - 100, -3000);
    slider.max = new Date().getFullYear();
    slider.value = slider.max;
    updateTimeFilter(parseInt(slider.max));
  }
}

function drawMapArcs(threadId, maxYear) {
  clearMapArcs();

  // All thread markers (always visible in thread mode), sorted chronologically
  const threadMarkers = mapMarkers
    .filter(m => m._sliceThreads.includes(threadId))
    .sort((a, b) => a._sliceYear - b._sliceYear);

  if (threadMarkers.length < 2) return;

  // Only draw arcs where the slider has reached the destination event
  for (let i = 0; i < threadMarkers.length - 1; i++) {
    const toYear = threadMarkers[i + 1]._sliceYear;
    if (toYear > maxYear) break; // slider hasn't reached this event yet

    const from = threadMarkers[i].getLatLng();
    const to = threadMarkers[i + 1].getLatLng();
    const latlngs = generateArc(from, to, 50);

    const glowArc = L.polyline(latlngs, {
      color: 'rgba(124,111,247,0.2)',
      weight: 8, lineCap: 'round', lineJoin: 'round', interactive: false,
    }).addTo(map);

    const arc = L.polyline(latlngs, {
      color: 'rgba(124,111,247,0.7)',
      weight: 3, lineCap: 'round', lineJoin: 'round', interactive: false,
    }).addTo(map);

    const midIdx = Math.floor(latlngs.length / 2);
    const gap = toYear - threadMarkers[i]._sliceYear;
    const yearLabel = L.marker(latlngs[midIdx], {
      icon: L.divIcon({
        className: '',
        html: `<div style="
          color:rgba(255,255,255,0.95);
          font-family:var(--mono);
          font-size:0.65rem;
          font-weight:600;
          text-shadow:0 0 6px rgba(124,111,247,0.7), 0 0 12px rgba(124,111,247,0.4), 0 1px 3px rgba(0,0,0,0.9);
          white-space:nowrap;
          pointer-events:none;
        ">${gap} yrs ‚Üí</div>`,
        iconSize: [60, 16],
        iconAnchor: [30, 8],
      }),
      interactive: false,
    }).addTo(map);

    mapArcs.push(glowArc, arc, yearLabel);
  }
}

// Draw arcs between ALL thread entries (no time window filter) ‚Äî used when thread is selected statically
function drawMapArcsAll(threadId) {
  clearMapArcs();

  const threadMarkers = mapMarkers
    .filter(m => m._sliceThreads.includes(threadId))
    .sort((a, b) => a._sliceYear - b._sliceYear);

  if (threadMarkers.length < 2) return;

  for (let i = 0; i < threadMarkers.length - 1; i++) {
    const from = threadMarkers[i].getLatLng();
    const to = threadMarkers[i + 1].getLatLng();
    const latlngs = generateArc(from, to, 50);

    const glowArc = L.polyline(latlngs, {
      color: 'rgba(124,111,247,0.2)',
      weight: 8, lineCap: 'round', lineJoin: 'round', interactive: false,
    }).addTo(map);

    const arc = L.polyline(latlngs, {
      color: 'rgba(124,111,247,0.7)',
      weight: 3, lineCap: 'round', lineJoin: 'round', interactive: false,
    }).addTo(map);

    // Staggered animation
    const animDelay = i * 400;
    glowArc.setLatLngs([]);
    arc.setLatLngs([]);
    let frame = 0;
    const totalFrames = latlngs.length;
    setTimeout(() => {
      function animateArc() {
        if (frame >= totalFrames) return;
        frame += 2;
        const partial = latlngs.slice(0, Math.min(frame, totalFrames));
        glowArc.setLatLngs(partial);
        arc.setLatLngs(partial);
        if (frame < totalFrames) requestAnimationFrame(animateArc);
      }
      animateArc();
    }, animDelay);

    const midIdx = Math.floor(latlngs.length / 2);
    const gap = threadMarkers[i + 1]._sliceYear - threadMarkers[i]._sliceYear;
    const yearLabel = L.marker(latlngs[midIdx], {
      icon: L.divIcon({
        className: '',
        html: `<div style="
          color:rgba(255,255,255,0.95);
          font-family:var(--mono);
          font-size:0.65rem;
          font-weight:600;
          text-shadow:0 0 6px rgba(124,111,247,0.7), 0 0 12px rgba(124,111,247,0.4), 0 1px 3px rgba(0,0,0,0.9);
          white-space:nowrap;
          pointer-events:none;
        ">${gap} yrs ‚Üí</div>`,
        iconSize: [60, 16],
        iconAnchor: [30, 8],
      }),
      interactive: false,
    }).addTo(map);

    mapArcs.push(glowArc, arc, yearLabel);
  }
}

function clearMapArcs() {
  if (map) mapArcs.forEach(a => map.removeLayer(a));
  mapArcs = [];
}

// Generate a curved arc between two points
function generateArc(from, to, numPoints) {
  const points = [];
  const latDiff = to.lat - from.lat;
  const lngDiff = to.lng - from.lng;
  const dist = Math.sqrt(latDiff * latDiff + lngDiff * lngDiff);

  for (let i = 0; i <= numPoints; i++) {
    const t = i / numPoints;
    const lat = from.lat + latDiff * t;
    const lng = from.lng + lngDiff * t;

    // Offset perpendicular to create curve
    // Curve height proportional to distance
    const curveHeight = dist * 0.15;
    const offset = Math.sin(t * Math.PI) * curveHeight;

    // Perpendicular direction
    const perpLat = -lngDiff / dist * offset;
    const perpLng = latDiff / dist * offset;

    points.push([lat + perpLat, lng + perpLng]);
  }
  return points;
}

// View toggle
function showMapView() {
  initMap();
  document.getElementById('mapView').classList.add('active');
  document.getElementById('mapTimeControl').classList.add('visible');
  document.getElementById('viewToggle').classList.add('active');
  document.getElementById('viewToggle').textContent = t('viewTimeline');
  document.getElementById('quickActions').style.display = 'none';

  // Hide timeline's thread banner ‚Äî header is z-100, above map z-50
  document.getElementById('threadBanner').classList.remove('visible');

  // Fix Leaflet rendering (needs invalidateSize after display:block)
  setTimeout(() => {
    map.invalidateSize();
    populateMap();
    // populateMap handles mapActiveThread re-activation
  }, 150);
}

function showTimelineView() {
  stopMapPlay();
  document.getElementById('mapView').classList.remove('active');
  document.getElementById('mapTimeControl').classList.remove('visible');
  document.getElementById('viewToggle').classList.remove('active');
  document.getElementById('viewToggle').textContent = t('viewMap');
  document.getElementById('quickActions').style.display = 'flex';

  // Sync thread state: apply whatever thread is active (or clear)
  if (activeThread) {
    // Re-apply visual state on the timeline DOM
    activateThread(activeThread);
  } else {
    clearThread();
  }
}

function scrollToEntry(id) {
  showTimelineView();
  setTimeout(() => {
    const entry = document.getElementById(`entry-${id}`);
    if (entry) {
      highlightAndScroll(entry);
    }
  }, 200);
}

let _suppressAutoFit = false;

function flyToEntry(year) {
  const slice = SLICES.find(s => String(s.year) === String(year));
  if (!slice || !slice.location) return;
  showMapView();
  setTimeout(() => {
    // Set slider to the entry's year so it (and its contemporaries) are visible
    const slider = document.getElementById('timeSlider');
    const numYear = parseInt(year);
    slider.value = Math.max(parseInt(slider.min), Math.min(parseInt(slider.max), numYear));
    _suppressAutoFit = true;
    updateTimeFilter(parseInt(slider.value));
    setTimeout(() => { _suppressAutoFit = false; }, 500);

    map.flyTo([slice.location.lat, slice.location.lon], 5, { duration: 1.2 });
    // Open the marker popup
    const marker = mapMarkers.find(m => String(m._sliceYear) === String(year));
    if (marker) {
      setTimeout(() => marker.openPopup(), 1300);
    }
  }, 200);
}

document.getElementById('viewToggle').addEventListener('click', () => {
  if (document.getElementById('mapView').classList.contains('active')) {
    showTimelineView();
  } else {
    showMapView();
  }
});

document.getElementById('mapBackBtn').addEventListener('click', showTimelineView);
document.getElementById('mapThreadClose').addEventListener('click', clearMapThread);
document.getElementById('mapThreadBanner').addEventListener('click', clearMapThread);

// Map lang switcher
document.querySelectorAll('[data-map="1"]').forEach(btn => {
  btn.addEventListener('click', () => {
    const lang = btn.dataset.lang;
    if (lang === currentLang) return;
    currentLang = lang;
    // Update both header lang buttons
    document.querySelectorAll('.lang-btn').forEach(b => {
      b.classList.toggle('active', b.dataset.lang === currentLang);
    });
    stopAllPodcasts();
    updateUILabels();
    loadSlices();
    // Repopulate map after slices load
    setTimeout(populateMap, 500);
  });
});

// ‚îÄ‚îÄ Shared helper: make an entry visible, scroll to it, highlight it ‚îÄ‚îÄ
function highlightAndScroll(entry) {
  if (!entry) return;

  // Reveal target instantly (skip CSS scroll-reveal transition)
  entry.style.transition = 'none';
  entry.classList.add('visible');
  entry.offsetHeight; // force reflow so browser sees the new layout

  // Reveal everything else so layout is stable
  document.querySelectorAll('.entry:not(.visible)').forEach(el => el.classList.add('visible'));

  // Scroll to entry using native hash navigation
  // The element id is "entry-{slug}" ‚Äî set hash to the full id so the browser finds it
  history.replaceState(null, '', window.location.pathname + window.location.search);
  requestAnimationFrame(() => {
    location.hash = entry.id;

    // Warm glow highlight
    entry.style.transition = 'box-shadow 0.3s ease';
    entry.style.boxShadow = '0 0 20px rgba(209,154,102,0.5)';
    setTimeout(() => {
      entry.style.boxShadow = '';
      entry.style.transition = '';
      // Clean up: show pretty slug in URL bar (without entry- prefix)
      const prettyHash = entry.id.replace('entry-', '');
      history.replaceState(null, '', window.location.pathname + window.location.search + '#' + prettyHash);
    }, 1500);
  });
}

// ‚îÄ‚îÄ üé≤ Dice: pick a random entry from whatever is in the DOM right now ‚îÄ‚îÄ
document.getElementById('diceBtn').addEventListener('click', () => {
  const btn = document.getElementById('diceBtn');
  const entries = Array.from(document.querySelectorAll('.entry[data-year]'));
  if (!entries.length) return; // nothing rendered yet ‚Äî silently no-op

  // Roll animation
  btn.classList.add('rolling');
  setTimeout(() => btn.classList.remove('rolling'), 500);

  const target = entries[Math.floor(Math.random() * entries.length)];
  highlightAndScroll(target);
});

// ‚îÄ‚îÄ ‚òï Coffee: scroll to the freshest entry (the one with the ‚òï badge) ‚îÄ‚îÄ
document.getElementById('coffeeBtn').addEventListener('click', () => {
  const badge = document.querySelector('.entry .fresh-badge');
  if (!badge) return; // no fresh badge in DOM yet ‚Äî silently no-op

  const entry = badge.closest('.entry');
  highlightAndScroll(entry);
});
</script>

</body>
</html>
