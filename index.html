<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Time Slices</title>
<link rel="icon" type="image/svg+xml" href="favicon.svg">
<link rel="apple-touch-icon" href="favicon.svg">
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<style>
  :root {
    --bg: #0a0a0f;
    --surface: #14141f;
    --surface2: #1e1e2e;
    --border: #2a2a3a;
    --text: #e0e0e8;
    --text-dim: #8888a0;
    --accent: #7c6ff7;
    --art: #e06090;
    --lit: #60c0e0;
    --phil: #e0a050;
    --hist: #60e080;
    --conn: #c080e0;
    --font: 'Segoe UI', system-ui, -apple-system, sans-serif;
    --mono: 'SF Mono', 'Fira Code', 'Consolas', monospace;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: var(--font);
    overflow-x: hidden;
  }

  /* Header */
  header {
    position: fixed; top: 0; left: 0; right: 0; z-index: 100;
    background: rgba(10,10,15,0.95);
    backdrop-filter: blur(20px);
    border-bottom: 1px solid var(--border);
    padding: 14px 32px;
  }
  .header-top {
    display: flex; align-items: baseline; justify-content: space-between;
    margin-bottom: 10px;
  }
  .header-left { display: flex; align-items: baseline; }
  .header-right { display: flex; align-items: center; gap: 6px; }
  header h1 {
    font-size: 1.4rem; font-weight: 700;
    background: linear-gradient(135deg, var(--accent), var(--art));
    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  }
  header .subtitle { color: var(--text-dim); font-size: 0.85rem; margin-left: 12px; }

  /* Language switcher */
  .lang-btn {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 3px 10px;
    font-size: 0.75rem;
    font-family: var(--font);
    color: var(--text-dim);
    cursor: pointer;
    transition: all 0.2s ease;
    line-height: 1.4;
  }
  .lang-btn:hover { border-color: var(--text-dim); color: var(--text); }
  .lang-btn.active { background: var(--accent); border-color: var(--accent); color: #fff; }

  /* Thread banner */
  .thread-banner {
    display: none;
    align-items: center;
    gap: 10px;
    margin-top: 10px;
    padding: 8px 14px;
    background: var(--surface2);
    border: 1px solid var(--accent);
    border-radius: 10px;
    font-size: 0.8rem;
    color: var(--text);
    animation: fadeIn 0.2s ease;
  }
  .thread-banner.visible { display: flex; }
  .thread-banner .thread-name {
    font-weight: 600;
    color: var(--accent);
  }
  .thread-banner .thread-close {
    margin-left: auto;
    cursor: pointer;
    color: var(--text-dim);
    font-size: 1.2rem;
    padding: 4px 8px;
    border-radius: 4px;
    transition: background 0.15s ease, color 0.15s ease;
  }
  .thread-banner .thread-close:hover { color: var(--text); background: rgba(255,255,255,0.1); }
  .thread-banner .thread-count { color: var(--text-dim); }

  /* Timeline container */
  .timeline-container {
    margin-top: 110px;
    padding: 40px 32px 80px;
    position: relative;
  }

  /* Central line */
  .timeline-line {
    position: absolute;
    left: 50%;
    top: 0; bottom: 0;
    width: 2px;
    background: linear-gradient(to bottom, transparent, var(--border) 80px, var(--border) calc(100% - 80px), transparent);
    transform: translateX(-50%);
    transition: opacity 0.4s ease;
  }
  .timeline-line.thread-active { opacity: 0.15; }

  /* Entry */
  .entry {
    position: relative;
    width: 45%;
    margin-bottom: 48px;
    cursor: pointer;
    transition: transform 0.2s ease, opacity 0.3s ease, max-height 0.4s ease, margin-bottom 0.4s ease;
  }
  .entry:hover { transform: translateY(-2px); }
  .entry:nth-child(odd) { margin-left: 5%; }
  .entry:nth-child(even) { margin-left: 50%; }
  .entry.thread-hidden {
    max-height: 0;
    margin-bottom: 0;
    opacity: 0;
    pointer-events: none;
    overflow: hidden;
    transition: max-height 0.4s ease, margin-bottom 0.4s ease, opacity 0.3s ease;
  }
  .entry.thread-highlighted { opacity: 1; }

  /* Dot on timeline */
  .entry::before {
    content: '';
    position: absolute;
    top: 24px;
    width: 14px; height: 14px;
    border-radius: 50%;
    background: var(--accent);
    border: 3px solid var(--bg);
    z-index: 2;
    transition: transform 0.2s, box-shadow 0.2s;
  }
  .entry:hover::before {
    transform: scale(1.3);
    box-shadow: 0 0 16px var(--accent);
  }
  .entry:nth-child(odd)::before { right: -32px; }
  .entry:nth-child(even)::before { left: -32px; }

  /* Connector line */
  .entry::after {
    content: '';
    position: absolute;
    top: 30px;
    width: 24px; height: 2px;
    background: var(--border);
  }
  .entry:nth-child(odd)::after { right: -24px; }
  .entry:nth-child(even)::after { left: -24px; }

  /* Card */
  .card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 12px;
    overflow: hidden;
    transition: border-color 0.2s, box-shadow 0.2s;
  }
  .entry:hover .card {
    border-color: var(--accent);
    box-shadow: 0 4px 24px rgba(124,111,247,0.15);
  }
  .entry.expanded .card {
    border-color: var(--accent);
    box-shadow: 0 8px 32px rgba(124,111,247,0.2);
  }

  /* Hero image ‚Äî inline (collapsed state + mobile) */
  .card-image-inline {
    width: 100%;
    height: 500px;
    object-fit: cover;
    object-position: center 20%;
    display: block;
    background: var(--surface2);
    opacity: 0;
    transition: opacity 0.4s ease;
  }
  .card-image-inline.loaded { opacity: 1; }
  .entry.expanded .card-image-inline { display: none; }

  .card-image-caption-inline {
    font-size: 0.7rem;
    color: var(--text-dim);
    padding: 4px 24px 0;
    opacity: 0.6;
    font-style: italic;
  }
  .entry.expanded .card-image-caption-inline { display: none; }

  /* Floating image ‚Äî opposite side (expanded state, desktop only) */
  .floating-image {
    display: none;
    position: absolute;
    top: 0;
    width: 50%;
    z-index: 10;
    animation: fadeIn 0.4s ease;
  }
  .entry.expanded .floating-image { display: block; }
  /* Odd entries are on the left ‚Üí image floats right */
  .entry:nth-child(odd) .floating-image { left: calc(100% + 56px); }
  /* Even entries are on the right ‚Üí image floats left */
  .entry:nth-child(even) .floating-image { right: calc(100% + 56px); }

  .floating-image img {
    width: 100%;
    max-height: 500px;
    object-fit: contain;
    border-radius: 12px;
    background: transparent;
    border: none;
    display: block;
  }
  .floating-image .floating-caption {
    font-size: 0.7rem;
    color: var(--text-dim);
    padding: 6px 4px 0;
    opacity: 0.6;
    font-style: italic;
    text-align: center;
  }
  .floating-image .floating-attribution {
    font-size: 0.6rem;
    color: var(--text-dim);
    opacity: 0.4;
    text-align: center;
    padding-top: 2px;
  }

  .card-body { padding: 20px 24px; }

  .card-year {
    font-family: var(--mono);
    font-size: 0.75rem;
    color: var(--accent);
    letter-spacing: 0.1em;
    text-transform: uppercase;
    margin-bottom: 6px;
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .card-map-link {
    font-size: 0.7rem;
    color: var(--text-dim);
    cursor: pointer;
    opacity: 0.5;
    transition: opacity 0.2s ease, color 0.2s ease;
    text-decoration: none;
    font-family: system-ui, sans-serif;
  }
  .card-map-link:hover {
    opacity: 1;
    color: var(--accent);
  }
  .card-title {
    font-size: 1.15rem;
    font-weight: 600;
    margin-bottom: 8px;
    line-height: 1.3;
  }
  .card-teaser {
    font-size: 0.9rem;
    color: var(--text-dim);
    line-height: 1.5;
  }

  /* Thread tags */
  .card-threads {
    display: flex; flex-wrap: wrap; gap: 6px;
    margin-top: 12px;
  }
  .thread-tag {
    background: var(--surface2);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 2px 10px;
    font-size: 0.7rem;
    color: var(--text-dim);
    cursor: pointer;
    transition: all 0.2s ease;
  }
  .thread-tag:hover {
    border-color: var(--accent);
    color: var(--accent);
    background: rgba(124,111,247,0.1);
  }
  .thread-tag.active {
    border-color: var(--accent);
    color: #fff;
    background: var(--accent);
  }

  /* Expanded content */
  .card-details {
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.5s ease, opacity 0.3s ease;
    opacity: 0;
  }
  .entry.expanded .card-details {
    opacity: 1;
    overflow: visible;
  }

  /* Dimension sections */
  .dimension {
    padding: 14px 0;
    border-top: 1px solid var(--border);
    transition: opacity 0.3s ease, max-height 0.3s ease;
  }
  .dimension:first-child { border-top: none; }
  .dim-header {
    display: flex; align-items: center; gap: 8px;
    font-weight: 600; font-size: 0.9rem;
    margin-bottom: 8px;
  }
  .dim-icon { font-size: 1.1rem; }
  .dim-label-art { color: var(--art); }
  .dim-label-lit { color: var(--lit); }
  .dim-label-phil { color: var(--phil); }
  .dim-label-hist { color: var(--hist); }
  .dim-label-conn { color: var(--conn); }

  .dim-content {
    font-size: 0.88rem;
    line-height: 1.7;
    color: var(--text-dim);
  }
  .dim-content strong { color: var(--text); font-weight: 500; }
  .dim-content em { color: var(--text); font-style: italic; }

  /* Fun fact callout */
  .fun-fact {
    background: var(--surface2);
    border-left: 3px solid var(--border);
    border-radius: 0 8px 8px 0;
    padding: 10px 14px;
    margin-top: 10px;
    font-size: 0.85rem;
    color: var(--text-dim);
    transition: border-color 0.4s ease, background 0.4s ease;
  }
  .fun-fact::before { content: 'üí° '; }
  .entry.expanded .fun-fact {
    border-left-color: var(--accent);
    background: rgba(124,111,247,0.06);
  }

  /* Sources */
  .card-sources {
    padding-top: 12px;
    border-top: 1px solid var(--border);
    margin-top: 4px;
  }
  .card-sources summary {
    font-size: 0.75rem;
    color: var(--text-dim);
    cursor: pointer;
    opacity: 0.6;
  }
  .card-sources summary:hover { opacity: 1; }
  .card-sources a {
    display: block;
    font-size: 0.72rem;
    color: var(--accent);
    text-decoration: none;
    padding: 2px 0;
    opacity: 0.7;
  }
  .card-sources a:hover { opacity: 1; text-decoration: underline; }

  /* Expand hint */
  .expand-hint {
    font-size: 0.75rem;
    color: var(--text-dim);
    margin-top: 10px;
    opacity: 0.6;
    transition: opacity 0.2s;
  }
  .entry:hover .expand-hint { opacity: 1; }
  .entry.expanded .expand-hint { display: none; }

  /* Reference markers */
  .marker {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 12px;
    height: 28px;
  }
  .marker.thread-hidden { display: none; }

  /* Thread narrative connector */
  .thread-narrative {
    position: relative;
    width: 50%;
    margin: 0 auto 32px;
    padding: 14px 20px;
    background: var(--bg);
    border: 1px solid rgba(124,111,247,0.25);
    border-radius: 10px;
    font-size: 0.82rem;
    line-height: 1.6;
    color: var(--text-dim);
    text-align: center;
    animation: fadeIn 0.4s ease;
    z-index: 5;
    /* Cover the timeline line behind */
    box-shadow: 0 0 0 12px var(--bg), 0 0 20px rgba(124,111,247,0.08);
  }
  .thread-narrative .narrative-arrow {
    color: var(--accent);
    opacity: 0.5;
    display: block;
    font-size: 1.2rem;
    margin-bottom: 6px;
  }
  .thread-narrative strong { color: var(--text); font-weight: 500; }
  .thread-narrative em { color: var(--accent); }

  /* SVG thread lines overlay */
  .thread-lines-svg {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 1;
    overflow: visible;
  }
  .marker-line {
    position: absolute;
    left: calc(50% - 60px);
    width: 120px;
    height: 1px;
    background: var(--border);
    opacity: 0.6;
  }
  .marker-label {
    position: relative;
    z-index: 2;
    font-family: var(--mono);
    font-size: 0.65rem;
    color: var(--text-dim);
    letter-spacing: 0.08em;
    background: var(--bg);
    padding: 2px 10px;
    border: 1px solid var(--border);
    border-radius: 10px;
    white-space: nowrap;
    opacity: 0.5;
    transition: opacity 0.2s;
  }
  .marker:hover .marker-label { opacity: 1; }

  /* Responsive */
  @media (max-width: 768px) {
    .timeline-line { left: 24px; }
    .entry { width: calc(100% - 60px); margin-left: 50px !important; }
    .entry::before { left: -33px !important; right: auto !important; }
    .entry::after { left: -24px !important; right: auto !important; }
    header { padding: 10px 16px; }
    .header-top { margin-bottom: 8px; }
    .timeline-container { padding: 40px 16px 80px; margin-top: 120px; }
    .subtitle { display: none; }
    .card-image-inline { max-height: none; height: auto; object-fit: contain; object-position: center; }
    /* On mobile: no floating image, keep inline visible when expanded */
    .floating-image { display: none !important; }
    .entry.expanded .card-image-inline { display: block; }
    .entry.expanded .card-image-caption-inline { display: block; }
    .thread-narrative { width: 80%; }
    .thread-lines-svg { display: none; }
  }

  /* Scroll animation */
  .entry { opacity: 0; transform: translateY(20px); transition: opacity 0.5s ease, transform 0.5s ease; }
  .entry.visible { opacity: 1; transform: translateY(0); }
  .entry:hover.visible { transform: translateY(-2px); }
  .entry.thread-hidden.visible { opacity: 0; transform: translateY(0); }

  @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

  /* View toggle */
  .view-toggle {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 3px 10px;
    font-size: 0.85rem;
    font-family: var(--font);
    color: var(--text-dim);
    cursor: pointer;
    transition: all 0.2s ease;
    line-height: 1.4;
    margin-right: 10px;
  }
  .view-toggle:hover { border-color: var(--text-dim); color: var(--text); }
  .view-toggle.active { background: var(--accent); border-color: var(--accent); color: #fff; }

  /* Map container */
  #mapView {
    display: none;
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    z-index: 50;
    background: var(--bg);
  }
  #mapView.active { display: block; }

  #map {
    position: absolute;
    top: 56px;
    left: 0; right: 0;
    bottom: 72px;
  }

  /* Override Leaflet popups */
  .leaflet-popup-content-wrapper {
    background: var(--surface) !important;
    border: 1px solid var(--accent) !important;
    border-radius: 12px !important;
    color: var(--text) !important;
    box-shadow: 0 8px 32px rgba(124,111,247,0.2) !important;
  }
  .leaflet-popup-tip { background: var(--surface) !important; }
  .leaflet-popup-content {
    margin: 14px 18px !important;
    font-family: var(--font) !important;
    font-size: 0.88rem !important;
    line-height: 1.5 !important;
  }
  .leaflet-popup-close-button {
    color: var(--text-dim) !important;
    font-size: 1.2rem !important;
  }
  .leaflet-popup-close-button:hover { color: var(--text) !important; }

  .map-popup-year {
    font-family: var(--mono);
    font-size: 0.72rem;
    color: var(--accent);
    letter-spacing: 0.1em;
    margin-bottom: 4px;
  }
  .map-popup-title {
    font-size: 1rem;
    font-weight: 600;
    margin-bottom: 6px;
  }
  .map-popup-teaser {
    font-size: 0.82rem;
    color: var(--text-dim);
    margin-bottom: 10px;
    line-height: 1.5;
  }
  .map-popup-threads {
    display: flex; flex-wrap: wrap; gap: 4px;
    margin-bottom: 10px;
  }
  .map-popup-link {
    display: inline-block;
    font-size: 0.78rem;
    color: var(--accent);
    text-decoration: none;
    cursor: pointer;
  }
  .map-popup-link:hover { text-decoration: underline; }

  /* Map time slider */
  .map-time-control {
    position: fixed;
    bottom: 0; left: 0; right: 0;
    z-index: 60;
    background: rgba(10,10,15,0.95);
    backdrop-filter: blur(20px);
    border-top: 1px solid var(--border);
    padding: 16px 32px 20px;
    display: none;
  }
  .map-time-control.visible { display: block; }

  .time-slider-row {
    display: flex;
    align-items: center;
    gap: 16px;
  }
  .time-year-display {
    font-family: var(--mono);
    font-size: 1.4rem;
    color: var(--accent);
    font-weight: 700;
    min-width: 70px;
    text-align: center;
  }
  .time-slider {
    flex: 1;
    -webkit-appearance: none;
    appearance: none;
    height: 4px;
    background: var(--border);
    border-radius: 2px;
    outline: none;
    cursor: pointer;
  }
  .time-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 18px; height: 18px;
    border-radius: 50%;
    background: var(--accent);
    box-shadow: 0 0 12px rgba(124,111,247,0.5);
    cursor: pointer;
    transition: transform 0.15s ease;
  }
  .time-slider::-webkit-slider-thumb:hover { transform: scale(1.3); }
  .time-slider::-moz-range-thumb {
    width: 18px; height: 18px;
    border-radius: 50%;
    background: var(--accent);
    border: none;
    box-shadow: 0 0 12px rgba(124,111,247,0.5);
    cursor: pointer;
  }
  .time-play-btn {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 50%;
    width: 36px; height: 36px;
    font-size: 1rem;
    color: var(--text-dim);
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex; align-items: center; justify-content: center;
  }
  .time-play-btn:hover { border-color: var(--accent); color: var(--accent); }
  .time-play-btn.playing { background: var(--accent); border-color: var(--accent); color: #fff; }

  /* Map marker pulse */
  @keyframes markerPulse {
    0% { box-shadow: 0 0 0 0 rgba(124,111,247,0.6); }
    70% { box-shadow: 0 0 0 16px rgba(124,111,247,0); }
    100% { box-shadow: 0 0 0 0 rgba(124,111,247,0); }
  }
  .map-marker-wrap {
    position: relative;
    width: 40px; height: 40px;
    display: flex; align-items: center; justify-content: center;
    cursor: pointer;
  }
  .map-marker {
    width: 22px; height: 22px;
    border-radius: 50%;
    background: var(--accent);
    border: 3px solid var(--bg);
    box-shadow: 0 0 16px rgba(124,111,247,0.5);
    transition: opacity 0.5s ease, transform 0.3s ease;
    position: relative;
    z-index: 2;
  }
  .map-marker-wrap:hover .map-marker { transform: scale(1.3); }
  .map-marker.arriving {
    animation: markerPulse 1.2s ease-out;
  }
  .map-marker-ring {
    position: absolute;
    width: 36px; height: 36px;
    border-radius: 50%;
    border: 2px solid rgba(124,111,247,0.25);
    top: 2px; left: 2px;
    z-index: 1;
    transition: opacity 0.5s ease;
  }
  .map-marker.dimmed { opacity: 0.15; }
  .map-marker.dimmed + .map-marker-ring { opacity: 0.1; }
  .map-marker.hidden-by-time { opacity: 0; pointer-events: none; }
  .map-marker.hidden-by-time + .map-marker-ring { opacity: 0; }

  .map-marker-label {
    position: absolute;
    top: 38px; left: 50%;
    transform: translateX(-50%);
    font-family: var(--mono);
    font-size: 0.65rem;
    color: var(--text);
    white-space: nowrap;
    letter-spacing: 0.05em;
    text-shadow: 0 1px 6px rgba(0,0,0,0.9), 0 0 12px rgba(0,0,0,0.6);
    pointer-events: none;
    transition: opacity 0.5s ease;
    z-index: 3;
  }

  /* Map thread arcs */
  .thread-arc {
    fill: none;
    stroke: rgba(124,111,247,0.5);
    stroke-width: 2.5;
    stroke-linecap: round;
    filter: drop-shadow(0 0 6px rgba(124,111,247,0.4));
  }

  /* Map header bar */
  .map-header {
    position: fixed;
    top: 0; left: 0; right: 0;
    z-index: 70;
    background: rgba(10,10,15,0.95);
    backdrop-filter: blur(20px);
    border-bottom: 1px solid var(--border);
    padding: 14px 32px;
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
  .map-header h1 {
    font-size: 1.4rem; font-weight: 700;
    background: linear-gradient(135deg, var(--accent), var(--art));
    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  }
  .map-header .subtitle { color: var(--text-dim); font-size: 0.85rem; margin-left: 12px; }

  .map-thread-banner {
    display: none;
    position: fixed;
    top: 72px; left: 50%;
    transform: translateX(-50%);
    z-index: 1100; /* above Leaflet popups (z-index ~700) */
    align-items: center;
    gap: 10px;
    padding: 8px 18px;
    background: rgba(10,10,15,0.95);
    backdrop-filter: blur(20px);
    border: 1px solid var(--accent);
    border-radius: 10px;
    font-size: 0.8rem;
    color: var(--text);
    animation: fadeIn 0.2s ease;
    cursor: pointer; /* whole banner is clickable to dismiss */
  }
  .map-thread-banner.visible { display: flex; }
  .map-thread-banner .thread-name { font-weight: 600; color: var(--accent); }
  .map-thread-banner .thread-close {
    margin-left: auto; cursor: pointer;
    color: var(--text-dim); font-size: 1.2rem;
    padding: 4px 8px;
    border-radius: 4px;
    transition: background 0.15s ease, color 0.15s ease;
  }
  .map-thread-banner .thread-close:hover { color: var(--text); background: rgba(255,255,255,0.1); }

  @media (max-width: 768px) {
    .map-time-control { padding: 12px 16px 16px; }
    .time-year-display { font-size: 1.1rem; min-width: 55px; }
    .map-marker-label { display: none; }
    .map-header .subtitle { display: none; }
  }
</style>
</head>
<body>

<header>
  <div class="header-top">
    <div class="header-left">
      <h1>Time Slices</h1>
      <span class="subtitle" id="subtitle">Cross-disciplinary history exploration</span>
    </div>
    <div class="header-right">
      <button class="view-toggle" id="viewToggle" title="Map view">üó∫Ô∏è</button>
      <button class="lang-btn active" data-lang="en">EN</button>
      <button class="lang-btn" data-lang="it">IT</button>
    </div>
  </div>
  <div class="thread-banner" id="threadBanner">
    <span>üßµ Thread: <span class="thread-name" id="threadName"></span></span>
    <span class="thread-count" id="threadCount"></span>
    <span class="thread-close" id="threadClose">‚úï</span>
  </div>
</header>

<div class="timeline-container">
  <div class="timeline-line"></div>
  <div id="timeline"></div>
</div>

<!-- Map View -->
<div id="mapView">
  <div class="map-header">
    <div style="display:flex;align-items:baseline;">
      <h1>Time Slices</h1>
      <span class="subtitle" id="mapSubtitle">Map</span>
    </div>
    <div style="display:flex;align-items:center;gap:8px;">
      <button class="view-toggle active" id="mapBackBtn" title="Timeline view">üìú</button>
      <button class="lang-btn" data-lang="en" data-map="1">EN</button>
      <button class="lang-btn" data-lang="it" data-map="1">IT</button>
    </div>
  </div>
  <div class="map-thread-banner" id="mapThreadBanner">
    <span>üßµ <span id="mapThreadLabel"></span>: <span class="thread-name" id="mapThreadName"></span></span>
    <span class="thread-close" id="mapThreadClose">‚úï</span>
  </div>
  <div id="map"></div>
</div>

<div class="map-time-control" id="mapTimeControl">
  <div class="time-slider-row">
    <button class="time-play-btn" id="timePlayBtn">‚ñ∂</button>
    <span class="time-year-display" id="timeYearDisplay">762</span>
    <input type="range" class="time-slider" id="timeSlider" min="700" max="2026" value="2026" step="1">
  </div>
</div>

<script>
let SLICES = [];
let activeThread = null;
let currentLang = (navigator.language || '').startsWith('it') ? 'it' : 'en';

const DIM_ICONS = { art: 'üé®', lit: 'üìñ', phil: 'üß†', hist: '‚öîÔ∏è', conn: 'üîó' };

const I18N = {
  en: {
    subtitle: 'Cross-disciplinary history exploration',
    all: 'All', art: 'üé® Art', lit: 'üìñ Literature', phil: 'üß† Philosophy', hist: '‚öîÔ∏è History', conn: 'üîó Connections',
    thread: 'Thread', entries: 'entries', entry: 'entry',
    expandHint: 'Click to explore ‚Üí', sources: 'Sources',
    yearsLater: 'years later‚Ä¶',
    slicesFile: 'slices.json',
  },
  it: {
    subtitle: 'Esplorazione interdisciplinare della storia',
    all: 'Tutti', art: 'üé® Arte', lit: 'üìñ Letteratura', phil: 'üß† Filosofia', hist: '‚öîÔ∏è Storia', conn: 'üîó Connessioni',
    thread: 'Filo', entries: 'voci', entry: 'voce',
    expandHint: 'Clicca per esplorare ‚Üí', sources: 'Fonti',
    yearsLater: 'anni dopo‚Ä¶',
    slicesFile: 'slices.it.json',
  }
};

function t(key) { return I18N[currentLang][key] || I18N.en[key] || key; }
const THREAD_LABELS = {
  en: {
    'translation-movement': 'Translation as Power',
    'rationalism': 'Rationalism',
    'islamic-golden-age': 'Islamic Golden Age',
    'cosmopolitanism': 'Cosmopolitanism',
    'geometry-as-ideology': 'Geometry as Ideology',
    'renaissance-humanism': 'Renaissance Humanism',
    'neoplatonism': 'Neoplatonism',
    'classical-revival': 'Classical Revival',
    'art-and-power': 'Art & Power',
    'christian-humanism': 'Christian Humanism',
    'post-impressionism': 'Post-Impressionism',
    'crisis-of-positivism': 'Crisis of Positivism',
    'modernity': 'Modernity',
    'death-of-god': 'Death of God',
    'expressionism': 'Expressionism',
    'symbolism': 'Symbolism',
    'modernism': 'Modernism',
    'fragmentation': 'Fragmentation',
    'logical-positivism': 'Logical Positivism',
    'existentialism': 'Existentialism',
    'totalitarianism': 'Totalitarianism',
  },
  it: {
    'translation-movement': 'Traduzione come potere',
    'rationalism': 'Razionalismo',
    'islamic-golden-age': 'Et√† d\'oro islamica',
    'cosmopolitanism': 'Cosmopolitismo',
    'geometry-as-ideology': 'Geometria come ideologia',
    'renaissance-humanism': 'Umanesimo rinascimentale',
    'neoplatonism': 'Neoplatonismo',
    'classical-revival': 'Rinascita classica',
    'art-and-power': 'Arte e potere',
    'christian-humanism': 'Umanesimo cristiano',
    'post-impressionism': 'Post-impressionismo',
    'crisis-of-positivism': 'Crisi del positivismo',
    'modernity': 'Modernit√†',
    'death-of-god': 'Morte di Dio',
    'expressionism': 'Espressionismo',
    'symbolism': 'Simbolismo',
    'modernism': 'Modernismo',
    'fragmentation': 'Frammentazione',
    'logical-positivism': 'Positivismo logico',
    'existentialism': 'Esistenzialismo',
    'totalitarianism': 'Totalitarismo',
  }
};

const MARKERS = [
  { year: -3000, label: "First writing (Sumer)" },
  { year: -776, label: "First Olympics" },
  { year: -509, label: "Roman Republic founded" },
  { year: -323, label: "Death of Alexander the Great" },
  { year: 0, label: "Year Zero" },
  { year: 476, label: "Fall of Western Rome" },
  { year: 622, label: "Hijra ‚Äî birth of Islam" },
  { year: 800, label: "Charlemagne crowned Emperor" },
  { year: 1066, label: "Norman Conquest" },
  { year: 1215, label: "Magna Carta" },
  { year: 1347, label: "Black Death arrives in Europe" },
  { year: 1453, label: "Fall of Constantinople" },
  { year: 1492, label: "Columbus reaches the Americas" },
  { year: 1517, label: "Luther's 95 Theses" },
  { year: 1648, label: "Peace of Westphalia" },
  { year: 1776, label: "American Independence" },
  { year: 1789, label: "French Revolution" },
  { year: 1815, label: "Waterloo" },
  { year: 1914, label: "World War I begins" },
  { year: 1945, label: "World War II ends" },
  { year: 1969, label: "Moon landing" },
  { year: 1989, label: "Fall of the Berlin Wall" },
];

const timeline = document.getElementById('timeline');

function formatThreadId(id) {
  const labels = THREAD_LABELS[currentLang] || THREAD_LABELS.en;
  return labels[id] || id.split('-').map(w => w[0].toUpperCase() + w.slice(1)).join(' ');
}

function renderSlice(slice) {
  const dims = Object.entries(slice.dimensions).map(([key, dim]) => {
    const funFact = dim.funFact ? `<div class="fun-fact">${dim.funFact}</div>` : '';
    return `
      <div class="dimension" data-dim="${key}">
        <div class="dim-header">
          <span class="dim-icon">${DIM_ICONS[key]}</span>
          <span class="dim-label-${key}">${dim.label}</span>
        </div>
        <div class="dim-content">${dim.content}${funFact}</div>
      </div>
    `;
  }).join('');

  const threads = (slice.threads || []).map(t =>
    `<span class="thread-tag" data-thread="${t}">${formatThreadId(t)}</span>`
  ).join('');

  const sources = (slice.sources || []).map(s =>
    `<a href="${s.url}" target="_blank" rel="noopener">${s.title}</a>`
  ).join('');
  const sourcesHtml = sources ? `
    <details class="card-sources" onclick="event.stopPropagation()">
      <summary>${t('sources')}</summary>
      ${sources}
    </details>` : '';

  const imageInlineHtml = slice.image ? `
    <img class="card-image-inline" data-src="${slice.image.url}" alt="${slice.image.caption}">
    <div class="card-image-caption-inline">${slice.image.caption}</div>` : '';

  const floatingImageHtml = slice.image ? `
    <div class="floating-image">
      <img data-src="${slice.image.url}" alt="${slice.image.caption}">
      <div class="floating-caption">${slice.image.caption}</div>
      ${slice.image.attribution ? `<div class="floating-attribution">${slice.image.attribution}</div>` : ''}
    </div>` : '';

  const mapLink = slice.location ? `<span class="card-map-link" data-year="${slice.year}" title="${slice.location.place}">üìç</span>` : '';

  const el = document.createElement('div');
  el.className = 'entry';
  el.dataset.year = slice.year;
  el.dataset.threads = JSON.stringify(slice.threads || []);
  el.innerHTML = `
    ${floatingImageHtml}
    <div class="card">
      ${imageInlineHtml}
      <div class="card-body">
        <div class="card-year">${slice.year}${mapLink}</div>
        <div class="card-title">${slice.title}</div>
        <div class="card-teaser">${slice.teaser}</div>
        <div class="card-threads">${threads}</div>
        <div class="expand-hint">${t('expandHint')}</div>
        <div class="card-details">
          ${dims}
          ${sourcesHtml}
        </div>
      </div>
    </div>
  `;

  // Expand/collapse
  el.addEventListener('click', (e) => {
    if (e.target.closest('.thread-tag') || e.target.closest('.card-sources') || e.target.closest('.card-map-link')) return;
    const details = el.querySelector('.card-details');
    if (el.classList.contains('expanded')) {
      details.style.maxHeight = details.scrollHeight + 'px';
      requestAnimationFrame(() => { details.style.maxHeight = '0'; });
      el.classList.remove('expanded');
    } else {
      el.classList.add('expanded');
      details.style.maxHeight = details.scrollHeight + 'px';
      details.addEventListener('transitionend', function handler() {
        if (el.classList.contains('expanded')) {
          details.style.maxHeight = 'none';
        }
        details.removeEventListener('transitionend', handler);
      });
      // Eagerly load floating image
      const floatImg = el.querySelector('.floating-image img[data-src]');
      if (floatImg && !floatImg.src) {
        floatImg.src = floatImg.dataset.src;
      }
    }
  });

  // Thread tag clicks
  el.querySelectorAll('.thread-tag').forEach(tag => {
    tag.addEventListener('click', (e) => {
      e.stopPropagation();
      const thread = tag.dataset.thread;
      if (activeThread === thread) {
        clearThread();
      } else {
        activateThread(thread);
      }
    });
  });

  // Map pin link
  const mapLinkEl = el.querySelector('.card-map-link');
  if (mapLinkEl) {
    mapLinkEl.addEventListener('click', (e) => {
      e.stopPropagation();
      flyToEntry(mapLinkEl.dataset.year);
    });
  }

  return el;
}

function renderMarker(marker) {
  const el = document.createElement('div');
  el.className = 'marker';
  const yearStr = marker.year < 0 ? `${Math.abs(marker.year)} BC` : marker.year === 0 ? '0' : marker.year;
  el.innerHTML = `
    <div class="marker-line"></div>
    <span class="marker-label">${yearStr} ‚Äî ${marker.label}</span>
  `;
  return el;
}

// Thread logic
// Narrative connectors between thread entries
const THREAD_NARRATIVES = {
  en: {
    'death-of-god': {
      '1889‚Üí1922': 'Nietzsche declared God dead in 1882. By 1922, the void he predicted had swallowed certainty itself ‚Äî Eliot\'s <em>Waste Land</em> mapped the wreckage, while logical positivism tried to rebuild meaning from scratch.',
    },
  },
  it: {
    'death-of-god': {
      '1889‚Üí1922': 'Nietzsche dichiar√≤ morto Dio nel 1882. Entro il 1922, il vuoto che aveva predetto aveva inghiottito la certezza stessa ‚Äî <em>La terra desolata</em> di Eliot ne mappava le macerie, mentre il positivismo logico tentava di ricostruire il significato da zero.',
    },
  },
};

function getThreadNarrative(threadId, yearFrom, yearTo) {
  const key = `${yearFrom}‚Üí${yearTo}`;
  const langNarratives = THREAD_NARRATIVES[currentLang] || THREAD_NARRATIVES.en;
  const narratives = langNarratives[threadId];
  return narratives && narratives[key] ? narratives[key] : null;
}

function activateThread(threadId) {
  activeThread = threadId;
  mapActiveThread = threadId; // keep both views in sync
  const entries = document.querySelectorAll('.entry');
  const matchingEntries = [];

  // Dim the main timeline line
  document.querySelector('.timeline-line').classList.add('thread-active');

  // First: record max-height of non-matching entries before hiding
  entries.forEach(entry => {
    const threads = JSON.parse(entry.dataset.threads || '[]');
    if (threads.includes(threadId)) {
      entry.classList.remove('thread-hidden');
      entry.classList.add('thread-highlighted');
      matchingEntries.push(entry);
    } else {
      // Store current height for smooth collapse
      entry.style.maxHeight = entry.scrollHeight + 'px';
      entry.classList.remove('thread-highlighted');
      requestAnimationFrame(() => {
        entry.classList.add('thread-hidden');
        entry.style.maxHeight = '0';
      });
    }
  });

  // Hide markers
  document.querySelectorAll('.marker').forEach(m => m.classList.add('thread-hidden'));

  // Remove old narratives
  document.querySelectorAll('.thread-narrative').forEach(n => n.remove());

  // Insert narrative connectors between matching entries
  for (let i = 0; i < matchingEntries.length - 1; i++) {
    const fromYear = matchingEntries[i].dataset.year;
    const toYear = matchingEntries[i + 1].dataset.year;
    const narrative = getThreadNarrative(threadId, fromYear, toYear);

    const connector = document.createElement('div');
    connector.className = 'thread-narrative';

    if (narrative) {
      connector.innerHTML = `<span class="narrative-arrow">‚Üì</span>${narrative}`;
    } else {
      const gap = parseInt(toYear) - parseInt(fromYear);
      connector.innerHTML = `<span class="narrative-arrow">‚Üì</span><em>${gap} ${t('yearsLater')}</em>`;
    }

    // Insert after the current matching entry
    matchingEntries[i].after(connector);
  }

  // Draw SVG thread lines
  drawThreadLines(matchingEntries);

  // Update all thread tags
  document.querySelectorAll('.thread-tag').forEach(t => {
    t.classList.toggle('active', t.dataset.thread === threadId);
  });

  // Show banner
  const count = matchingEntries.length;
  document.getElementById('threadName').textContent = formatThreadId(threadId);
  document.getElementById('threadCount').textContent = `${count} ${count === 1 ? t('entry') : t('entries')}`;
  document.getElementById('threadBanner').classList.add('visible');

  // Scroll to first matching entry
  if (matchingEntries.length > 0) {
    setTimeout(() => {
      matchingEntries[0].scrollIntoView({ behavior: 'smooth', block: 'center' });
    }, 300);
  }
}

function clearThread() {
  activeThread = null;
  mapActiveThread = null; // keep both views in sync

  // Restore timeline line
  document.querySelector('.timeline-line').classList.remove('thread-active');

  document.querySelectorAll('.entry').forEach(e => {
    e.classList.remove('thread-hidden', 'thread-highlighted');
    e.style.maxHeight = '';
  });
  document.querySelectorAll('.marker').forEach(m => m.classList.remove('thread-hidden'));
  document.querySelectorAll('.thread-tag').forEach(t => t.classList.remove('active'));
  document.querySelectorAll('.thread-narrative').forEach(n => n.remove());
  clearThreadLines();
  document.getElementById('threadBanner').classList.remove('visible');
}

// SVG thread lines
function drawThreadLines(matchingEntries) {
  clearThreadLines();
  if (matchingEntries.length < 2) return;

  // Delay drawing until layout has settled after hide/show transitions
  setTimeout(() => {
    const container = document.querySelector('.timeline-container');
    const containerRect = container.getBoundingClientRect();
    const scrollTop = container.scrollTop || 0;

    const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    svg.classList.add('thread-lines-svg');
    // Set SVG to cover the full scrollable height of the container
    const fullHeight = container.scrollHeight;
    svg.setAttribute('width', '100%');
    svg.setAttribute('height', fullHeight + 'px');
    svg.style.height = fullHeight + 'px';
    container.appendChild(svg);

    // Add glow filter
    const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
    defs.innerHTML = `
      <filter id="threadGlow" x="-50%" y="-50%" width="200%" height="200%">
        <feGaussianBlur stdDeviation="4" result="blur"/>
        <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
      </filter>
    `;
    svg.appendChild(defs);

    const timelineX = container.offsetWidth / 2;

    for (let i = 0; i < matchingEntries.length - 1; i++) {
      const fromEntry = matchingEntries[i];
      const toEntry = matchingEntries[i + 1];

      const fromRect = fromEntry.getBoundingClientRect();
      const toRect = toEntry.getBoundingClientRect();

      // Dot is at top: 24px of the entry, offset from container top
      const fromY = fromRect.top - containerRect.top + scrollTop + 30;
      const toY = toRect.top - containerRect.top + scrollTop + 30;

      const midY = (fromY + toY) / 2;
      const curveOffset = 30;

      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute('d', `M ${timelineX} ${fromY} Q ${timelineX + curveOffset} ${midY} ${timelineX} ${toY}`);
      path.setAttribute('fill', 'none');
      path.setAttribute('stroke', 'rgba(124,111,247,0.35)');
      path.setAttribute('stroke-width', '3');
      path.setAttribute('stroke-linecap', 'round');
      path.setAttribute('filter', 'url(#threadGlow)');

      // Animate
      const length = path.getTotalLength ? path.getTotalLength() : 500;
      path.setAttribute('stroke-dasharray', length);
      path.setAttribute('stroke-dashoffset', length);
      path.style.transition = `stroke-dashoffset 0.8s ease ${i * 0.2}s`;

      svg.appendChild(path);

      requestAnimationFrame(() => {
        path.setAttribute('stroke-dashoffset', '0');
      });
    }
  }, 500); // wait for hide/show transitions to finish
}

function clearThreadLines() {
  document.querySelectorAll('.thread-lines-svg').forEach(s => s.remove());
}

document.getElementById('threadClose').addEventListener('click', clearThread);

// Lazy image loading
function lazyLoadImages() {
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(e => {
      if (e.isIntersecting) {
        const img = e.target;
        img.src = img.dataset.src;
        img.onload = () => img.classList.add('loaded');
        observer.unobserve(img);
      }
    });
  }, { rootMargin: '200px' });

  document.querySelectorAll('[data-src]').forEach(img => observer.observe(img));
}

// Scroll reveal
function setupScrollReveal() {
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(e => { if (e.isIntersecting) e.target.classList.add('visible'); });
  }, { threshold: 0.1 });
  document.querySelectorAll('.entry').forEach(el => observer.observe(el));
}

// Update UI labels for current language
function updateUILabels() {
  document.getElementById('subtitle').textContent = t('subtitle');
  document.querySelectorAll('#filters .filter-btn').forEach(btn => {
    btn.textContent = t(btn.dataset.dim);
  });
  document.querySelector('.thread-banner span:first-child').innerHTML =
    `üßµ ${t('thread')}: <span class="thread-name" id="threadName"></span>`;
  document.documentElement.lang = currentLang;
}

// Load slices for current language and rebuild timeline
function loadSlices() {
  // Clear active thread
  if (activeThread) clearThread();

  fetch(t('slicesFile'))
    .then(r => r.json())
    .then(data => {
      SLICES = data;
      timeline.innerHTML = '';

      const items = [
        ...SLICES.map(s => ({ type: 'slice', year: parseInt(s.year), data: s })),
        ...MARKERS.map(m => ({ type: 'marker', year: m.year, data: m })),
      ];
      items.sort((a, b) => a.year - b.year || (a.type === 'marker' ? -1 : 1));

      items.forEach((item) => {
        if (item.type === 'slice') {
          timeline.appendChild(renderSlice(item.data));
        } else {
          timeline.appendChild(renderMarker(item.data));
        }
      });

      lazyLoadImages();
      setupScrollReveal();
    });
}

// Language switcher
document.querySelectorAll('.lang-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    const lang = btn.dataset.lang;
    if (lang === currentLang) return;
    currentLang = lang;
    document.querySelectorAll('.lang-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    updateUILabels();
    loadSlices();
  });
});

// Init: set correct lang button active and load
(function init() {
  document.querySelectorAll('.lang-btn').forEach(b => {
    b.classList.toggle('active', b.dataset.lang === currentLang);
  });
  updateUILabels();
  loadSlices();
})();

// ========================================
// MAP VIEW
// ========================================

let map = null;
let mapMarkers = [];
let mapArcs = [];
let mapActiveThread = null;
let mapIsPlaying = false;

// Initialize Leaflet map (lazy ‚Äî only on first toggle)
function initMap() {
  if (map) return;

  map = L.map('map', {
    center: [42, 20],
    zoom: 4,
    zoomControl: false,
    attributionControl: false,
  });

  // CartoDB Dark Matter ‚Äî matches our aesthetic
  L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
    maxZoom: 18,
    subdomains: 'abcd',
  }).addTo(map);

  // Zoom control in bottom-right (away from time slider)
  L.control.zoom({ position: 'bottomright' }).addTo(map);

  // Attribution (small, bottom-right)
  L.control.attribution({ position: 'bottomright', prefix: false })
    .addAttribution('¬© <a href="https://carto.com/">CARTO</a> ¬© <a href="https://www.openstreetmap.org/">OSM</a>')
    .addTo(map);
}

function createMapMarker(slice) {
  if (!slice.location) return null;

  const icon = L.divIcon({
    className: '',
    html: `<div class="map-marker-wrap">
             <div class="map-marker" data-year="${slice.year}"></div>
             <div class="map-marker-ring"></div>
             <div class="map-marker-label">${slice.year} ¬∑ ${slice.location.place}</div>
           </div>`,
    iconSize: [40, 40],
    iconAnchor: [20, 20],
    popupAnchor: [0, -24],
  });

  const marker = L.marker([slice.location.lat, slice.location.lon], { icon });

  // Build popup content
  const threads = (slice.threads || []).map(t =>
    `<span class="thread-tag" data-thread="${t}" onclick="event.stopPropagation(); activateMapThread('${t}')">${formatThreadId(t)}</span>`
  ).join('');

  const popup = L.popup({
    maxWidth: 320,
    minWidth: 240,
    closeButton: true,
  }).setContent(`
    <div class="map-popup-year">${slice.year}</div>
    <div class="map-popup-title">${slice.title}</div>
    <div class="map-popup-teaser">${slice.teaser}</div>
    <div class="map-popup-threads">${threads}</div>
    <a class="map-popup-link" onclick="scrollToEntry('${slice.year}')">View in timeline ‚Üí</a>
  `);

  marker.bindPopup(popup);
  marker._sliceYear = parseInt(slice.year);
  marker._sliceThreads = slice.threads || [];

  return marker;
}

function populateMap() {
  // Clear existing markers
  mapMarkers.forEach(m => map.removeLayer(m));
  mapMarkers = [];
  clearMapArcs();

  SLICES.forEach(slice => {
    const marker = createMapMarker(slice);
    if (marker) {
      marker.addTo(map);
      mapMarkers.push(marker);
    }
  });

  // Update slider range
  if (SLICES.length > 0) {
    const years = SLICES.map(s => parseInt(s.year)).sort((a, b) => a - b);
    const minY = Math.max(years[0] - 100, -3000);
    const maxY = new Date().getFullYear();
    const slider = document.getElementById('timeSlider');
    slider.min = minY;
    slider.max = maxY;
    slider.value = maxY;
    document.getElementById('timeYearDisplay').textContent = maxY;
  }

  // Fit bounds to show all markers
  if (mapMarkers.length > 1) {
    const group = L.featureGroup(mapMarkers);
    map.fitBounds(group.getBounds().pad(0.3), { maxZoom: 6 });
  }

  // Update map lang buttons
  document.querySelectorAll('[data-map="1"]').forEach(b => {
    b.classList.toggle('active', b.dataset.lang === currentLang);
  });

  // Re-apply thread if active
  if (mapActiveThread) {
    activateMapThread(mapActiveThread);
  }
}

// Time slider logic
function updateTimeFilter(maxYear) {
  document.getElementById('timeYearDisplay').textContent = maxYear;

  mapMarkers.forEach(marker => {
    const markerEl = marker.getElement();
    if (!markerEl) return;
    const dot = markerEl.querySelector('.map-marker');
    const label = markerEl.querySelector('.map-marker-label');
    if (!dot) return;

    if (marker._sliceYear <= maxYear) {
      const wasHidden = dot.classList.contains('hidden-by-time');
      dot.classList.remove('hidden-by-time');
      if (label) label.style.opacity = '1';
      if (wasHidden) {
        dot.classList.add('arriving');
        setTimeout(() => dot.classList.remove('arriving'), 1000);
      }
    } else {
      dot.classList.add('hidden-by-time');
      dot.classList.remove('arriving');
      if (label) label.style.opacity = '0';
    }
  });

  // Redraw arcs if thread is active ‚Äî only show arcs where both endpoints are visible
  if (mapActiveThread) {
    drawMapArcs(mapActiveThread, maxYear);
  }
}

document.getElementById('timeSlider').addEventListener('input', (e) => {
  updateTimeFilter(parseInt(e.target.value));
});

// Auto-play ‚Äî density-proportional speed
function startMapPlay() {
  mapIsPlaying = true;
  document.getElementById('timePlayBtn').textContent = '‚è∏';
  document.getElementById('timePlayBtn').classList.add('playing');

  const slider = document.getElementById('timeSlider');
  const min = parseInt(slider.min);
  const max = parseInt(slider.max);

  // Start from minimum
  slider.value = min;
  updateTimeFilter(min);

  // Build a speed map: faster in empty stretches, slower near entries
  const entryYears = SLICES.map(s => parseInt(s.year)).sort((a, b) => a - b);

  function getSpeed(year) {
    // Find distance to nearest entry
    let minDist = Infinity;
    for (const ey of entryYears) {
      minDist = Math.min(minDist, Math.abs(year - ey));
    }

    // Near an entry (within 30 years): slow ‚Äî 2 years/frame
    // Far from any entry (>200 years): fast ‚Äî 15 years/frame
    // In between: interpolate
    if (minDist <= 30) return 2;
    if (minDist >= 200) return 15;
    return 2 + (minDist - 30) / (200 - 30) * 13;
  }

  // Pause briefly when hitting an entry
  let pauseFrames = 0;

  function tick() {
    if (!mapIsPlaying) return;

    const current = parseInt(slider.value);
    if (current >= max) {
      stopMapPlay();
      return;
    }

    // If pausing at an entry, count down
    if (pauseFrames > 0) {
      pauseFrames--;
      requestAnimationFrame(tick);
      return;
    }

    const speed = getSpeed(current);
    const next = Math.min(current + Math.round(speed), max);
    slider.value = next;
    updateTimeFilter(next);

    // Check if we just passed an entry ‚Äî pause for a beat
    for (const ey of entryYears) {
      if (ey > current && ey <= next) {
        pauseFrames = 45; // ~0.75 seconds at 60fps
        break;
      }
    }

    requestAnimationFrame(tick);
  }

  requestAnimationFrame(tick);
}

function stopMapPlay() {
  mapIsPlaying = false;
  document.getElementById('timePlayBtn').textContent = '‚ñ∂';
  document.getElementById('timePlayBtn').classList.remove('playing');
}

document.getElementById('timePlayBtn').addEventListener('click', () => {
  if (mapIsPlaying) stopMapPlay();
  else startMapPlay();
});

// Thread arcs on map
function activateMapThread(threadId) {
  mapActiveThread = threadId;

  // Also activate in timeline
  activeThread = threadId;

  // Dim non-matching markers
  mapMarkers.forEach(marker => {
    const el = marker.getElement();
    if (!el) return;
    const dot = el.querySelector('.map-marker');
    if (!dot) return;
    if (marker._sliceThreads.includes(threadId)) {
      dot.classList.remove('dimmed');
    } else {
      dot.classList.add('dimmed');
    }
  });

  // Draw arcs
  const maxYear = parseInt(document.getElementById('timeSlider').value);
  drawMapArcs(threadId, maxYear);

  // Show banner
  document.getElementById('mapThreadName').textContent = formatThreadId(threadId);
  document.getElementById('mapThreadLabel').textContent = t('thread');
  document.getElementById('mapThreadBanner').classList.add('visible');

  // Fit bounds to thread entries
  const threadMarkers = mapMarkers.filter(m => m._sliceThreads.includes(threadId));
  if (threadMarkers.length > 1) {
    const group = L.featureGroup(threadMarkers);
    map.fitBounds(group.getBounds().pad(0.4), { maxZoom: 6 });
  }
}

function clearMapThread() {
  mapActiveThread = null;
  activeThread = null; // keep both views in sync

  mapMarkers.forEach(marker => {
    const el = marker.getElement();
    if (!el) return;
    const dot = el.querySelector('.map-marker');
    if (dot) dot.classList.remove('dimmed');
  });

  clearMapArcs();
  document.getElementById('mapThreadBanner').classList.remove('visible');
}

function drawMapArcs(threadId, maxYear) {
  clearMapArcs();

  const threadMarkers = mapMarkers
    .filter(m => m._sliceThreads.includes(threadId) && m._sliceYear <= maxYear)
    .sort((a, b) => a._sliceYear - b._sliceYear);

  if (threadMarkers.length < 2) return;

  for (let i = 0; i < threadMarkers.length - 1; i++) {
    const from = threadMarkers[i].getLatLng();
    const to = threadMarkers[i + 1].getLatLng();

    // Create curved arc using intermediate points
    const latlngs = generateArc(from, to, 50);

    // Background glow arc (wider, more transparent)
    const glowArc = L.polyline(latlngs, {
      color: 'rgba(124,111,247,0.2)',
      weight: 8,
      lineCap: 'round',
      lineJoin: 'round',
      interactive: false,
    }).addTo(map);

    // Main arc (solid, bright)
    const arc = L.polyline(latlngs, {
      color: 'rgba(124,111,247,0.7)',
      weight: 3,
      lineCap: 'round',
      lineJoin: 'round',
      interactive: false,
    }).addTo(map);

    // Animate via progressive point reveal
    const animDelay = i * 400;
    glowArc.setLatLngs([]);
    arc.setLatLngs([]);
    
    let frame = 0;
    const totalFrames = latlngs.length;
    setTimeout(() => {
      function animateArc() {
        if (frame >= totalFrames) return;
        frame += 2; // 2 points per frame for speed
        const partial = latlngs.slice(0, Math.min(frame, totalFrames));
        glowArc.setLatLngs(partial);
        arc.setLatLngs(partial);
        if (frame < totalFrames) requestAnimationFrame(animateArc);
      }
      animateArc();
    }, animDelay);

    // Year label at midpoint
    const midIdx = Math.floor(latlngs.length / 2);
    const fromYear = threadMarkers[i]._sliceYear;
    const toYear = threadMarkers[i + 1]._sliceYear;
    const gap = toYear - fromYear;
    const yearLabel = L.marker(latlngs[midIdx], {
      icon: L.divIcon({
        className: '',
        html: `<div style="
          color:rgba(124,111,247,0.85);
          font-family:var(--mono);
          font-size:0.65rem;
          font-weight:600;
          text-shadow:0 0 8px rgba(124,111,247,0.5), 0 1px 4px rgba(0,0,0,0.8);
          white-space:nowrap;
          pointer-events:none;
        ">${gap} yrs ‚Üí</div>`,
        iconSize: [60, 16],
        iconAnchor: [30, 8],
      }),
      interactive: false,
    }).addTo(map);

    mapArcs.push(glowArc, arc, yearLabel);
  }
}

function clearMapArcs() {
  if (map) mapArcs.forEach(a => map.removeLayer(a));
  mapArcs = [];
}

// Generate a curved arc between two points
function generateArc(from, to, numPoints) {
  const points = [];
  const latDiff = to.lat - from.lat;
  const lngDiff = to.lng - from.lng;
  const dist = Math.sqrt(latDiff * latDiff + lngDiff * lngDiff);

  for (let i = 0; i <= numPoints; i++) {
    const t = i / numPoints;
    const lat = from.lat + latDiff * t;
    const lng = from.lng + lngDiff * t;

    // Offset perpendicular to create curve
    // Curve height proportional to distance
    const curveHeight = dist * 0.15;
    const offset = Math.sin(t * Math.PI) * curveHeight;

    // Perpendicular direction
    const perpLat = -lngDiff / dist * offset;
    const perpLng = latDiff / dist * offset;

    points.push([lat + perpLat, lng + perpLng]);
  }
  return points;
}

// View toggle
function showMapView() {
  initMap();
  document.getElementById('mapView').classList.add('active');
  document.getElementById('mapTimeControl').classList.add('visible');
  document.getElementById('viewToggle').classList.add('active');
  document.getElementById('viewToggle').textContent = 'üìú';
  document.getElementById('viewToggle').title = 'Timeline view';

  // Hide timeline's thread banner ‚Äî header is z-100, above map z-50
  document.getElementById('threadBanner').classList.remove('visible');

  // Fix Leaflet rendering (needs invalidateSize after display:block)
  setTimeout(() => {
    map.invalidateSize();
    populateMap();
    // populateMap handles mapActiveThread re-activation
  }, 150);
}

function showTimelineView() {
  stopMapPlay();
  document.getElementById('mapView').classList.remove('active');
  document.getElementById('mapTimeControl').classList.remove('visible');
  document.getElementById('viewToggle').classList.remove('active');
  document.getElementById('viewToggle').textContent = 'üó∫Ô∏è';
  document.getElementById('viewToggle').title = 'Map view';

  // Sync thread state: apply whatever thread is active (or clear)
  if (activeThread) {
    // Re-apply visual state on the timeline DOM
    activateThread(activeThread);
  } else {
    clearThread();
  }
}

function scrollToEntry(year) {
  showTimelineView();
  setTimeout(() => {
    const entry = document.querySelector(`.entry[data-year="${year}"]`);
    if (entry) {
      entry.scrollIntoView({ behavior: 'smooth', block: 'center' });
      // Flash highlight
      entry.style.transition = 'box-shadow 0.3s ease';
      entry.querySelector('.card').style.boxShadow = '0 0 30px rgba(124,111,247,0.4)';
      setTimeout(() => {
        entry.querySelector('.card').style.boxShadow = '';
      }, 1500);
    }
  }, 200);
}

function flyToEntry(year) {
  const slice = SLICES.find(s => String(s.year) === String(year));
  if (!slice || !slice.location) return;
  showMapView();
  setTimeout(() => {
    map.flyTo([slice.location.lat, slice.location.lon], 8, { duration: 1.2 });
    // Open the marker popup
    const marker = mapMarkers.find(m => String(m._sliceYear) === String(year));
    if (marker) {
      setTimeout(() => marker.openPopup(), 1300);
    }
  }, 200);
}

document.getElementById('viewToggle').addEventListener('click', () => {
  if (document.getElementById('mapView').classList.contains('active')) {
    showTimelineView();
  } else {
    showMapView();
  }
});

document.getElementById('mapBackBtn').addEventListener('click', showTimelineView);
document.getElementById('mapThreadClose').addEventListener('click', clearMapThread);
document.getElementById('mapThreadBanner').addEventListener('click', clearMapThread);

// Map lang switcher
document.querySelectorAll('[data-map="1"]').forEach(btn => {
  btn.addEventListener('click', () => {
    const lang = btn.dataset.lang;
    if (lang === currentLang) return;
    currentLang = lang;
    // Update both header lang buttons
    document.querySelectorAll('.lang-btn').forEach(b => {
      b.classList.toggle('active', b.dataset.lang === currentLang);
    });
    updateUILabels();
    loadSlices();
    // Repopulate map after slices load
    setTimeout(populateMap, 500);
  });
});
</script>

</body>
</html>
